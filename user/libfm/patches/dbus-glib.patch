From cf809d9d44267f286697d9b41d3e72d13937256b Mon Sep 17 00:00:00 2001
From: Andriy Grytsenko <andrej@rep.kiev.ua>
Date: Tue, 9 Feb 2021 20:28:07 +0200
Subject: [PATCH] UDisks2 migration.

Migrate away from dbus-glib-1 wihich is deprecated.
Migrate from Udisks to Udisks2 DBus API.
---
 NEWS                                 |    7 +
 configure.ac                         |    8 +-
 po/POTFILES.in                       |    4 +-
 src/Makefile.am                      |    2 -
 src/base/fm-action.c                 |    9 +-
 src/udisks/dbus-utils.c              |   13 +-
 src/udisks/dbus-utils.h              |   84 +-
 src/udisks/g-udisks-device.c         |  436 +++++-----
 src/udisks/g-udisks-device.h         |   91 +-
 src/udisks/g-udisks-drive.c          |  378 +++++++--
 src/udisks/g-udisks-drive.h          |   26 +-
 src/udisks/g-udisks-mount.c          |  113 ++-
 src/udisks/g-udisks-mount.h          |   18 +-
 src/udisks/g-udisks-volume-monitor.c |  693 +++++++++-------
 src/udisks/g-udisks-volume-monitor.h |   14 -
 src/udisks/g-udisks-volume.c         |  348 +++++---
 src/udisks/g-udisks-volume.h         |   22 +-
 src/udisks/gen-binding               |    3 -
 src/udisks/udisks-device.h           | 1147 --------------------------
 src/udisks/udisks.h                  |  927 ---------------------
 20 files changed, 1324 insertions(+), 3019 deletions(-)
 delete mode 100755 src/udisks/gen-binding
 delete mode 100644 src/udisks/udisks-device.h
 delete mode 100644 src/udisks/udisks.h

diff --git a/NEWS b/NEWS
index 79d6082c..cbdfd8b1 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,10 @@
+Changes on 1.4.0 since 1.3.2:
+
+* Migrated away from dbus-glib-1 which is deprecated for years.
+
+* Migrated from Udisks (which is not used anymore anywhere) to Udisks2 DBus API.
+
+
 Changes on 1.3.2 since 1.3.1:
 
 * Fixed all/allfiles parse conditions in FmAction, it was inverted.
diff --git a/configure.ac b/configure.ac
index bf6b07fd..6d7396a5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -184,7 +184,7 @@ fi
 
 AC_ARG_ENABLE(udisks,
     [AC_HELP_STRING([--enable-udisks],
-        [build libfm with udisks support (Linux only) @<:@default=yes@:>@])],
+        [build libfm with udisks support (Linux only) @<:@default=no@:>@])],
     [enable_udisks="${enableval}"],
     [enable_udisks=no]
 )
@@ -194,12 +194,6 @@ AM_CONDITIONAL(ENABLE_UDISKS, test x"$enable_udisks" = x"yes")
 if test x"$enable_udisks" = x"yes"; then
     # turn on udisks support
     AC_DEFINE_UNQUOTED(USE_UDISKS, [1], [Enable UDisks support])
-
-    # test for availability of dbus
-    dbus_modules="dbus-glib-1"
-    PKG_CHECK_MODULES(DBUS, [$dbus_modules])
-    AC_SUBST(DBUS_CFLAGS)
-    AC_SUBST(DBUS_LIBS)
 fi
 
 AC_ARG_ENABLE([exif],
diff --git a/po/POTFILES.in b/po/POTFILES.in
index f7d3fa5e..44c271e1 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -48,4 +48,6 @@ src/modules/gtk-fileprop-x-desktop.c
 src/modules/gtk-menu-trash.c
 src/tools/libfm-pref-apps.c
 src/tools/lxshortcut.c
-src/udisks/g-udisks-device.c
+src/udisks/g-udisks-drive.c
+src/udisks/g-udisks-mount.c
+src/udisks/g-udisks-volume.c
diff --git a/src/Makefile.am b/src/Makefile.am
index 8864b122..ebb5dfd1 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -260,7 +260,6 @@ libfm_la_SOURCES = \
 libfm_la_CFLAGS = \
 	$(GIO_CFLAGS) \
 	$(MENU_CACHE_CFLAGS) \
-	$(DBUS_CFLAGS) \
 	$(EXIF_CFLAGS) \
 	-DPACKAGE_DATA_DIR=\""$(datadir)/libfm"\" \
 	-DPACKAGE_MODULES_DIR=\""$(libdir)/@PACKAGE@/modules"\" \
@@ -269,7 +268,6 @@ libfm_la_CFLAGS = \
 libfm_la_LIBADD = \
 	$(GIO_LIBS) \
 	$(MENU_CACHE_LIBS) \
-	$(DBUS_LIBS) \
 	$(EXIF_LIBS) \
 	$(INTLLIBS) \
 	$(NULL)
diff --git a/src/base/fm-action.c b/src/base/fm-action.c
index a4ec7d20..39e8bf23 100644
--- a/src/base/fm-action.c
+++ b/src/base/fm-action.c
@@ -1729,6 +1729,10 @@ static gboolean _matches_cond(FmFileInfoList *files, FmFileInfo *location,
     gsize len;
     int num;
     gboolean match = TRUE, found, match_num;
+#if GLIB_CHECK_VERSION(2, 24, 0)
+    GDBusConnection *conn;
+    GVariant *result;
+#endif
 
     if (files != NULL)
         flist = fm_file_info_list_peek_head_link(files);
@@ -1832,8 +1836,8 @@ static gboolean _matches_cond(FmFileInfoList *files, FmFileInfo *location,
             g_string_free(str, TRUE);
             break;
         case CONDITION_TYPE_DBUS: /* ShowIfRegistered */
-#if defined(ENABLE_DBUS) && GLIB_CHECK_VERSION(2, 24, 0)
-            str = g_string_size_new(64);
+#if GLIB_CHECK_VERSION(2, 24, 0)
+            str = g_string_sized_new(64);
             _expand_params(str, cond->str, root, TRUE, NULL);
             /* DBus call is taken from GLib sources: gio/tests/gdbus-names.c */
             conn = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, NULL);
@@ -1852,6 +1856,7 @@ static gboolean _matches_cond(FmFileInfoList *files, FmFileInfo *location,
                 g_variant_unref(result);
             }
             g_string_free(str, TRUE);
+            g_object_unref(conn);
 #endif
             break;
         case CONDITION_TYPE_OUT_TRUE: /* ShowIfTrue */
diff --git a/src/udisks/dbus-utils.c b/src/udisks/dbus-utils.c
index aa235a6f..6122edb6 100644
--- a/src/udisks/dbus-utils.c
+++ b/src/udisks/dbus-utils.c
@@ -26,24 +26,13 @@
 #include "dbus-utils.h"
 #include <gio/gio.h>
 
-GHashTable* dbus_get_all_props(DBusGProxy* proxy, const char* iface, GError** err)
-{
-    GHashTable* props = NULL;
-    dbus_g_proxy_call(proxy, "GetAll", err,
-                      G_TYPE_STRING, iface, G_TYPE_INVALID,
-                      dbus_g_type_get_map("GHashTable", G_TYPE_STRING, G_TYPE_VALUE), &props, G_TYPE_INVALID);
-    return props;
-}
-
-
 GError* g_udisks_error_to_gio_error(GError* error)
 {
     if(error)
     {
         int code = G_IO_ERROR_FAILED;
         error = g_error_new_literal(G_IO_ERROR, code, error->message);
-        return error;
     }
-    return NULL;
+    return error;
 }
 
diff --git a/src/udisks/dbus-utils.h b/src/udisks/dbus-utils.h
index d2128223..5fb2dd4d 100644
--- a/src/udisks/dbus-utils.h
+++ b/src/udisks/dbus-utils.h
@@ -2,6 +2,7 @@
  *      dbus-utils.h
  *
  *      Copyright 2010 PCMan <pcman.tw@gmail.com>
+ *      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
  *
  *      This program is free software; you can redistribute it and/or modify
  *      it under the terms of the GNU General Public License as published by
@@ -22,83 +23,42 @@
 #ifndef __DBUS_UTILS_H__
 #define __DBUS_UTILS_H__
 
-#include <glib.h>
-#include <dbus/dbus-glib.h>
+#include <gio/gio.h>
 
 G_BEGIN_DECLS
 
-// char* dbus_get_prop(DBusGProxy* proxy, const char* iface, const char* prop);
-GHashTable* dbus_get_all_props(DBusGProxy* proxy, const char* iface, GError** err);
-
-static inline const char* dbus_prop_str(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_string(val) : NULL;
-}
-
-static inline const char* dbus_prop_obj_path(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? (char*)g_value_get_boxed(val) : NULL;
-}
-
-static inline const char** dbus_prop_strv(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? (const char**)g_value_get_boxed(val) : NULL;
-}
-
-static inline char* dbus_prop_dup_str(GHashTable* props, const char* name)
+static inline char* dbus_prop_dup_str(GDBusProxy* proxy, const char* name)
 {
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_dup_string(val) : NULL;
+    GVariant *var = g_dbus_proxy_get_cached_property(proxy, name);
+    char *str = var ? g_variant_dup_string(var, NULL) : NULL;
+    if (var) g_variant_unref(var);
+    return str;
 }
 
-static inline char* dbus_prop_dup_obj_path(GHashTable* props, const char* name)
+static inline char** dbus_prop_dup_strv(GDBusProxy* proxy, const char* name)
 {
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_strdup((char*)g_value_get_boxed(val)) : NULL;
+    GVariant *var = g_dbus_proxy_get_cached_property(proxy, name);
+    char **strv = var ? g_variant_dup_bytestring_array(var, NULL) : NULL;
+    if (var) g_variant_unref(var);
+    return strv;
 }
 
-static inline char** dbus_prop_dup_strv(GHashTable* props, const char* name)
+static inline gboolean dbus_prop_bool(GDBusProxy* proxy, const char* name)
 {
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_dup_boxed(val) : NULL;
+    GVariant *var = g_dbus_proxy_get_cached_property(proxy, name);
+    gboolean val = var ? g_variant_get_boolean(var) : FALSE;
+    if (var) g_variant_unref(var);
+    return val;
 }
 
-static inline gboolean dbus_prop_bool(GHashTable* props, const char* name)
+static inline guint dbus_prop_uint(GDBusProxy* proxy, const char* name)
 {
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_boolean(val) : FALSE;
+    GVariant *var = g_dbus_proxy_get_cached_property(proxy, name);
+    guint val = var ? g_variant_get_uint32(var) : 0;
+    if (var) g_variant_unref(var);
+    return val;
 }
 
-static inline gint dbus_prop_int(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_int(val) : 0;
-}
-
-static inline guint dbus_prop_uint(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_uint(val) : 0;
-}
-
-static inline gint64 dbus_prop_int64(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_int64(val) : 0;
-}
-
-static inline guint64 dbus_prop_uint64(GHashTable* props, const char* name)
-{
-    GValue* val = (GValue*)g_hash_table_lookup(props, name);
-    return val ? g_value_get_uint64(val) : 0;
-}
-
-// GHashTable* dbus_get_prop_async();
-// GHashTable* dbus_get_all_props_async();
-
 GError* g_udisks_error_to_gio_error(GError* error);
 
 G_END_DECLS
diff --git a/src/udisks/g-udisks-device.c b/src/udisks/g-udisks-device.c
index 773525ec..d7164331 100644
--- a/src/udisks/g-udisks-device.c
+++ b/src/udisks/g-udisks-device.c
@@ -1,6 +1,7 @@
 //      g-udisks-device.c
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -21,46 +22,43 @@
 #include <config.h>
 #endif
 
-#include "g-udisks-device.h"
+#include "g-udisks-mount.h"
+#include "g-udisks-drive.h"
 #include "dbus-utils.h"
-#include "udisks-device.h"
+
 #include <string.h>
-#include <glib/gi18n-lib.h>
 
-/* This array is taken from gnome-disk-utility: gdu-volume.c
- * Copyright (C) 2007 David Zeuthen, licensed under GNU LGPL
- */
-static const struct
+struct _GUDisksDevice
 {
-        const char *disc_type;
-        const char *icon_name;
-        const char *ui_name;
-        const char *ui_name_blank;
-} disc_data[] = {
-  /* Translator: The word "blank" is used as an adjective, e.g. we are decsribing discs that are already blank */
-  {"optical_cd",             "media-optical-cd-rom",        N_("CD-ROM Disc"),     N_("Blank CD-ROM Disc")},
-  {"optical_cd_r",           "media-optical-cd-r",          N_("CD-R Disc"),       N_("Blank CD-R Disc")},
-  {"optical_cd_rw",          "media-optical-cd-rw",         N_("CD-RW Disc"),      N_("Blank CD-RW Disc")},
-  {"optical_dvd",            "media-optical-dvd-rom",       N_("DVD-ROM Disc"),    N_("Blank DVD-ROM Disc")},
-  {"optical_dvd_r",          "media-optical-dvd-r",         N_("DVD-ROM Disc"),    N_("Blank DVD-ROM Disc")},
-  {"optical_dvd_rw",         "media-optical-dvd-rw",        N_("DVD-RW Disc"),     N_("Blank DVD-RW Disc")},
-  {"optical_dvd_ram",        "media-optical-dvd-ram",       N_("DVD-RAM Disc"),    N_("Blank DVD-RAM Disc")},
-  {"optical_dvd_plus_r",     "media-optical-dvd-r-plus",    N_("DVD+R Disc"),      N_("Blank DVD+R Disc")},
-  {"optical_dvd_plus_rw",    "media-optical-dvd-rw-plus",   N_("DVD+RW Disc"),     N_("Blank DVD+RW Disc")},
-  {"optical_dvd_plus_r_dl",  "media-optical-dvd-dl-r-plus", N_("DVD+R DL Disc"),   N_("Blank DVD+R DL Disc")},
-  {"optical_dvd_plus_rw_dl", "media-optical-dvd-dl-r-plus", N_("DVD+RW DL Disc"),  N_("Blank DVD+RW DL Disc")},
-  {"optical_bd",             "media-optical-bd-rom",        N_("Blu-Ray Disc"),    N_("Blank Blu-Ray Disc")},
-  {"optical_bd_r",           "media-optical-bd-r",          N_("Blu-Ray R Disc"),  N_("Blank Blu-Ray R Disc")},
-  {"optical_bd_re",          "media-optical-bd-re",         N_("Blu-Ray RW Disc"), N_("Blank Blu-Ray RW Disc")},
-  {"optical_hddvd",          "media-optical-hddvd-rom",     N_("HD DVD Disc"),     N_("Blank HD DVD Disc")},
-  {"optical_hddvd_r",        "media-optical-hddvd-r",       N_("HD DVD-R Disc"),   N_("Blank HD DVD-R Disc")},
-  {"optical_hddvd_rw",       "media-optical-hddvd-rw",      N_("HD DVD-RW Disc"),  N_("Blank HD DVD-RW Disc")},
-  {"optical_mo",             "media-optical-mo",            N_("MO Disc"),         N_("Blank MO Disc")},
-  {"optical_mrw",            "media-optical-mrw",           N_("MRW Disc"),        N_("Blank MRW Disc")},
-  {"optical_mrw_w",          "media-optical-mrw-w",         N_("MRW/W Disc"),      N_("Blank MRW/W Disc")},
-  {NULL, NULL, NULL, NULL}
+    GObject parent;
+    char* obj_path; /* dbus object path */
+    GDBusProxy *proxy; /* dbus proxy for org.freedesktop.UDisks2.Block */
+    GDBusProxy *fsproxy; /* dbus proxy for org.freedesktop.UDisks2.Filesystem */
+
+    gboolean is_sys_internal : 1;
+    gboolean is_hidden : 1;
+    gboolean auto_mount : 1;
+
+    char** mount_paths;
+
+    GVolume *volume;
+    GDrive *drive;
 };
 
+struct _GUDisksDeviceClass
+{
+    GObjectClass parent_class;
+    void (*changed)(GUDisksDevice* dev);
+    void (*mount_added)(GUDisksDevice* dev, GUDisksMount* mnt);
+    void (*mount_preunmount)(GUDisksDevice* dev, GUDisksMount* mnt);
+    void (*mount_removed)(GUDisksDevice* dev, GUDisksMount* mnt);
+};
+
+static guint sig_changed;
+static guint sig_mount_added;
+static guint sig_mount_preunmount;
+static guint sig_mount_removed;
+
 static void g_udisks_device_finalize            (GObject *object);
 
 G_DEFINE_TYPE(GUDisksDevice, g_udisks_device, G_TYPE_OBJECT)
@@ -72,83 +70,65 @@ static void g_udisks_device_class_init(GUDisksDeviceClass *klass)
 
     g_object_class = G_OBJECT_CLASS(klass);
     g_object_class->finalize = g_udisks_device_finalize;
+
+    sig_changed = g_signal_new("changed", G_TYPE_FROM_CLASS(klass),
+                               G_SIGNAL_RUN_FIRST,
+                               G_STRUCT_OFFSET (GUDisksDeviceClass, changed),
+                               NULL, NULL,
+                               g_cclosure_marshal_VOID__VOID,
+                               G_TYPE_NONE, 0);
+
+    sig_mount_added = g_signal_new("mount-added", G_TYPE_FROM_CLASS(klass),
+                                   G_SIGNAL_RUN_FIRST,
+                                   G_STRUCT_OFFSET (GUDisksDeviceClass, mount_added),
+                                   NULL, NULL,
+                                   g_cclosure_marshal_VOID__OBJECT,
+                                   G_TYPE_NONE, 1, G_TYPE_OBJECT);
+
+    sig_mount_preunmount = g_signal_new("mount-pre-unmount", G_TYPE_FROM_CLASS(klass),
+                                        G_SIGNAL_RUN_FIRST,
+                                        G_STRUCT_OFFSET (GUDisksDeviceClass, mount_preunmount),
+                                        NULL, NULL,
+                                        g_cclosure_marshal_VOID__OBJECT,
+                                        G_TYPE_NONE, 1, G_TYPE_OBJECT);
+
+    sig_mount_removed = g_signal_new("mount-removed", G_TYPE_FROM_CLASS(klass),
+                                     G_SIGNAL_RUN_FIRST,
+                                     G_STRUCT_OFFSET (GUDisksDeviceClass, mount_removed),
+                                     NULL, NULL,
+                                     g_cclosure_marshal_VOID__OBJECT,
+                                     G_TYPE_NONE, 1, G_TYPE_OBJECT);
 }
 
 static void clear_props(GUDisksDevice* dev)
 {
-    g_free(dev->dev_file);
-    g_free(dev->dev_file_presentation);
-    g_free(dev->name);
-    g_free(dev->icon_name);
-    g_free(dev->usage);
-    g_free(dev->type);
-    g_free(dev->uuid);
-    g_free(dev->label);
-    g_free(dev->vender);
-    g_free(dev->model);
-    g_free(dev->conn_iface);
-    g_free(dev->media);
-    g_free(dev->partition_slave);
-
     g_strfreev(dev->mount_paths);
 }
 
-static void set_props(GUDisksDevice* dev, GHashTable* props)
+static void set_props(GUDisksDevice* dev)
 {
-    dev->dev_file = dbus_prop_dup_str(props, "DeviceFile");
-    dev->dev_file_presentation = dbus_prop_dup_str(props, "DeviceFilePresentation");
-    dev->is_sys_internal = dbus_prop_bool(props, "DeviceIsSystemInternal");
-    dev->is_removable = dbus_prop_bool(props, "DeviceIsRemovable");
-    dev->is_read_only = dbus_prop_bool(props, "DeviceIsReadOnly");
-    dev->is_drive = dbus_prop_bool(props, "DeviceIsDrive");
-    dev->is_optic_disc = dbus_prop_bool(props, "DeviceIsOpticalDisc");
-    dev->is_mounted = dbus_prop_bool(props, "DeviceIsMounted");
-    dev->is_media_available = dbus_prop_bool(props, "DeviceIsMediaAvailable");
-    dev->is_media_change_notification_polling = dbus_prop_bool(props, "DeviceIsMediaChangeDetectionPolling");
-    dev->is_luks = dbus_prop_bool(props, "DeviceIsLuks");
-    dev->is_luks_clear_text = dbus_prop_bool(props, "DeviceIsLuksCleartext");
-    dev->is_linux_md_component = dbus_prop_bool(props, "DeviceIsLinuxMdComponent");
-    dev->is_linux_md = dbus_prop_bool(props, "DeviceIsLinuxMd");
-    dev->is_linux_lvm2lv = dbus_prop_bool(props, "DeviceIsLinuxLvm2LV");
-    dev->is_linux_lvm2pv = dbus_prop_bool(props, "DeviceIsLinuxLvm2PV");
-    dev->is_linux_dmmp_component = dbus_prop_bool(props, "DeviceIsLinuxDmmpComponent");
-    dev->is_linux_dmmp = dbus_prop_bool(props, "DeviceIsLinuxDmmp");
-
-    dev->is_ejectable = dbus_prop_bool(props, "DriveIsMediaEjectable");
-    dev->is_disc_blank = dbus_prop_bool(props, "OpticalDiscIsBlank");
-
-    dev->is_hidden = dbus_prop_bool(props, "DevicePresentationHide");
-    dev->auto_mount = !dbus_prop_bool(props, "DevicePresentationNopolicy");
-
-    dev->mounted_by_uid = dbus_prop_uint(props, "DeviceMountedByUid");
-    dev->mount_paths = dbus_prop_dup_strv(props, "DeviceMountPaths");
-
-    dev->dev_size = dbus_prop_uint64(props, "DeviceSize");
-    dev->partition_size = dbus_prop_uint64(props, "PartitionSize");
-
-    dev->luks_unlocked_by_uid = dbus_prop_uint(props, "LuksCleartextUnlockedByUid");
-    dev->num_audio_tracks = dbus_prop_uint(props, "OpticalDiscNumAudioTracks");
-
-    dev->name = dbus_prop_dup_str(props, "DevicePresentationName");
-    dev->icon_name = dbus_prop_dup_str(props, "DevicePresentationIconName");
-
-    dev->usage = dbus_prop_dup_str(props, "IdUsage");
-    dev->type = dbus_prop_dup_str(props, "IdType");
-    dev->uuid = dbus_prop_dup_str(props, "IdUuid");
-    dev->label = dbus_prop_dup_str(props, "IdLabel");
-    dev->vender = dbus_prop_dup_str(props, "DriveVendor");
-    dev->model = dbus_prop_dup_str(props, "DriveModel");
-    dev->conn_iface = dbus_prop_dup_str(props, "DriveConnectionInterface");
-    dev->media = dbus_prop_dup_str(props, "DriveMedia");
-
-    dev->partition_slave = dbus_prop_dup_obj_path(props, "PartitionSlave");
-
-    /* how to support LUKS? */
-/*
-    'LuksHolder'                              read      'o'
-    'LuksCleartextSlave'                      read      'o'
-*/
+    dev->is_sys_internal = dbus_prop_bool(dev->proxy, "HintSystem");//
+    dev->is_hidden = dbus_prop_bool(dev->proxy, "HintIgnore");//
+    dev->auto_mount = dbus_prop_bool(dev->proxy, "HintAuto");//
+
+    if (dev->fsproxy)
+        dev->mount_paths = dbus_prop_dup_strv(dev->fsproxy, "MountPoints");
+    else
+        dev->mount_paths = NULL;
 
+    if (dev->volume)
+        g_udisks_volume_set_mounts(G_UDISKS_VOLUME(dev->volume), dev->mount_paths);
+}
+
+static void g_udisks_device_changed(GDBusProxy *proxy, GVariant *changed_properties,
+                                    GStrv invalidated_properties, gpointer user_data)
+{
+    g_return_if_fail(G_IS_UDISKS_DEVICE(user_data));
+    GUDisksDevice* dev = G_UDISKS_DEVICE(user_data);
+
+    clear_props(dev);
+    set_props(dev);
+    g_signal_emit(dev, sig_changed, 0);
 }
 
 static void g_udisks_device_finalize(GObject *object)
@@ -160,9 +140,25 @@ static void g_udisks_device_finalize(GObject *object)
 
     self = G_UDISKS_DEVICE(object);
 
+    if (self->proxy)
+    {
+        g_object_unref(self->proxy);
+        g_signal_handlers_disconnect_by_func(self->proxy, G_CALLBACK(g_udisks_device_changed), self);
+    }
+    if (self->fsproxy)
+    {
+        g_object_unref(self->fsproxy);
+        g_signal_handlers_disconnect_by_func(self->fsproxy, G_CALLBACK(g_udisks_device_changed), self);
+    }
+
     g_free(self->obj_path);
     clear_props(self);
 
+    if (self->volume)
+        g_object_unref(self->volume);
+    if (self->drive)
+        g_object_unref(self->drive);
+
     G_OBJECT_CLASS(g_udisks_device_parent_class)->finalize(object);
 }
 
@@ -172,142 +168,150 @@ static void g_udisks_device_init(GUDisksDevice *self)
 }
 
 
-GUDisksDevice *g_udisks_device_new(const char* obj_path, GHashTable* props)
+GUDisksDevice *g_udisks_device_new(const char* obj_path, GDBusConnection* con,
+                                   GCancellable* cancellable, GError** error)
 {
     GUDisksDevice* dev = (GUDisksDevice*)g_object_new(G_TYPE_UDISKS_DEVICE, NULL);
     dev->obj_path = g_strdup(obj_path);
-    set_props(dev, props);
+    dev->proxy = g_dbus_proxy_new_sync(con, G_DBUS_PROXY_FLAGS_NONE, NULL,
+                                       "org.freedesktop.UDisks2", obj_path,
+                                       "org.freedesktop.UDisks2.Block",
+                                       cancellable, error);
+    if (dev->proxy)
+    {
+        g_object_ref_sink(dev->proxy);
+        dev->fsproxy = g_dbus_proxy_new_sync(con, G_DBUS_PROXY_FLAGS_NONE, NULL,
+                                             "org.freedesktop.UDisks2", obj_path,
+                                             "org.freedesktop.UDisks2.Filesystem",
+                                             cancellable, error);
+        set_props(dev);
+        g_signal_connect(dev->proxy, "g-properties-changed",
+                         G_CALLBACK(g_udisks_device_changed), dev);
+        if (dev->fsproxy)
+        {
+            g_object_ref_sink(dev->fsproxy);
+            g_signal_connect(dev->fsproxy, "g-properties-changed",
+                             G_CALLBACK(g_udisks_device_changed), dev);
+        }
+    }
     return dev;
 }
 
-void g_udisks_device_update(GUDisksDevice* dev, GHashTable* props)
+void g_udisks_device_set_drive(GUDisksDevice* dev, GDrive* drv)
 {
-    clear_props(dev);
-    set_props(dev, props);
+    if (dev->drive)
+        g_object_unref(dev->drive);
+    dev->drive = drv ? g_object_ref_sink(drv) : NULL;
 }
 
-DBusGProxy* g_udisks_device_get_proxy(GUDisksDevice* dev, DBusGConnection* con)
+GDrive *g_udisks_device_get_drive(GUDisksDevice* dev)
 {
-    DBusGProxy* proxy = dbus_g_proxy_new_for_name(con,
-                            "org.freedesktop.UDisks",
-                            dev->obj_path,
-                            "org.freedesktop.UDisks.Device");
-    return proxy;
+    return dev->drive ? g_object_ref(dev->drive) : NULL;
 }
 
-const char* g_udisks_device_get_icon_name(GUDisksDevice* dev)
+void g_udisks_device_set_volume(GUDisksDevice* dev, GVolume* volume)
 {
-    const char* icon_name = NULL;
-    if(dev->icon_name && *dev->icon_name)
-        icon_name = dev->icon_name;
-    else if(dev->media && *dev->media) /* by media type */
-    {
-        if(dev->is_optic_disc)
-        {
-            if(dev->num_audio_tracks > 0)
-                icon_name = "media-optical-audio";
-            else
-            {
-                guint i;
-                icon_name = "media-optical";
-                for( i = 0; i < G_N_ELEMENTS(disc_data); ++i)
-                {
-                    if(strcmp(dev->media, disc_data[i].disc_type) == 0)
-                    {
-                        if(dev->is_disc_blank)
-                            icon_name = disc_data[i].icon_name;
-                        break;
-                    }
-                }
-            }
-        }
-        else
-        {
-            if(strcmp (dev->media, "flash_cf") == 0)
-                icon_name = "media-flash-cf";
-            else if(strcmp (dev->media, "flash_ms") == 0)
-                icon_name = "media-flash-ms";
-            else if(strcmp (dev->media, "flash_sm") == 0)
-                icon_name = "media-flash-sm";
-            else if(strcmp (dev->media, "flash_sd") == 0)
-                icon_name = "media-flash-sd";
-            else if(strcmp (dev->media, "flash_sdhc") == 0)
-                icon_name = "media-flash-sd";
-            else if(strcmp (dev->media, "flash_mmc") == 0)
-                icon_name = "media-flash-sd";
-            else if(strcmp (dev->media, "floppy") == 0)
-                icon_name = "media-floppy";
-            else if(strcmp (dev->media, "floppy_zip") == 0)
-                icon_name = "media-floppy-zip";
-            else if(strcmp (dev->media, "floppy_jaz") == 0)
-                icon_name = "media-floppy-jaz";
-            else if(g_str_has_prefix (dev->media, "flash"))
-                icon_name = "media-flash";
-        }
-    }
-    else if(dev->conn_iface && *dev->conn_iface) /* by connection interface */
-    {
-        if(g_str_has_prefix(dev->conn_iface, "ata"))
-            icon_name = dev->is_removable ? "drive-removable-media-ata" : "drive-harddisk-ata";
-        else if(g_str_has_prefix (dev->conn_iface, "scsi"))
-            icon_name = dev->is_removable ? "drive-removable-media-scsi" : "drive-harddisk-scsi";
-        else if(strcmp (dev->conn_iface, "usb") == 0)
-            icon_name = dev->is_removable ? "drive-removable-media-usb" : "drive-harddisk-usb";
-        else if (strcmp (dev->conn_iface, "firewire") == 0)
-            icon_name = dev->is_removable ? "drive-removable-media-ieee1394" : "drive-harddisk-ieee1394";
-    }
+    GUDisksVolume *vol = G_UDISKS_VOLUME(volume);
+    if (volume == dev->volume)
+        return;
+    if (dev->volume)
+        g_object_unref(dev->volume);
+    dev->volume = volume ? g_object_ref_sink(volume) : NULL;
+    if (vol)
+        g_udisks_volume_set_mounts(vol, dev->mount_paths);
+}
 
-    if(!icon_name)
-    {
-        if(dev->is_removable)
-            icon_name = "drive-removable-media";
-        else
-            icon_name = "drive-harddisk";
-    }
-    return icon_name;
+GVariant *g_udisks_device_get_fstype(GUDisksDevice* dev)
+{
+    GVariant *var = g_dbus_proxy_get_cached_property(dev->proxy, "IdType");
+    return var ? var : g_variant_ref_sink(g_variant_new_string("auto"));
 }
 
-const char* g_udisks_device_get_disc_name(GUDisksDevice* dev)
+char *g_udisks_device_get_uuid(GUDisksDevice* dev)
 {
-    const char* name = NULL;
-    if(!dev->is_optic_disc)
-        return NULL;
-    if(dev->media && *dev->media)
-    {
-        if(dev->num_audio_tracks > 0 && g_str_has_prefix(dev->media, "optical_cd"))
-            name = "Audio CD";
-        else
-        {
-            guint i;
-            for( i = 0; i < G_N_ELEMENTS(disc_data); ++i)
-            {
-                if(strcmp(dev->media, disc_data[i].disc_type) == 0)
-                {
-                    if(dev->is_disc_blank)
-                        name = disc_data[i].ui_name_blank;
-                    else
-                        name = disc_data[i].ui_name;
-                    break;
-                }
-            }
-        }
-    }
+    return dbus_prop_dup_str(dev->proxy, "IdUUID");
+}
+
+char *g_udisks_device_get_label(GUDisksDevice* dev)
+{
+    return dbus_prop_dup_str(dev->proxy, "IdLabel");
+}
+
+char *g_udisks_device_get_dev_file(GUDisksDevice* dev)
+{
+    return dbus_prop_dup_str(dev->proxy, "Device");
+}
+
+char *g_udisks_device_get_dev_basename(GUDisksDevice* dev)
+{
+    GVariant *var = g_dbus_proxy_get_cached_property(dev->proxy, "PreferredDevice");
+    char *basename;
 
-    if(!name)
+    if (!var)
+        var = g_dbus_proxy_get_cached_property(dev->proxy, "Device");
+    if (var)
     {
-        if(dev->is_disc_blank)
-            name = _("Blank Optical Disc");
-        else
-            name = _("Optical Disc");
+        basename = g_path_get_basename(g_variant_get_bytestring(var));
+        g_variant_unref(var);
     }
-    return name;
+    else
+        basename = g_path_get_basename(dev->obj_path);
+
+    return basename;
+}
+
+char *g_udisks_device_get_icon_name(GUDisksDevice* dev)
+{
+    // FIXME: check for HintSymbolicIconName if it's not blank
+    return dbus_prop_dup_str(dev->proxy, "HintIconName");
+}
+
+char *g_udisks_device_get_drive_obj_path(GUDisksDevice* dev)
+{
+    return dbus_prop_dup_str(dev->proxy, "Drive");
+}
+
+const char *g_udisks_device_get_obj_path(GUDisksDevice* dev)
+{
+    return dev->obj_path;
 }
 
-gboolean g_udisks_device_is_volume(GUDisksDevice* dev)
+gboolean g_udisks_device_is_sys_internal(GUDisksDevice* dev)
 {
-    /* also treat blank optical discs as volumes here to be compatible with gvfs.
-     * FIXME: this is useless unless we support burn:///
-     * So, should we support this? Personally I think it's a bad idea. */
-    return (g_strcmp0(dev->usage, "filesystem") == 0 || dev->is_disc_blank);
+    return dev->is_sys_internal;
 }
 
+gboolean g_udisks_device_is_hidden(GUDisksDevice* dev)
+{
+    return dev->is_hidden;
+}
+
+gboolean g_udisks_device_can_auto_mount(GUDisksDevice* dev)
+{
+    return dev->auto_mount;
+}
+
+GVolume *g_udisks_device_get_volume(GUDisksDevice* dev)
+{
+    return dev->volume ? g_object_ref(dev->volume) : NULL;
+}
+
+GDBusProxy *g_udisks_device_get_fs_proxy(GUDisksDevice* dev)
+{
+    return dev->fsproxy ? g_object_ref(dev->fsproxy) : NULL;
+}
+
+void g_udisks_device_mount_added(GUDisksDevice* dev, GUDisksMount* mnt)
+{
+    g_signal_emit(dev, sig_mount_added, 0, mnt);
+}
+
+void g_udisks_device_mount_preunmount(GUDisksDevice* dev, GUDisksMount* mnt)
+{
+    g_signal_emit(dev, sig_mount_preunmount, 0, mnt);
+}
+
+void g_udisks_device_mount_removed(GUDisksDevice* dev, GUDisksMount* mnt)
+{
+    g_signal_emit(dev, sig_mount_removed, 0, mnt);
+}
diff --git a/src/udisks/g-udisks-device.h b/src/udisks/g-udisks-device.h
index d5f736a1..6f9b08ff 100644
--- a/src/udisks/g-udisks-device.h
+++ b/src/udisks/g-udisks-device.h
@@ -1,6 +1,7 @@
 //      g-udisks-device.h
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -22,7 +23,7 @@
 #define __G_UDISKS_DEVICE_H__
 
 #include <glib-object.h>
-#include <dbus/dbus-glib.h>
+#include <gio/gio.h>
 
 G_BEGIN_DECLS
 
@@ -41,77 +42,31 @@ G_BEGIN_DECLS
 
 typedef struct _GUDisksDevice            GUDisksDevice;
 typedef struct _GUDisksDeviceClass        GUDisksDeviceClass;
-typedef struct _GUDisksDevicePrivate        GUDisksDevicePrivate;
-
-struct _GUDisksDevice
-{
-    GObject parent;
-    char* obj_path; /* dbus object path */
-
-    char* dev_file;
-    char* dev_file_presentation;
-    gboolean is_sys_internal : 1;
-    gboolean is_removable : 1;
-    gboolean is_read_only : 1;
-    gboolean is_drive : 1;
-    gboolean is_optic_disc : 1;
-    gboolean is_mounted : 1;
-    gboolean is_media_available : 1;
-    gboolean is_media_change_notification_polling : 1;
-    gboolean is_luks : 1;
-    gboolean is_luks_clear_text : 1;
-    gboolean is_linux_md_component : 1;
-    gboolean is_linux_md : 1;
-    gboolean is_linux_lvm2lv : 1;
-    gboolean is_linux_lvm2pv : 1;
-    gboolean is_linux_dmmp_component : 1;
-    gboolean is_linux_dmmp : 1;
-    gboolean is_ejectable : 1;
-    gboolean is_disc_blank : 1;
-    gboolean is_hidden : 1;
-    gboolean auto_mount : 1;
-
-    guint mounted_by_uid;
-    char** mount_paths;
-    guint64 dev_size;
-    guint64 partition_size;
-
-    guint num_audio_tracks;
-    guint luks_unlocked_by_uid;
-
-    char* name;
-    char* icon_name;
-
-    char* usage;
-    char* type;
-    char* uuid;
-    char* label;
-    char* vender;
-    char* model;
-    char* conn_iface;
-    char* media;
-    char* partition_slave;
-};
-
-struct _GUDisksDeviceClass
-{
-    GObjectClass parent_class;
-};
 
 
 GType g_udisks_device_get_type (void);
-GUDisksDevice* g_udisks_device_new (const char* obj_path, GHashTable* props);
-
-void g_udisks_device_update(GUDisksDevice* dev, GHashTable* props);
-
-DBusGProxy* g_udisks_device_get_proxy(GUDisksDevice* dev, DBusGConnection* con);
-
-const char* g_udisks_device_get_icon_name(GUDisksDevice* dev);
-
-/* this is only valid if the device contains a optic disc */
-const char* g_udisks_device_get_disc_name(GUDisksDevice* dev);
 
-gboolean g_udisks_device_is_volume(GUDisksDevice* dev);
+GUDisksDevice* g_udisks_device_new(const char* obj_path, GDBusConnection* con,
+                                   GCancellable* cancellable, GError** error);
+
+void g_udisks_device_set_drive(GUDisksDevice* dev, GDrive* drv);
+GDrive *g_udisks_device_get_drive(GUDisksDevice* dev);
+GVariant *g_udisks_device_get_fstype(GUDisksDevice* dev);
+char *g_udisks_device_get_uuid(GUDisksDevice* dev);
+char *g_udisks_device_get_label(GUDisksDevice* dev);
+char *g_udisks_device_get_dev_file(GUDisksDevice* dev);
+char *g_udisks_device_get_dev_basename(GUDisksDevice* dev);
+char *g_udisks_device_get_icon_name(GUDisksDevice* dev);
+char *g_udisks_device_get_drive_obj_path(GUDisksDevice* dev);
+const char *g_udisks_device_get_obj_path(GUDisksDevice* dev);
+//gboolean g_udisks_device_is_volume(GUDisksDevice* dev);
+gboolean g_udisks_device_is_drive(GUDisksDevice* dev);
+gboolean g_udisks_device_is_sys_internal(GUDisksDevice* dev);
+gboolean g_udisks_device_is_hidden(GUDisksDevice* dev);
+gboolean g_udisks_device_can_auto_mount(GUDisksDevice* dev);
+void g_udisks_device_set_volume(GUDisksDevice* dev, GVolume* vol);
+GVolume *g_udisks_device_get_volume(GUDisksDevice* dev);
+GDBusProxy *g_udisks_device_get_fs_proxy(GUDisksDevice* dev);
 
 G_END_DECLS
 
diff --git a/src/udisks/g-udisks-drive.c b/src/udisks/g-udisks-drive.c
index 7633ae27..916f4c40 100644
--- a/src/udisks/g-udisks-drive.c
+++ b/src/udisks/g-udisks-drive.c
@@ -1,6 +1,7 @@
 //      g-udisks-drive.c
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -22,12 +23,92 @@
 #endif
 
 #include "g-udisks-drive.h"
-#include "g-udisks-device.h"
-#include "g-udisks-volume.h"
+//#include "g-udisks-device.h"
+//#include "g-udisks-volume.h"
 #include <string.h>
-#include "udisks-device.h"
+#include <glib/gi18n-lib.h>
+//#include "udisks/udisks.h"
 #include "dbus-utils.h"
 
+/* This array is taken from gnome-disk-utility: gdu-volume.c
+ * Copyright (C) 2007 David Zeuthen, licensed under GNU LGPL
+ */
+static const struct
+{
+        const char *disc_type;
+        const char *icon_name;
+        const char *ui_name;
+        const char *ui_name_blank;
+} disc_data[] = {
+  /* Translator: The word "blank" is used as an adjective, e.g. we are decsribing discs that are already blank */
+  {"optical_cd",             "media-optical-cd-rom",        N_("CD-ROM Disc"),     N_("Blank CD-ROM Disc")},
+  {"optical_cd_r",           "media-optical-cd-r",          N_("CD-R Disc"),       N_("Blank CD-R Disc")},
+  {"optical_cd_rw",          "media-optical-cd-rw",         N_("CD-RW Disc"),      N_("Blank CD-RW Disc")},
+  {"optical_dvd",            "media-optical-dvd-rom",       N_("DVD-ROM Disc"),    N_("Blank DVD-ROM Disc")},
+  {"optical_dvd_r",          "media-optical-dvd-r",         N_("DVD-ROM Disc"),    N_("Blank DVD-ROM Disc")},
+  {"optical_dvd_rw",         "media-optical-dvd-rw",        N_("DVD-RW Disc"),     N_("Blank DVD-RW Disc")},
+  {"optical_dvd_ram",        "media-optical-dvd-ram",       N_("DVD-RAM Disc"),    N_("Blank DVD-RAM Disc")},
+  {"optical_dvd_plus_r",     "media-optical-dvd-r-plus",    N_("DVD+R Disc"),      N_("Blank DVD+R Disc")},
+  {"optical_dvd_plus_rw",    "media-optical-dvd-rw-plus",   N_("DVD+RW Disc"),     N_("Blank DVD+RW Disc")},
+  {"optical_dvd_plus_r_dl",  "media-optical-dvd-dl-r-plus", N_("DVD+R DL Disc"),   N_("Blank DVD+R DL Disc")},
+  {"optical_dvd_plus_rw_dl", "media-optical-dvd-dl-r-plus", N_("DVD+RW DL Disc"),  N_("Blank DVD+RW DL Disc")},
+  {"optical_bd",             "media-optical-bd-rom",        N_("Blu-Ray Disc"),    N_("Blank Blu-Ray Disc")},
+  {"optical_bd_r",           "media-optical-bd-r",          N_("Blu-Ray R Disc"),  N_("Blank Blu-Ray R Disc")},
+  {"optical_bd_re",          "media-optical-bd-re",         N_("Blu-Ray RW Disc"), N_("Blank Blu-Ray RW Disc")},
+  {"optical_hddvd",          "media-optical-hddvd-rom",     N_("HD DVD Disc"),     N_("Blank HD DVD Disc")},
+  {"optical_hddvd_r",        "media-optical-hddvd-r",       N_("HD DVD-R Disc"),   N_("Blank HD DVD-R Disc")},
+  {"optical_hddvd_rw",       "media-optical-hddvd-rw",      N_("HD DVD-RW Disc"),  N_("Blank HD DVD-RW Disc")},
+  {"optical_mo",             "media-optical-mo",            N_("MO Disc"),         N_("Blank MO Disc")},
+  {"optical_mrw",            "media-optical-mrw",           N_("MRW Disc"),        N_("Blank MRW Disc")},
+  {"optical_mrw_w",          "media-optical-mrw-w",         N_("MRW/W Disc"),      N_("Blank MRW/W Disc")},
+  {NULL, NULL, NULL, NULL}
+};
+
+struct _GUDisksDrive
+{
+    GObject parent;
+    char* obj_path; /* dbus object path */
+    GUDisksDevice* dev; /* weak ref */
+    GList* devs; /* weak_ref */
+    //char* icon_name;
+    GIcon* icon;
+    gboolean is_removable : 1;
+    gboolean is_optic_disc : 1;
+    gboolean is_media_available : 1;
+    gboolean is_media_change_notification_polling : 1;
+    gboolean is_ejectable : 1;
+    gboolean is_disc_blank : 1;
+    guint num_audio_tracks;
+    //char* vender;
+    //char* model;
+    char* conn_iface;
+    char* media;
+    GDBusProxy *proxy; /* dbus proxy */
+};
+
+static void g_udisks_clear_props(GUDisksDrive* drv)
+{
+    //g_free(drv->vender);
+    //g_free(drv->model);
+    g_free(drv->conn_iface);
+    g_free(drv->media);
+}
+
+static void g_udisks_fill_props(GUDisksDrive* drv)
+{
+    drv->conn_iface = dbus_prop_dup_str(drv->proxy, "ConnectionBus");
+    drv->is_removable = dbus_prop_bool(drv->proxy, "MediaRemovable");
+    drv->is_optic_disc = dbus_prop_bool(drv->proxy, "Optical");
+    drv->is_media_available = dbus_prop_bool(drv->proxy, "MediaAvailable");
+    drv->is_media_change_notification_polling = dbus_prop_bool(drv->proxy, "MediaChangeDetected");
+    drv->is_ejectable = dbus_prop_bool(drv->proxy, "Ejectable");
+    drv->is_disc_blank = dbus_prop_bool(drv->proxy, "OpticalBlank");
+    drv->num_audio_tracks = dbus_prop_uint(drv->proxy, "OpticalNumAudioTracks");
+    //drv->vender = dbus_prop_dup_str(drv->proxy, "Vendor");
+    //drv->model = dbus_prop_dup_str(drv->proxy, "Model");
+    drv->media = dbus_prop_dup_str(drv->proxy, "Media");
+}
+
 typedef struct
 {
     GUDisksDrive* drv;
@@ -36,8 +117,6 @@ typedef struct
     GMountOperation* op;
     GCancellable* cancellable;
     gpointer user_data;
-    DBusGProxy* proxy;
-    DBusGProxyCall* call;
     GList* mounts;
 }EjectData;
 
@@ -66,13 +145,13 @@ static void g_udisks_drive_class_init(GUDisksDriveClass *klass)
 static gboolean g_udisks_drive_can_eject (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    return drv->dev->is_ejectable;
+    return drv->is_ejectable;
 }
 
 static gboolean g_udisks_drive_can_poll_for_media (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    return drv->dev->is_media_change_notification_polling;
+    return drv->is_media_change_notification_polling;
 }
 
 static gboolean g_udisks_drive_can_start (GDrive* base)
@@ -100,46 +179,43 @@ static GList* g_udisks_drive_get_volumes (GDrive* base)
 {
     /* FIXME: is it a better idea to save all volumes in GUDisksDrive instead? */
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    GList* vols = g_volume_monitor_get_volumes(G_VOLUME_MONITOR(drv->mon));
     GList* l;
     GList* ret = NULL;
-    for(l = vols;l;l=l->next)
+    for (l = drv->devs; l; l = l->next)
     {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        if(vol->drive == drv)
+        GVolume* vol = g_udisks_device_get_volume(l->data);
+        if (vol)
             ret = g_list_prepend(ret, vol);
-        else
-            g_object_unref(vol);
     }
-    g_list_free(vols);
-    return ret;
+    return g_list_reverse(ret);
 }
 
-static void on_eject_cancelled(GCancellable* cancellable, gpointer user_data);
-
 static void finish_eject(GSimpleAsyncResult* res, EjectData* data)
 {
     g_simple_async_result_complete(res);
     g_object_unref(res);
 
     g_object_unref(data->drv);
-    if(data->cancellable)
-    {
-        g_signal_handlers_disconnect_by_func(data->cancellable, on_eject_cancelled, data);
+    if (data->op)
+        g_object_unref(data->op);
+    if (data->cancellable)
         g_object_unref(data->cancellable);
-    }
-    if(data->proxy)
-        g_object_unref(data->proxy);
+
     g_slice_free(EjectData, data);
 }
 
-static void on_ejected(DBusGProxy *proxy, GError *error, gpointer user_data)
+static void on_ejected(GObject *source_object, GAsyncResult *result, gpointer user_data)
 {
     EjectData* data = (EjectData*)user_data;
-    GSimpleAsyncResult* res;
-    if(error)
+    GDBusProxy *proxy = (GDBusProxy *)source_object;
+    GError *err = NULL;
+    GSimpleAsyncResult *res;
+    GVariant *val = g_dbus_proxy_call_finish(proxy, result, &err);
+
+    if(err)
     {
-        error = g_udisks_error_to_gio_error(error);
+        GError *error = g_udisks_error_to_gio_error(err);
+        g_error_free(err);
         res = g_simple_async_result_new_from_error(G_OBJECT(data->drv),
                                                    data->callback,
                                                    data->user_data,
@@ -152,19 +228,23 @@ static void on_ejected(DBusGProxy *proxy, GError *error, gpointer user_data)
                                         data->callback,
                                         data->user_data,
                                         NULL);
-        g_simple_async_result_set_op_res_gboolean(res, TRUE);
+        g_simple_async_result_set_op_res_gboolean(res, TRUE); // FIXME
+        if (val)
+            g_variant_unref(val);
     }
+    g_object_ref_sink(res);
     finish_eject(res, data);
 }
 
 static void do_eject(EjectData* data)
 {
-    data->proxy = g_udisks_device_get_proxy(data->drv->dev, data->drv->mon->con);
-    data->call = org_freedesktop_UDisks_Device_drive_eject_async(
-                        data->proxy,
-                        NULL,
-                        on_ejected,
-                        data);
+    GVariantBuilder b;
+    g_debug("%s: sending DBus request", __func__);
+    g_variant_builder_init(&b, G_VARIANT_TYPE("(a{sv})"));
+    g_variant_builder_open(&b, G_VARIANT_TYPE ("a{sv}"));
+    g_variant_builder_close(&b);
+    g_dbus_proxy_call(data->drv->proxy, "Eject", g_variant_builder_end(&b),
+                      G_DBUS_CALL_FLAGS_NONE, -1, data->cancellable, on_ejected, data);
 }
 
 static void unmount_before_eject(EjectData* data);
@@ -186,14 +266,13 @@ static void on_unmounted(GObject* mnt, GAsyncResult* res, gpointer input_data)
     else
     {
         GSimpleAsyncResult* res;
-        GError* error = g_udisks_error_to_gio_error(err);
-        g_error_free(err);
         res = g_simple_async_result_new_from_error(G_OBJECT(data->drv),
                                                    data->callback,
                                                    data->user_data,
                                                    err);
+        g_object_ref_sink(res);
         finish_eject(res, data);
-        g_error_free(error);
+        g_error_free(err);
     }
 #undef data
 }
@@ -210,14 +289,6 @@ static void unmount_before_eject(EjectData* data)
     g_object_unref(mnt);
 }
 
-static void on_eject_cancelled(GCancellable* cancellable, gpointer user_data)
-{
-    EjectData* data = (EjectData*)user_data;
-    /* cancel the dbus call if needed */
-    if(data->call)
-        dbus_g_proxy_cancel_call(data->proxy, data->call);
-}
-
 static void g_udisks_drive_eject_with_operation (GDrive* base, GMountUnmountFlags flags, GMountOperation* mount_operation, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
@@ -248,9 +319,6 @@ static void g_udisks_drive_eject_with_operation (GDrive* base, GMountUnmountFlag
     data->op = mount_operation ? g_object_ref(mount_operation) : NULL;
     data->user_data = user_data;
 
-    if(cancellable)
-        g_signal_connect(cancellable, "cancelled", G_CALLBACK(on_eject_cancelled), data);
-
     if(mounts) /* unmount all GMounts first, and do eject in ready callback */
     {
         /* NOTE: is this really needed?
@@ -294,28 +362,143 @@ static char** g_udisks_drive_enumerate_identifiers (GDrive* base)
     return kinds;
 }
 
+const char* g_udisks_drive_get_obj_path(GUDisksDrive* drv)
+{
+    return drv->obj_path;
+}
+
+static const char* g_udisks_drive_get_icon_name(GUDisksDrive* drv)
+{
+    const char* icon_name = NULL;
+
+    if(drv->media && *drv->media) /* by media type */
+    {
+        if(drv->is_optic_disc)
+        {
+            if(drv->num_audio_tracks > 0)
+                icon_name = "media-optical-audio";
+            else
+            {
+                guint i;
+                icon_name = "media-optical";
+                for( i = 0; i < G_N_ELEMENTS(disc_data); ++i)
+                {
+                    if(strcmp(drv->media, disc_data[i].disc_type) == 0)
+                    {
+                        if(drv->is_disc_blank)
+                            icon_name = disc_data[i].icon_name;
+                        break;
+                    }
+                }
+            }
+        }
+        else
+        {
+            if(strcmp (drv->media, "flash_cf") == 0)
+                icon_name = "media-flash-cf";
+            else if(strcmp (drv->media, "flash_ms") == 0)
+                icon_name = "media-flash-ms";
+            else if(strcmp (drv->media, "flash_sm") == 0)
+                icon_name = "media-flash-sm";
+            else if(g_str_has_prefix (drv->media, "flash_sd"))
+                icon_name = "media-flash-sd";
+            else if(strcmp (drv->media, "flash_mmc") == 0)
+                icon_name = "media-flash-sd";
+            else if(strcmp (drv->media, "floppy") == 0)
+                icon_name = "media-floppy";
+            else if(strcmp (drv->media, "floppy_zip") == 0)
+                icon_name = "media-floppy-zip";
+            else if(strcmp (drv->media, "floppy_jaz") == 0)
+                icon_name = "media-floppy-jaz";
+            else if(g_str_has_prefix (drv->media, "flash"))
+                icon_name = "media-flash";
+            else if(strcmp (drv->media, "thumb") == 0)
+                icon_name = "drive-harddisk-usb";
+        }
+    }
+    else if(drv->conn_iface && *drv->conn_iface) /* by connection interface */
+    {
+/*        if(g_str_has_prefix(drv->conn_iface, "ata"))
+            icon_name = drv->is_removable ? "drive-removable-media-ata" : "drive-harddisk-ata";
+        else if(g_str_has_prefix (drv->conn_iface, "scsi"))
+            icon_name = drv->is_removable ? "drive-removable-media-scsi" : "drive-harddisk-scsi";
+        else */
+        if(strcmp (drv->conn_iface, "usb") == 0)
+            icon_name = drv->is_removable ? "drive-removable-media-usb" : "drive-harddisk-usb";
+        else if (strcmp (drv->conn_iface, "ieee1394") == 0)
+            icon_name = drv->is_removable ? "drive-removable-media-ieee1394" : "drive-harddisk-ieee1394";
+    }
+
+    if(!icon_name)
+    {
+        if(drv->is_removable)
+            icon_name = "drive-removable-media";
+        else
+            icon_name = "drive-harddisk";
+    }
+    return icon_name;
+}
+
+const char* g_udisks_drive_get_disc_name(GUDisksDrive* drv)
+{
+    const char* name = NULL;
+    if(!drv || !drv->is_optic_disc)
+        return NULL;
+    if(drv->media && *drv->media)
+    {
+        if(drv->num_audio_tracks > 0 && g_str_has_prefix(drv->media, "optical_cd"))
+            name = _("Audio CD");
+        else
+        {
+            guint i;
+            for( i = 0; i < G_N_ELEMENTS(disc_data); ++i)
+            {
+                if(strcmp(drv->media, disc_data[i].disc_type) == 0)
+                {
+                    if(drv->is_disc_blank)
+                        name = gettext(disc_data[i].ui_name_blank);
+                    else
+                        name = gettext(disc_data[i].ui_name);
+                    break;
+                }
+            }
+        }
+    }
+
+    if(!name)
+    {
+        if(drv->is_disc_blank)
+            name = _("Blank Optical Disc");
+        else
+            name = _("Optical Disc");
+    }
+    return name;
+}
+
 static GIcon* g_udisks_drive_get_icon (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
     if(!drv->icon)
     {
-        const char* icon_name = g_udisks_device_get_icon_name(drv->dev);
+        char* drv_icon_name = drv->dev ? g_udisks_device_get_icon_name(drv->dev) : NULL;
+        const char* icon_name = drv_icon_name ? drv_icon_name : g_udisks_drive_get_icon_name(drv);
         drv->icon = g_themed_icon_new_with_default_fallbacks(icon_name);
+        g_free(drv_icon_name);
     }
-    return (GIcon*)g_object_ref(drv->icon);
+    return (GIcon*)g_object_ref_sink(drv->icon);
 }
 
 static char* g_udisks_drive_get_identifier (GDrive* base, const char* kind)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    if(kind)
+    if(kind && drv->dev)
     {
         if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_LABEL) == 0)
-            return g_strdup(drv->dev->label);
+            return g_udisks_device_get_label(drv->dev);
         else if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE) == 0)
-            return g_strdup(drv->dev->dev_file);
+            return g_udisks_device_get_dev_file(drv->dev);
         else if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_UUID) == 0)
-            return g_strdup(drv->dev->uuid);
+            return g_udisks_device_get_uuid(drv->dev);
     }
     return NULL;
 }
@@ -337,7 +520,7 @@ static GDriveStartStopType g_udisks_drive_get_start_stop_type (GDrive* base)
 static gboolean g_udisks_drive_has_media (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    return drv->dev->is_media_available;
+    return drv->is_media_available;
 }
 
 static gboolean g_udisks_drive_has_volumes (GDrive* base)
@@ -350,13 +533,13 @@ static gboolean g_udisks_drive_is_media_check_automatic (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
     /* FIXME: is this correct? */
-    return drv->dev->is_media_change_notification_polling;
+    return drv->is_media_change_notification_polling;
 }
 
 static gboolean g_udisks_drive_is_media_removable (GDrive* base)
 {
     GUDisksDrive* drv = G_UDISKS_DRIVE(base);
-    return drv->dev->is_removable;
+    return drv->is_removable;
 }
 
 static void g_udisks_drive_poll_for_media (GDrive* base, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data)
@@ -397,6 +580,28 @@ static gboolean g_udisks_drive_stop_finish (GDrive* base, GAsyncResult* res, GEr
     return FALSE;
 }
 
+static void g_udisks_drive_changed(GDBusProxy *proxy, GVariant *changed_properties,
+                                   GStrv invalidated_properties, gpointer user_data)
+{
+    g_return_if_fail(G_IS_UDISKS_DRIVE(user_data));
+    GUDisksDrive* drv = G_UDISKS_DRIVE(user_data);
+
+    g_udisks_clear_props(drv);
+    g_udisks_fill_props(drv);
+    g_signal_emit(drv, sig_changed, 0);
+}
+
+static void on_device_removed(gpointer data, GObject *dev)
+{
+    GUDisksDrive *drv = G_UDISKS_DRIVE(data);
+    GList *l = g_list_find(drv->devs, dev);
+
+    if ((GUDisksDevice *)dev == drv->dev)
+        drv->dev = NULL;
+    if (l)
+        drv->devs = g_list_delete_link(drv->devs, l);
+}
+
 
 void g_udisks_drive_drive_iface_init (GDriveIface * iface)
 {
@@ -442,8 +647,26 @@ static void g_udisks_drive_finalize(GObject *object)
     g_return_if_fail(G_IS_UDISKS_DRIVE(object));
 
     self = G_UDISKS_DRIVE(object);
+
+    if(self->proxy)
+    {
+        g_signal_handlers_disconnect_by_func(self->proxy, G_CALLBACK(g_udisks_drive_changed), self);
+        g_object_unref(self->proxy);
+    }
+
     if(self->dev)
-        g_object_unref(self->dev);
+        g_object_weak_unref(G_OBJECT(self->dev), on_device_removed, self);
+    while(self->devs)
+    {
+        g_object_weak_unref(G_OBJECT(self->devs->data), on_device_removed, self);
+        self->devs = g_list_delete_link(self->devs, self->devs);
+    }
+
+    g_udisks_clear_props(self);
+
+    g_free(self->obj_path);
+    if(self->icon)
+        g_object_unref(self->icon);
 
     G_OBJECT_CLASS(g_udisks_drive_parent_class)->finalize(object);
 }
@@ -454,18 +677,47 @@ static void g_udisks_drive_init(GUDisksDrive *self)
 
 }
 
-GUDisksDrive *g_udisks_drive_new(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+GUDisksDrive *g_udisks_drive_new(GDBusConnection* con, const char *obj_path,
+                                 GCancellable* cancellable, GError** error)
 {
     GUDisksDrive* drv = (GUDisksDrive*)g_object_new(G_TYPE_UDISKS_DRIVE, NULL);
-    drv->dev = g_object_ref(dev);
-    drv->mon = mon;
+    drv->obj_path = g_strdup(obj_path);
+    drv->proxy = g_dbus_proxy_new_sync(con, G_DBUS_PROXY_FLAGS_NONE, NULL,
+                                       "org.freedesktop.UDisks2", obj_path,
+                                       "org.freedesktop.UDisks2.Drive",
+                                       cancellable, error);
+    if (drv->proxy)
+    {
+        g_object_ref_sink(drv->proxy);
+        g_udisks_fill_props(drv);
+        g_signal_connect(drv->proxy, "g-properties-changed",
+                         G_CALLBACK(g_udisks_drive_changed), drv);
+    }
     return drv;
 }
 
+void g_udisks_drive_add_device(GUDisksDrive* drv, GUDisksDevice* dev, gboolean self)
+{
+    GList *l = g_list_find(drv->devs, dev);
+    if (dev == drv->dev) /* already in place */
+        return;
+    if (!l)
+        g_object_weak_ref(G_OBJECT(dev), on_device_removed, drv);
+    if (self)
+    {
+        if (l && drv->dev)
+            l->data = drv->dev;
+        else if (l)
+            drv->devs = g_list_delete_link(drv->devs, l);
+        drv->dev = dev;
+    }
+    else if (!l)
+        drv->devs = g_list_prepend(drv->devs, dev);
+}
 
-void g_udisks_drive_changed(GUDisksDrive* drv)
+gboolean g_udisks_drive_is_disc_blank(GUDisksDrive* drv)
 {
-    g_signal_emit(drv, sig_changed, 0);
+    return drv->is_disc_blank;
 }
 
 void g_udisks_drive_disconnected(GUDisksDrive* drv)
diff --git a/src/udisks/g-udisks-drive.h b/src/udisks/g-udisks-drive.h
index 5c0c3661..c60cc239 100644
--- a/src/udisks/g-udisks-drive.h
+++ b/src/udisks/g-udisks-drive.h
@@ -1,6 +1,7 @@
 //      g-udisks-drive.h
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -22,8 +23,7 @@
 #define __G_UDISKS_DRIVE_H__
 
 #include <gio/gio.h>
-#include "g-udisks-device.h"
-#include "g-udisks-volume-monitor.h"
+#include "g-udisks-volume.h"
 
 G_BEGIN_DECLS
 
@@ -43,15 +43,6 @@ G_BEGIN_DECLS
 typedef struct _GUDisksDrive            GUDisksDrive;
 typedef struct _GUDisksDriveClass        GUDisksDriveClass;
 
-struct _GUDisksDrive
-{
-    GObject parent;
-    GUDisksDevice* dev;
-    GIcon* icon;
-    char* name;
-    GUDisksVolumeMonitor* mon;
-};
-
 struct _GUDisksDriveClass
 {
     GObjectClass parent_class;
@@ -59,11 +50,20 @@ struct _GUDisksDriveClass
 
 
 GType        g_udisks_drive_get_type(void);
-GUDisksDrive* g_udisks_drive_new(GUDisksVolumeMonitor* mon, GUDisksDevice* dev);
+GUDisksDrive* g_udisks_drive_new(GDBusConnection* con, const char *obj_path,
+                                 GCancellable* cancellable, GError** error);
+
+void g_udisks_drive_add_device(GUDisksDrive* drv, GUDisksDevice* dev, gboolean self);
 
-void g_udisks_drive_changed(GUDisksDrive* drv);
 void g_udisks_drive_disconnected(GUDisksDrive* drv);
 
+const char* g_udisks_drive_get_obj_path(GUDisksDrive* drv);
+
+/* this is only valid if the device contains a optic disc */
+const char* g_udisks_drive_get_disc_name(GUDisksDrive* drv);
+
+gboolean g_udisks_drive_is_disc_blank(GUDisksDrive* drv);
+
 G_END_DECLS
 
 #endif /* __G_UDISKS_DRIVE_H__ */
diff --git a/src/udisks/g-udisks-mount.c b/src/udisks/g-udisks-mount.c
index ba5cf79a..70d12db4 100644
--- a/src/udisks/g-udisks-mount.c
+++ b/src/udisks/g-udisks-mount.c
@@ -1,6 +1,7 @@
 //      g-udisks-mount.c
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -21,19 +22,27 @@
 #include <config.h>
 #endif
 
-#include "g-udisks-volume.h"
-#include "udisks-device.h"
-#include "dbus-utils.h"
+#include "g-udisks-mount.h"
+
+#include <glib/gi18n-lib.h>
+
+struct _GUDisksMount
+{
+    GObject parent;
+    GUDisksVolume* vol; /* weak */
+    GFile* root;
+};
 
 typedef struct
 {
     GUDisksMount* mnt;
     GAsyncReadyCallback callback;
     gpointer user_data;
-    DBusGProxy* proxy;
-    DBusGProxyCall* call;
 }AsyncData;
 
+static guint sig_pre_unmount;
+static guint sig_unmounted;
+
 static void g_udisks_mount_mount_iface_init(GMountIface *iface);
 static void g_udisks_mount_finalize            (GObject *object);
 
@@ -62,6 +71,8 @@ static void g_udisks_mount_finalize(GObject *object)
     self = G_UDISKS_MOUNT(object);
     if(self->root)
         g_object_unref(self->root);
+    if(self->vol)
+        g_object_remove_weak_pointer(G_OBJECT(self->vol), (gpointer *)&self->vol);
 
     G_OBJECT_CLASS(g_udisks_mount_parent_class)->finalize(object);
 }
@@ -72,24 +83,28 @@ static void g_udisks_mount_init(GUDisksMount *self)
 }
 
 
-GUDisksMount *g_udisks_mount_new(GUDisksVolume* vol)
+GUDisksMount *g_udisks_mount_new(GUDisksVolume* vol, GFile* root)
 {
+    g_return_val_if_fail(vol, NULL);
+    g_return_val_if_fail(root, NULL);
     GUDisksMount* mnt = g_object_new(G_TYPE_UDISKS_MOUNT, NULL);
     /* we don't do g_object_ref here to prevent circular reference. */
     mnt->vol = vol;
+    g_object_add_weak_pointer(G_OBJECT(vol), (gpointer *)&mnt->vol);
+    mnt->root = g_object_ref_sink(root);
     return mnt;
 }
 
 static gboolean g_udisks_mount_can_eject (GMount* base)
 {
     GUDisksMount* mnt = G_UDISKS_MOUNT(base);
-    return mnt->vol ? mnt->vol->dev->is_ejectable : FALSE;
+    return mnt->vol ? g_volume_can_eject(G_VOLUME(mnt->vol)) : FALSE;
 }
 
 static gboolean g_udisks_mount_can_unmount (GMount* base)
 {
     GUDisksMount* mnt = G_UDISKS_MOUNT(base);
-    return mnt->vol ? mnt->vol->dev->is_mounted : FALSE;
+    return mnt->root != NULL;
 }
 
 typedef struct
@@ -163,11 +178,6 @@ static char* g_udisks_mount_get_name (GMount* base)
 static GFile* g_udisks_mount_get_root (GMount* base)
 {
     GUDisksMount* mnt = G_UDISKS_MOUNT(base);
-    if(!mnt->root && mnt->vol->dev->is_mounted && mnt->vol->dev->mount_paths)
-    {
-        /* TODO */
-        mnt->root = g_file_new_for_path(mnt->vol->dev->mount_paths[0]);
-    }
     return mnt->root ? (GFile*)g_object_ref(mnt->root) : NULL;
 }
 
@@ -217,6 +227,7 @@ static gboolean guess_content_job(GIOSchedulerJob *job, GCancellable* cancellabl
                                     data->callback,
                                     data->user_data,
                                     NULL);
+    g_object_ref_sink(res);
     g_simple_async_result_set_op_res_gpointer(res, content_types, (GDestroyNotify)g_strfreev);
     g_simple_async_result_complete_in_idle(res);
     g_object_unref(res);
@@ -265,13 +276,15 @@ static gchar** g_udisks_mount_guess_content_type_sync (GMount* base, gboolean fo
     /* TODO */
 //}
 
-static void unmount_callback(DBusGProxy *proxy, GError *error, gpointer user_data)
+static void unmount_callback(GObject *source, GAsyncResult *result, gpointer user_data)
 {
+    GDBusProxy *proxy = G_DBUS_PROXY(source);
     AsyncData* data = (AsyncData*)user_data;
     GSimpleAsyncResult* res;
+    GError *error = NULL;
+    GVariant *val = g_dbus_proxy_call_finish(proxy, result, &error);
     if(error)
     {
-        error = g_udisks_error_to_gio_error(error);
         res = g_simple_async_result_new_from_error(G_OBJECT(data->mnt),
                                                    data->callback,
                                                    data->user_data,
@@ -285,42 +298,58 @@ static void unmount_callback(DBusGProxy *proxy, GError *error, gpointer user_dat
                                         data->user_data,
                                         NULL);
         g_simple_async_result_set_op_res_gboolean(res, TRUE);
+        if (val) g_variant_unref(val);
     }
+    g_object_ref_sink(res);
     g_simple_async_result_complete(res);
     g_object_unref(res);
 
     g_object_unref(data->mnt);
-    g_object_unref(data->proxy);
     g_slice_free(AsyncData, data);
 }
 
-static void on_unmount_cancelled(GCancellable* cancellable, gpointer user_data)
-{
-    AsyncData* data = (AsyncData*)user_data;
-    dbus_g_proxy_cancel_call(data->proxy, data->call);
-}
-
 static void g_udisks_mount_unmount_with_operation (GMount* base, GMountUnmountFlags flags, GMountOperation* mount_operation, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data)
 {
     GUDisksMount* mnt = G_UDISKS_MOUNT(base);
     if(mnt->vol)
     {
-        GUDisksDevice* dev = mnt->vol->dev;
-        GUDisksVolumeMonitor* mon = mnt->vol->mon;
-        AsyncData* data = g_slice_new(AsyncData);
-        DBusGProxy* proxy = g_udisks_device_get_proxy(dev, mon->con);
-        data->mnt = g_object_ref(mnt);
-        data->callback = callback;
-        data->user_data = user_data;
-        data->proxy = proxy;
-
-        g_signal_emit_by_name(mon, "mount-pre-unmount", mnt);
-        g_signal_emit_by_name(mnt, "pre-unmount");
-
-        data->call = org_freedesktop_UDisks_Device_filesystem_unmount_async(
-                        proxy, NULL, unmount_callback, data);
-        if(cancellable)
-            g_signal_connect(cancellable, "cancelled", G_CALLBACK(on_unmount_cancelled), data);
+        GUDisksDevice* dev = g_udisks_volume_get_device(mnt->vol);
+        GDBusProxy* proxy = dev ? g_udisks_device_get_fs_proxy(dev) : NULL;
+        if(proxy)
+        {
+            AsyncData* data = g_slice_new(AsyncData);
+            GVariantBuilder b;
+            data->mnt = g_object_ref(mnt);
+            data->callback = callback;
+            data->user_data = user_data;
+
+            g_debug("send DBus request to unmount %s", g_udisks_device_get_obj_path(dev));
+            if (dev)
+                g_udisks_device_mount_preunmount(dev, mnt);
+            g_signal_emit(mnt, sig_pre_unmount, 0);
+
+            g_variant_builder_init(&b, G_VARIANT_TYPE("(a{sv})"));
+            g_variant_builder_open(&b, G_VARIANT_TYPE ("a{sv}"));
+            g_variant_builder_close(&b);
+            g_dbus_proxy_call(proxy, "Unmount", g_variant_builder_end(&b),
+                              G_DBUS_CALL_FLAGS_NONE, -1, cancellable,
+                              unmount_callback, data);
+            g_object_unref(proxy);
+        }
+        else
+        {
+            GSimpleAsyncResult* res;
+            char *dev_file = dev ? g_udisks_device_get_dev_file(dev) : NULL;
+
+            res = g_simple_async_result_new_error(G_OBJECT(mnt), callback, user_data,
+                                                  G_IO_ERROR, G_IO_ERROR_FAILED,
+                                                  _("No filesystem proxy for '%s'"),
+                                                  dev_file);
+            g_object_ref_sink(res);
+            g_simple_async_result_complete(res);
+            g_object_unref(res);
+            g_free(dev_file);
+        }
     }
 }
 
@@ -362,4 +391,12 @@ void g_udisks_mount_mount_iface_init(GMountIface *iface)
     iface->guess_content_type = g_udisks_mount_guess_content_type;
     iface->guess_content_type_finish = g_udisks_mount_guess_content_type_finish;
     iface->guess_content_type_sync = g_udisks_mount_guess_content_type_sync;
+
+    sig_pre_unmount = g_signal_lookup("pre-unmount", G_TYPE_MOUNT);
+    sig_unmounted = g_signal_lookup("unmounted", G_TYPE_MOUNT);
+}
+
+void g_udisks_mount_unmounted(GUDisksMount* mnt)
+{
+    g_signal_emit(mnt, sig_unmounted, 0);
 }
diff --git a/src/udisks/g-udisks-mount.h b/src/udisks/g-udisks-mount.h
index 09ea443b..7bbcccaf 100644
--- a/src/udisks/g-udisks-mount.h
+++ b/src/udisks/g-udisks-mount.h
@@ -1,6 +1,7 @@
 //      g-udisks-mount.h
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -22,6 +23,7 @@
 #define __G_UDISKS_MOUNT_H__
 
 #include <gio/gio.h>
+#include "g-udisks-volume.h"
 
 G_BEGIN_DECLS
 
@@ -40,14 +42,6 @@ G_BEGIN_DECLS
 
 typedef struct _GUDisksMount            GUDisksMount;
 typedef struct _GUDisksMountClass        GUDisksMountClass;
-typedef struct _GUDisksMountPrivate        GUDisksMountPrivate;
-
-struct _GUDisksMount
-{
-    GObject parent;
-    struct _GUDisksVolume* vol;
-    GFile* root;
-};
 
 struct _GUDisksMountClass
 {
@@ -56,8 +50,14 @@ struct _GUDisksMountClass
 
 
 GType        g_udisks_mount_get_type(void);
-GUDisksMount* g_udisks_mount_new(struct _GUDisksVolume* vol);
+GUDisksMount* g_udisks_mount_new(GUDisksVolume* vol, GFile *path);
+
+void g_udisks_mount_unmounted(GUDisksMount* mnt);
 
+/* In g-udisks-device.c */
+void g_udisks_device_mount_added(GUDisksDevice* dev, GUDisksMount* mnt);
+void g_udisks_device_mount_preunmount(GUDisksDevice* dev, GUDisksMount* mnt);
+void g_udisks_device_mount_removed(GUDisksDevice* dev, GUDisksMount* mnt);
 
 G_END_DECLS
 
diff --git a/src/udisks/g-udisks-volume-monitor.c b/src/udisks/g-udisks-volume-monitor.c
index 0c2975ef..795924f7 100644
--- a/src/udisks/g-udisks-volume-monitor.c
+++ b/src/udisks/g-udisks-volume-monitor.c
@@ -2,6 +2,7 @@
  *      g-udisks-volume-monitor.c
  *
  *      Copyright 2010 PCMan <pcman.tw@gmail.com>
+ *      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
  *
  *      This program is free software; you can redistribute it and/or modify
  *      it under the terms of the GNU General Public License as published by
@@ -23,41 +24,54 @@
 #include <config.h>
 #endif
 
-#include "dbus-utils.h"
-#include "udisks.h"
-
 #include "g-udisks-volume-monitor.h"
-#include "g-udisks-device.h"
 #include "g-udisks-drive.h"
-#include "g-udisks-volume.h"
+#include "g-udisks-mount.h"
+
+#include <string.h>
 
 /* FIXME: later we need to remove this when gio-udisks becomes an
  * independent gio module. */
 #include "fm-config.h"
 
+/*
+ * Relations:
+ * Monitor => Device => Volume => Mount[]
+ *                             <= (weak)Mount
+ *                   => Drive
+ *                   <= (weak)Drive
+ *                   <= (weak)Volume
+ *         => Drive
+ */
+
+struct _GUDisksVolumeMonitor
+{
+    GNativeVolumeMonitor parent;
+    GDBusConnection* con;
+    GDBusProxy* udisks_proxy;
+    GCancellable *cancellable;
+
+    GList* devices;
+    GList* drives;
+};
+
 static guint sig_drive_changed;
 static guint sig_drive_connected;
 static guint sig_drive_disconnected;
 static guint sig_drive_eject_button;
+static guint sig_drive_stop_button;
 static guint sig_mount_added;
 static guint sig_mount_changed;
-static guint sig_mount_premount;
+static guint sig_mount_preunmount;
 static guint sig_mount_removed;
 static guint sig_volume_added;
 static guint sig_volume_changed;
 static guint sig_volume_removed;
 
-static void g_udisks_device_added(GUDisksDevice* dev, GUDisksVolumeMonitor* mon);
-static void g_udisks_device_changed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon);
-static void g_udisks_device_removed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon);
-
-typedef void (*GUDisksDeviceEventHandler)(GUDisksDevice*, GUDisksVolumeMonitor*);
-
-typedef struct
-{
-    GUDisksDevice* dev;
-    GUDisksDeviceEventHandler func;
-}QueuedEvent;
+static GUDisksDrive *add_drive(GUDisksVolumeMonitor* mon, const char *obj_path,
+                               gboolean emit_signal);
+static void remove_device(GUDisksVolumeMonitor* mon, const char* obj_path);
+static void remove_drive(GUDisksVolumeMonitor* mon, const char* obj_path);
 
 static void g_udisks_volume_monitor_finalize            (GObject *object);
 static GMount* get_mount_for_mount_path(const char *mount_path, GCancellable *cancellable);
@@ -70,14 +84,17 @@ static GVolume *get_volume_for_uuid(GVolumeMonitor *mon, const char *uuid);
 static GMount *get_mount_for_uuid(GVolumeMonitor *mon, const char *uuid);
 static void drive_eject_button(GVolumeMonitor *mon, GDrive *drive);
 
-static void add_device(GUDisksVolumeMonitor* mon, DBusGProxy* proxy, const char* obj_path, gboolean emit_signal);
-static void on_device_added(DBusGProxy* proxy, const char* obj_path, gpointer user_data);
-static void on_device_removed(DBusGProxy* proxy, const char* obj_path, gpointer user_data);
-static void on_device_changed(DBusGProxy* proxy, const char* obj_path, gpointer user_data);
+static GUDisksDevice* add_device(GUDisksVolumeMonitor* mon, const char* obj_path,
+                                 gboolean do_introspection);
+
+static void on_device_changed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon);
+static void on_mount_added(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon);
+static void on_mount_preunmount(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon);
+static void on_mount_removed(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon);
+static void on_drive_changed(GUDisksDrive* dev, GUDisksVolumeMonitor* mon);
 
 static GList* find_device_l(GUDisksVolumeMonitor* mon, const char* obj_path);
-static GList* find_drive_l(GUDisksVolumeMonitor* mon, GUDisksDevice* dev);
-static GList* find_volume_l(GUDisksVolumeMonitor* mon, GUDisksDevice* dev);
+static GList* find_drive_l(GUDisksVolumeMonitor* mon, const char* obj_path);
 
 static inline GUDisksDevice* find_device(GUDisksVolumeMonitor* mon, const char* obj_path)
 {
@@ -85,16 +102,107 @@ static inline GUDisksDevice* find_device(GUDisksVolumeMonitor* mon, const char*
     return l ? G_UDISKS_DEVICE(l->data) : NULL;
 }
 
-static inline GUDisksDrive* find_drive(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+static inline GUDisksDrive* find_drive(GUDisksVolumeMonitor* mon, const char* obj_path)
 {
-    GList* l = find_drive_l(mon, dev);
+    GList* l = find_drive_l(mon, obj_path);
     return l ? G_UDISKS_DRIVE(l->data) : NULL;
 }
 
-static inline GUDisksVolume* find_volume(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+/* callback when new device or drive added or removed */
+static void on_g_signal(GDBusProxy *proxy, char *sender_name, char *signal_name,
+                        GVariant *parameters, gpointer user_data)
 {
-    GList* l = find_volume_l(mon, dev);
-    return l ? G_UDISKS_VOLUME(l->data) : NULL;
+    GUDisksVolumeMonitor* mon = G_UDISKS_VOLUME_MONITOR(user_data);
+
+    if (!g_variant_is_container(parameters) || g_variant_n_children(parameters) < 2)
+    {
+        // error, should be either 'oas' or 'oa{sa{sv}}'
+        return;
+    }
+
+    GVariant *target = g_variant_get_child_value(parameters, 0);
+    GVariant *ifaces = g_variant_get_child_value(parameters, 1);
+
+    if (!g_variant_is_container(ifaces))
+    {
+        // should never happen
+    }
+    else if (strcmp(signal_name, "InterfacesAdded") == 0)
+    {
+        GVariant *test = g_variant_lookup_value(ifaces,
+                                                "org.freedesktop.UDisks2.Drive", NULL);
+        if (test)
+        {
+            /* appears to be a drive itself */
+            add_drive(mon, g_variant_get_string(target, NULL), TRUE);
+            g_variant_unref(test);
+        }
+        else if ((test = g_variant_lookup_value(ifaces,
+                                                "org.freedesktop.UDisks2.Block", NULL)))
+        {
+            GUDisksDevice* dev = add_device(mon, g_variant_get_string(target, NULL),
+                                            FALSE);
+            g_variant_unref(test);
+            if (dev)
+            {
+                char *drv_obj_path = g_udisks_device_get_drive_obj_path(dev);
+                GUDisksDrive *drv = find_drive(mon, drv_obj_path);
+                g_debug("added new device '%s' for drive '%s'", g_udisks_device_get_obj_path(dev), drv_obj_path);
+                g_free(drv_obj_path);
+
+                if (drv)
+                {
+                    g_udisks_device_set_drive(dev, G_DRIVE(drv));
+                    test = g_variant_lookup_value(ifaces,
+                                                  "org.freedesktop.UDisks2.PartitionTable", NULL);
+                    g_udisks_drive_add_device(drv, dev, test != NULL);
+                    if (test)
+                    {
+                        /* appears to be a drive device */
+                        g_variant_unref(test);
+                        /* FIXME: this is useless unless we support burn:/// */
+                        if (g_udisks_drive_is_disc_blank(drv))
+                        {
+                            GUDisksVolume *vol = g_udisks_volume_new(dev, NULL);
+                            g_debug("adding new volume for %s", g_udisks_device_get_obj_path(dev));
+                            g_signal_emit(mon, sig_volume_added, 0, vol);
+                        }
+                    }
+                }
+                test = g_variant_lookup_value(ifaces,
+                                              "org.freedesktop.UDisks2.Filesystem", NULL);
+                if (test)
+                {
+                    /* appears to be mountable */
+                    GFile *activation_root = NULL; //FIXME: use HintName or IdUUID into some point
+                    GUDisksVolume *vol = g_udisks_volume_new(dev, activation_root);
+                    g_debug("adding new volume for %s", g_udisks_device_get_obj_path(dev));
+                    g_signal_emit(mon, sig_volume_added, 0, vol);
+                    g_variant_unref(test);
+                }
+            }
+        }
+    }
+    else if (strcmp(signal_name, "InterfacesRemoved") == 0)
+    {
+        GVariantIter iter;
+        char *val;
+        g_variant_iter_init(&iter, ifaces);
+        while (g_variant_iter_next(&iter, "s", &val))
+        {
+            if (strcmp(val, "org.freedesktop.UDisks2.Drive") == 0)
+                remove_drive(mon, g_variant_get_string(target, NULL));
+            else if (strcmp(val, "org.freedesktop.UDisks2.Block") == 0)
+                remove_device(mon, g_variant_get_string(target, NULL));
+            g_free(val);
+        }
+    }
+    else
+    {
+        // shoudl never happen!
+    }
+    g_variant_unref(target);
+    g_variant_unref(ifaces);
 }
 
 
@@ -122,16 +230,16 @@ static void g_udisks_volume_monitor_class_init(GUDisksVolumeMonitorClass *klass)
     sig_drive_connected = g_signal_lookup("drive-connected", G_TYPE_VOLUME_MONITOR);
     sig_drive_disconnected = g_signal_lookup("drive-disconnected", G_TYPE_VOLUME_MONITOR);
     sig_drive_eject_button = g_signal_lookup("drive-eject-button", G_TYPE_VOLUME_MONITOR);
+    sig_drive_stop_button = g_signal_lookup("drive-stop-button", G_TYPE_VOLUME_MONITOR);
     sig_mount_added = g_signal_lookup("mount-added", G_TYPE_VOLUME_MONITOR);
     sig_mount_changed = g_signal_lookup("mount-changed", G_TYPE_VOLUME_MONITOR);
-    sig_mount_premount = g_signal_lookup("mount-premount", G_TYPE_VOLUME_MONITOR);
+    sig_mount_preunmount = g_signal_lookup("mount-pre-unmount", G_TYPE_VOLUME_MONITOR);
     sig_mount_removed = g_signal_lookup("mount-removed", G_TYPE_VOLUME_MONITOR);
     sig_volume_added = g_signal_lookup("volume-added", G_TYPE_VOLUME_MONITOR);
     sig_volume_changed = g_signal_lookup("volume-changed", G_TYPE_VOLUME_MONITOR);
     sig_volume_removed = g_signal_lookup("volume-removed", G_TYPE_VOLUME_MONITOR);
 }
 
-
 static void g_udisks_volume_monitor_finalize(GObject *object)
 {
     GUDisksVolumeMonitor *self;
@@ -141,101 +249,172 @@ static void g_udisks_volume_monitor_finalize(GObject *object)
 
     self = G_UDISKS_VOLUME_MONITOR(object);
 
-    if(self->idle_handler)
+    if(self->cancellable)
     {
-        GList* l;
-        g_source_remove(self->idle_handler);
-        for(l = self->queued_events; l; l=l->next)
-        {
-            QueuedEvent* q = (QueuedEvent*)l->data;
-            g_object_unref(q->dev);
-            g_slice_free(QueuedEvent, q);
-        }
-        g_list_free(self->queued_events);
+        g_cancellable_cancel(self->cancellable);
+        g_object_unref(self->cancellable);
     }
 
     if(self->udisks_proxy)
     {
-        dbus_g_proxy_disconnect_signal(self->udisks_proxy, "DeviceAdded", G_CALLBACK(on_device_added), self);
-        dbus_g_proxy_disconnect_signal(self->udisks_proxy, "DeviceRemoved", G_CALLBACK(on_device_removed), self);
-        dbus_g_proxy_disconnect_signal(self->udisks_proxy, "DeviceChanged", G_CALLBACK(on_device_changed), self);
+        g_signal_handlers_disconnect_by_func(self->udisks_proxy,
+                                             G_CALLBACK(on_g_signal), self);
         g_object_unref(self->udisks_proxy);
     }
 
-    if(self->devices)
-    {
-        g_list_foreach(self->devices, (GFunc)g_object_unref, NULL);
-        g_list_free(self->devices);
-    }
-
-    if(self->drives)
+    while(self->devices)
     {
-        g_list_foreach(self->drives, (GFunc)g_object_unref, NULL);
-        g_list_free(self->drives);
+        g_signal_handlers_disconnect_by_func(self->devices->data,
+                                             G_CALLBACK(on_device_changed), self);
+        g_signal_handlers_disconnect_by_func(self->devices->data,
+                                             G_CALLBACK(on_mount_added), self);
+        g_signal_handlers_disconnect_by_func(self->devices->data,
+                                             G_CALLBACK(on_mount_preunmount), self);
+        g_signal_handlers_disconnect_by_func(self->devices->data,
+                                             G_CALLBACK(on_mount_removed), self);
+        g_object_unref(self->devices->data);
+        self->devices = g_list_delete_link(self->devices, self->devices);
     }
 
-    if(self->volumes)
+    while(self->drives)
     {
-        g_list_foreach(self->volumes, (GFunc)g_object_unref, NULL);
-        g_list_free(self->volumes);
+        g_signal_handlers_disconnect_by_func(self->drives->data,
+                                             G_CALLBACK(on_drive_changed), self);
+        g_udisks_drive_disconnected(self->drives->data);
+        g_object_unref(self->drives->data);
+        self->drives = g_list_delete_link(self->drives, self->drives);
     }
 
     G_OBJECT_CLASS(g_udisks_volume_monitor_parent_class)->finalize(object);
 }
 
-static void update_volume_drive(GUDisksVolume* vol, GUDisksVolumeMonitor* mon)
+/* second phase of initialization: block devices scanned, add them and start monitoring */
+static void do_introspection(GUDisksVolumeMonitor *mon, const char *obj_path,
+                             void (*process)(GDBusNodeInfo *, const char *, GUDisksVolumeMonitor *, gpointer),
+                             gpointer pdata)
 {
-    /* set association between drive and volumes here */
-    GUDisksDevice* dev;
-    if(vol->dev->is_drive) /* it's a drive itself (cdrom is an example) */
-        dev = vol->dev;
-    else if(vol->dev->partition_slave)
-        dev = find_device(mon, vol->dev->partition_slave);
-    else
-        dev = NULL;
+    GVariant *res;
+    GError *error = NULL;
+
+    res = g_dbus_connection_call_sync(mon->con, "org.freedesktop.UDisks2",
+                                      obj_path,
+                                      "org.freedesktop.DBus.Introspectable",
+                                      "Introspect", NULL, G_VARIANT_TYPE("(s)"),
+                                      G_DBUS_CALL_FLAGS_NONE, -1,
+                                      mon->cancellable, &error);
 
-    /* no ref_count handling is needed. volume manager owns all the objects. */
-    if(dev)
+    /* parse result */
+    if (!error)
     {
-        GUDisksDrive* drv = find_drive(mon, dev);
-        vol->drive = drv;
+        GVariant *xml = g_variant_get_child_value(res, 0);
+        GDBusNodeInfo *info = g_dbus_node_info_new_for_xml(g_variant_get_string(xml, NULL),
+                                                           &error);
+
+        if (error)
+        {
+            g_warning("Udisks2 introspection bad result: %s", error->message);
+            g_error_free(error);
+        }
+        else
+        {
+            process(info, obj_path, mon, pdata);
+            g_dbus_node_info_unref(info);
+        }
+        g_variant_unref(xml);
+        g_variant_unref(res);
     }
     else
-        vol->drive = NULL;
+    {
+        g_warning("Udisks2 introspection failed: %s", error->message);
+        g_error_free(error);
+    }
 }
 
-static void g_udisks_volume_monitor_init(GUDisksVolumeMonitor *self)
+static void process_drives_introspect(GDBusNodeInfo *info, const char *obj_path,
+                                      GUDisksVolumeMonitor *mon, gpointer pdata)
 {
-    self->con = dbus_g_bus_get(DBUS_BUS_SYSTEM, NULL);
-    if(self->con)
+    GDBusNodeInfo **sub;
+    GString *str = g_string_new(obj_path);
+    gsize len;
+
+    g_string_append_c(str, '/');
+    len = str->len;
+    for (sub = info->nodes; sub && sub[0]; sub++)
     {
-        GPtrArray* ret;
-        /* FIXME: handle disconnecting from dbus */
-        self->udisks_proxy = dbus_g_proxy_new_for_name(self->con, "org.freedesktop.UDisks", "/org/freedesktop/UDisks", "org.freedesktop.UDisks");
+        g_string_append(str, sub[0]->path);
+        add_drive(mon, str->str, FALSE);
+        g_string_truncate(str, len);
+    }
+    g_string_free(str, TRUE);
+}
 
-        if(org_freedesktop_UDisks_enumerate_devices(self->udisks_proxy, &ret, NULL))
-        {
-            guint i;
-            char** paths = (char**)ret->pdata;
-            for(i=0; i<ret->len;++i)
-                add_device(self, self->udisks_proxy, paths[i], FALSE);
-            g_ptr_array_free(ret, TRUE);
-        }
+static void process_devices_introspect(GDBusNodeInfo *info, const char *obj_path,
+                                       GUDisksVolumeMonitor *mon, gpointer pdata)
+{
+    GDBusNodeInfo **sub;
+    GString *str = g_string_new(obj_path);
+    gsize len;
 
-        dbus_g_proxy_add_signal(self->udisks_proxy, "DeviceAdded", DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
-        dbus_g_proxy_add_signal(self->udisks_proxy, "DeviceRemoved", DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
-        dbus_g_proxy_add_signal(self->udisks_proxy, "DeviceChanged", DBUS_TYPE_G_OBJECT_PATH, G_TYPE_INVALID);
+    g_string_append_c(str, '/');
+    len = str->len;
+    for (sub = info->nodes; sub && sub[0]; sub++)
+    {
+        g_string_append(str, sub[0]->path);
+        add_device(mon, str->str, TRUE);
+        g_string_truncate(str, len);
+    }
+    g_string_free(str, TRUE);
+}
 
-        dbus_g_proxy_connect_signal(self->udisks_proxy, "DeviceAdded", G_CALLBACK(on_device_added), self, NULL);
-        dbus_g_proxy_connect_signal(self->udisks_proxy, "DeviceRemoved", G_CALLBACK(on_device_removed), self, NULL);
-        dbus_g_proxy_connect_signal(self->udisks_proxy, "DeviceChanged", G_CALLBACK(on_device_changed), self, NULL);
+/* first phase of initialization: DBus connected */
+static void on_dbus_connected(GObject *source_object, GAsyncResult *result,
+                              gpointer user_data)
+{
+    GUDisksVolumeMonitor *mon = G_UDISKS_VOLUME_MONITOR(user_data);
+    GError *error = NULL;
 
-        /* find drives for volumes */
-        if(self->volumes && self->drives)
-            g_list_foreach(self->volumes, (GFunc)update_volume_drive, self);
+    mon->con = g_bus_get_finish(result, &error);
+    if (!error)
+    {
+        /* collect drives */
+        const char *path = "/org/freedesktop/UDisks2/drives";
+        do_introspection(mon, path, &process_drives_introspect, NULL);
+
+        /* collect devices */
+        path = "/org/freedesktop/UDisks2/block_devices";
+        do_introspection(mon, path, &process_devices_introspect, NULL);
+
+        /* add a monitor */
+        mon->udisks_proxy = g_dbus_proxy_new_sync(mon->con,
+                                                  G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
+                                                  NULL, "org.freedesktop.UDisks2",
+                                                  "/org/freedesktop/UDisks2",
+                                                  "org.freedesktop.DBus.ObjectManager",
+                                                  mon->cancellable, &error);
+        if (!error)
+        {
+            g_object_ref_sink(mon->udisks_proxy);
+            g_signal_connect(mon->udisks_proxy, "g-signal", G_CALLBACK(on_g_signal), mon);
+        }
+        else
+        {
+            g_warning("Udisks2 ObjectManager proxy failed: %s", error->message);
+            g_error_free(error);
+        }
+    }
+    else
+    {
+        g_warning("Cannot connect DBus: %s", error->message);
+        g_error_free(error);
     }
 }
 
+static void g_udisks_volume_monitor_init(GUDisksVolumeMonitor *self)
+{
+    self->cancellable = g_object_ref_sink(g_cancellable_new());
+    g_bus_get(G_BUS_TYPE_SYSTEM, self->cancellable, on_dbus_connected, self);
+}
+
 
 GNativeVolumeMonitor *g_udisks_volume_monitor_new(void)
 {
@@ -266,22 +445,29 @@ GList* get_connected_drives(GVolumeMonitor *mon)
 GList* get_volumes(GVolumeMonitor *mon)
 {
     GUDisksVolumeMonitor* umon = G_UDISKS_VOLUME_MONITOR(mon);
-    GList* vols = g_list_copy(umon->volumes);
-    g_list_foreach(vols, (GFunc)g_object_ref, NULL);
-    return vols;
+    GList* vols = NULL, *l;
+    for (l = umon->devices; l; l = l->next)
+    {
+        GVolume *vol = g_udisks_device_get_volume(l->data);
+        if (vol)
+            vols = g_list_prepend(vols, vol);
+    }
+    return g_list_reverse(vols);
 }
 
 GList* get_mounts(GVolumeMonitor *mon)
 {
-    GUDisksVolumeMonitor* umon = G_UDISKS_VOLUME_MONITOR(mon);
+    GList* vols = get_volumes(mon);
     GList* l;
     GList* mnts = NULL;
-    for(l = umon->volumes; l; l=l->next)
+
+    for (l = vols; l; l = l->next)
     {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        if(vol->mount)
-            mnts = g_list_prepend(mnts, g_object_ref(vol->mount));
+        mnts = g_list_concat(g_udisks_volume_get_mounts(l->data), mnts);
+        g_object_unref(l->data);
     }
+    g_list_free(vols);
+    g_list_foreach(mnts, (GFunc)g_object_ref, NULL);
     return mnts;
 }
 
@@ -289,26 +475,23 @@ GVolume *get_volume_for_uuid(GVolumeMonitor *mon, const char *uuid)
 {
     GUDisksVolumeMonitor* umon = G_UDISKS_VOLUME_MONITOR(mon);
     GList* l;
-    for(l = umon->volumes; l; l=l->next)
+    for(l = umon->devices; l; l=l->next)
     {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        if(g_strcmp0(vol->dev->uuid, uuid) == 0)
-            return (GVolume*)g_object_ref(vol);
+        char *dev_uuid = g_udisks_device_get_uuid(l->data);
+        int res = g_strcmp0(dev_uuid, uuid);
+        g_free(dev_uuid);
+        if (res == 0)
+            return g_udisks_device_get_volume(l->data);
     }
     return NULL;
 }
 
 GMount *get_mount_for_uuid(GVolumeMonitor *mon, const char *uuid)
 {
-    GUDisksVolumeMonitor* umon = G_UDISKS_VOLUME_MONITOR(mon);
-    GList* l;
-    for(l = umon->volumes; l; l=l->next)
-    {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        if(g_strcmp0(vol->dev->uuid, uuid) == 0)
-            return g_volume_get_mount(G_VOLUME(vol));
-    }
-    return NULL;
+    GVolume *vol = get_volume_for_uuid(mon, uuid);
+    GMount *mnt = g_volume_get_mount(vol);
+    g_object_unref(vol);
+    return mnt;
 }
 
 /* signal added in 2.17 */
@@ -324,273 +507,203 @@ GList* find_device_l(GUDisksVolumeMonitor* mon, const char* obj_path)
     GList* l;
     for(l = mon->devices; l; l=l->next)
     {
-        GUDisksDevice* dev = G_UDISKS_DEVICE(l->data);
-        if(g_strcmp0(dev->obj_path, obj_path) == 0)
+        if(g_strcmp0(g_udisks_device_get_obj_path(l->data), obj_path) == 0)
             return l;
     }
     return NULL;
 }
 
-GList* find_drive_l(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+GList* find_drive_l(GUDisksVolumeMonitor* mon, const char* obj_path)
 {
     GList* l;
     for(l = mon->drives; l; l=l->next)
     {
-        GUDisksDrive* drv = G_UDISKS_DRIVE(l->data);
-        if(G_UNLIKELY(drv->dev == dev))
-            return l;
-    }
-    return NULL;
-}
-
-GList* find_volume_l(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
-{
-    GList* l;
-    for(l = mon->volumes; l; l=l->next)
-    {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        if(G_UNLIKELY(vol->dev == dev))
+        if(g_strcmp0(g_udisks_drive_get_obj_path(l->data), obj_path) == 0)
             return l;
     }
     return NULL;
 }
 
-static void add_drive(GUDisksVolumeMonitor* mon, GUDisksDevice* dev, gboolean emit_signal)
+static GUDisksDrive *add_drive(GUDisksVolumeMonitor* mon, const char *obj_path,
+                               gboolean emit_signal)
 {
-    if(!find_drive(mon, dev))
+    GUDisksDrive *drv = find_drive(mon, obj_path);
+    if (!drv)
     {
-        GUDisksDrive* drv = g_udisks_drive_new(mon, dev);
-        mon->drives = g_list_prepend(mon->drives, drv);
+        drv = g_udisks_drive_new(mon->con, obj_path, mon->cancellable, NULL); // FIXME
+        g_signal_connect(drv, "changed", G_CALLBACK(on_drive_changed), mon);
+        mon->drives = g_list_prepend(mon->drives, g_object_ref_sink(drv));
         if(emit_signal)
             g_signal_emit(mon, sig_drive_connected, 0, drv);
     }
+    return drv;
 }
 
-static void add_volume(GUDisksVolumeMonitor* mon, GUDisksDevice* dev, gboolean emit_signal)
-{
-    if(!find_volume(mon, dev))
-    {
-        GUDisksVolume* vol = g_udisks_volume_new(mon, dev);
-        mon->volumes = g_list_prepend(mon->volumes, vol);
-        if(emit_signal)
-            g_signal_emit(mon, sig_volume_added, 0, vol);
-    }
-}
-
-static void remove_drive(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+static void remove_drive(GUDisksVolumeMonitor* mon, const char *obj_path)
 {
-    GList* l = find_drive_l(mon, dev);
+    GList* l = find_drive_l(mon, obj_path);
+    g_debug("remove_drive: %s", obj_path);
     if(l)
     {
         GUDisksDrive* drv = G_UDISKS_DRIVE(l->data);
         mon->drives = g_list_delete_link(mon->drives, l);
+        g_signal_handlers_disconnect_by_func(drv, G_CALLBACK(on_drive_changed), mon);
         g_signal_emit(mon, sig_drive_disconnected, 0, drv);
         g_udisks_drive_disconnected(drv);
-        drv->mon = NULL;
-        for(l = mon->volumes; l; l=l->next)
-        {
-            GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-            if(vol->drive == drv)
-            {
-                vol->drive = NULL;
-                /* FIXME: emit sigal for volume change */
-            }
-        }
         g_object_unref(drv);
     }
 }
 
-static void remove_volume(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+static void process_a_device_introspect(GDBusNodeInfo *info, const char *obj_path,
+                                        GUDisksVolumeMonitor *mon, gpointer dev)
 {
-    GList* l = find_volume_l(mon, dev);
-    if(l)
+    GDBusInterfaceInfo **interfaces = info->interfaces;
+    gboolean has_fs = FALSE, has_pt = FALSE;
+    char *drv_obj_path;
+    GUDisksDrive *drv;
+
+    if (!interfaces) // Failure!
+        return;
+
+    drv_obj_path = g_udisks_device_get_drive_obj_path(dev);
+    drv = find_drive(mon, drv_obj_path);
+    if (drv)
+        g_udisks_device_set_drive(dev, G_DRIVE(drv));
+    while (*interfaces)
     {
-        GUDisksVolume* vol = G_UDISKS_VOLUME(l->data);
-        mon->volumes = g_list_delete_link(mon->volumes, l);
-        g_signal_emit(mon, sig_volume_removed, 0, vol);
-        g_udisks_volume_removed(vol);
-        vol->mon = NULL;
-        vol->drive = NULL;
-        g_object_unref(vol);
+        if (g_strcmp0((*interfaces)->name, "org.freedesktop.UDisks2.Filesystem") == 0)
+            has_fs = TRUE;
+        else if (drv && g_strcmp0((*interfaces)->name, "org.freedesktop.UDisks2.PartitionTable") == 0)
+            has_pt = TRUE;
+        interfaces++;
+    }
+
+    if (has_fs)
+    {
+        g_debug("adding new volume for %s", obj_path);
+        g_udisks_volume_new(dev, NULL); //FIXME: set some activation_root?
+    }
+    if (drv)
+    {
+        g_debug("added device '%s' %s drive '%s'", obj_path, has_pt ? "as a" : "to", drv_obj_path);
+        g_udisks_drive_add_device(drv, dev, has_pt);
+        /* also treat blank optical discs as volumes here to be compatible with gvfs.
+         * FIXME: this is useless unless we support burn:///
+         * [PCMan] So, should we support this? Personally I think it's a bad idea. */
+        if (g_udisks_drive_is_disc_blank(drv))
+        {
+            g_debug("adding new volume for %s", obj_path);
+            g_udisks_volume_new(dev, NULL);
+        }
     }
+    g_free(drv_obj_path);
 }
 
-static void _g_udisks_device_added(GUDisksDevice* dev, GUDisksVolumeMonitor* mon, gboolean emit_signal)
+static void _g_udisks_device_added(GUDisksDevice* dev, GUDisksVolumeMonitor* mon,
+                                   const char *obj_path)
 {
     /* FIXME: how should we treat sys internal devices?
      * make this optional */
-    if(!dev->is_hidden && (!dev->is_sys_internal || fm_config->show_internal_volumes) )
+    g_debug("added new device '%s'", obj_path);
+    if(!g_udisks_device_is_hidden(dev) &&
+       (!g_udisks_device_is_sys_internal(dev) || fm_config->show_internal_volumes))
     {
-        if(dev->is_drive)
-            add_drive(mon, dev, emit_signal);
-
-        if(g_udisks_device_is_volume(dev))
-            add_volume(mon, dev, emit_signal);
+        do_introspection(mon, obj_path, &process_a_device_introspect, dev);
     }
 }
 
-static void g_udisks_device_added(GUDisksDevice* dev, GUDisksVolumeMonitor* mon)
+static void on_device_changed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon)
 {
-    g_debug("g_udisks_device_added");
-    _g_udisks_device_added(dev, mon, TRUE);
-}
-
-static void g_udisks_device_changed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon)
-{
-    GUDisksDrive* drv = find_drive(mon, dev);
-    GUDisksVolume* vol = find_volume(mon, dev);
+    GVolume* vol = g_udisks_device_get_volume(dev);
     /*
     gboolean is_drive = dev->is_drive;
     char* usage = g_strdup(dev->usage);
     */
-    g_debug("g_udisks_device_changed");
-    if(drv)
-    {
-        g_signal_emit(mon, sig_drive_changed, 0, drv);
-        g_udisks_drive_changed(drv);
-        /* it's no longer a drive */
-        if(!dev->is_drive)
-            remove_drive(mon, dev);
-    }
-    else
-    {
-        if(dev->is_drive)
-            add_drive(mon, dev, TRUE);
-    }
+    g_debug("%s", __func__);
 
     if(vol)
     {
-        update_volume_drive(vol, mon);
         g_signal_emit(mon, sig_volume_changed, 0, vol);
-        g_udisks_volume_changed(vol);
-
-        /* it's no longer a volume */
-        if(!g_udisks_device_is_volume(dev))
-            remove_volume(mon, dev);
-    }
-    else
-    {
-        /* we got a usable volume now */
-        if(g_udisks_device_is_volume(dev))
-            add_volume(mon, dev, TRUE);
+        g_udisks_volume_changed(G_UDISKS_VOLUME(vol));
+        g_object_unref(vol);
     }
 }
 
-static void g_udisks_device_removed(GUDisksDevice* dev, GUDisksVolumeMonitor* mon)
+static void on_mount_added(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon)
 {
-    g_debug("g_udisks_device_removed");
-
-    if(dev->is_drive)
-        remove_drive(mon, dev);
+    g_debug(__func__);
+    g_signal_emit(mon, sig_mount_added, 0, mnt);
+}
 
-    remove_volume(mon, dev);
+static void on_mount_preunmount(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon)
+{
+    g_debug(__func__);
+    g_signal_emit(mon, sig_mount_preunmount, 0, mnt);
 }
 
-static gboolean on_idle(GUDisksVolumeMonitor* mon)
+static void on_mount_removed(GUDisksDevice* dev, GUDisksMount* mnt, GUDisksVolumeMonitor* mon)
 {
-    GList* l;
-    g_debug("on_idle: %d", g_list_length(mon->queued_events));
-    for(l = mon->queued_events; l; l=l->next)
-    {
-        QueuedEvent* q = (QueuedEvent*)l->data;
-        q->func(q->dev, mon);
-        g_object_unref(q->dev);
-        g_slice_free(QueuedEvent, q);
-    }
-    g_list_free(mon->queued_events);
-    mon->queued_events = NULL;
-    mon->idle_handler = 0;
-    return FALSE;
+    g_debug(__func__);
+    g_signal_emit(mon, sig_mount_removed, 0, mnt);
 }
 
-static void g_udisks_device_queue_event(GUDisksDevice* dev, GUDisksDeviceEventHandler func, GUDisksVolumeMonitor* mon)
+static void on_drive_changed(GUDisksDrive* drv, GUDisksVolumeMonitor* mon)
 {
-    QueuedEvent* q = g_slice_new(QueuedEvent);
-    q->dev = g_object_ref(dev);
-    q->func = func;
-    mon->queued_events = g_list_append(mon->queued_events, q);
+    g_debug("on_drive_changed");
 
-    if(0 == mon->idle_handler)
-        mon->idle_handler = g_idle_add_full(G_PRIORITY_HIGH, (GSourceFunc)on_idle, mon, NULL);
+    g_signal_emit(mon, sig_drive_changed, 0, drv);
 }
 
-static void add_device(GUDisksVolumeMonitor* mon, DBusGProxy* proxy, const char* obj_path, gboolean emit_signal)
+static GUDisksDevice* add_device(GUDisksVolumeMonitor* mon, const char* obj_path,
+                                 gboolean do_introspection)
 {
     if(!find_device(mon, obj_path))
     {
-        DBusGProxy *dev_proxy = dbus_g_proxy_new_for_name(mon->con,
-                                            "org.freedesktop.UDisks",
-                                            obj_path,
-                                            "org.freedesktop.DBus.Properties");
         GError* err = NULL;
-        GHashTable* props = dbus_get_all_props(dev_proxy, "org.freedesktop.UDisks.Device", &err);
-        if(props)
+        GUDisksDevice* dev = g_udisks_device_new(obj_path, mon->con, mon->cancellable, &err);
+
+        if (!err)
         {
-            GUDisksDevice* dev = g_udisks_device_new(obj_path, props);
-            g_hash_table_destroy(props);
-
-            mon->devices = g_list_prepend(mon->devices, dev);
-            if(emit_signal)
-                g_udisks_device_queue_event(dev, g_udisks_device_added, mon);
-            else
-                _g_udisks_device_added(dev, mon, FALSE);
+            mon->devices = g_list_prepend(mon->devices, g_object_ref_sink(dev));
+            g_signal_connect(dev, "changed", G_CALLBACK(on_device_changed), mon);
+            g_signal_connect(dev, "mount-added", G_CALLBACK(on_mount_added), mon);
+            g_signal_connect(dev, "mount-pre-unmount", G_CALLBACK(on_mount_preunmount), mon);
+            g_signal_connect(dev, "mount-removed", G_CALLBACK(on_mount_removed), mon);
+            if (do_introspection)
+                _g_udisks_device_added(dev, mon, obj_path);
+            return dev;
         }
         else
         {
             g_debug("%s", err->message);
             g_error_free(err);
         }
-        g_object_unref(dev_proxy);
     }
-    g_debug("device_added: %s", obj_path);
-}
-
-void on_device_added(DBusGProxy* proxy, const char* obj_path, gpointer user_data)
-{
-    GUDisksVolumeMonitor* mon = G_UDISKS_VOLUME_MONITOR(user_data);
-    add_device(mon, proxy, obj_path, TRUE);
+    return NULL;
 }
 
-
-void on_device_removed(DBusGProxy* proxy, const char* obj_path, gpointer user_data)
+static void remove_device(GUDisksVolumeMonitor* mon, const char* obj_path)
 {
-    GUDisksVolumeMonitor* mon = G_UDISKS_VOLUME_MONITOR(user_data);
     GList* l;
     l = find_device_l(mon, obj_path);
     if(l)
     {
         GUDisksDevice* dev = G_UDISKS_DEVICE(l->data);
-        mon->devices = g_list_delete_link(mon->devices, l);
+        GVolume* vol = g_udisks_device_get_volume(dev);
 
-        g_udisks_device_queue_event(dev, g_udisks_device_removed, mon);
+        g_signal_handlers_disconnect_by_func(dev, G_CALLBACK(on_device_changed), mon);
+        g_signal_handlers_disconnect_by_func(dev, G_CALLBACK(on_mount_added), mon);
+        g_signal_handlers_disconnect_by_func(dev, G_CALLBACK(on_mount_preunmount), mon);
+        g_signal_handlers_disconnect_by_func(dev, G_CALLBACK(on_mount_removed), mon);
+        mon->devices = g_list_delete_link(mon->devices, l);
+        if (vol)
+        {
+            g_signal_emit(mon, sig_volume_removed, 0, vol);
+            g_udisks_volume_removed(G_UDISKS_VOLUME(vol));
+            g_object_unref(vol);
+        }
         g_object_unref(dev);
     }
     g_debug("device_removed: %s", obj_path);
 
 }
-
-void on_device_changed(DBusGProxy* proxy, const char* obj_path, gpointer user_data)
-{
-    GUDisksVolumeMonitor* mon = G_UDISKS_VOLUME_MONITOR(user_data);
-    GUDisksDevice* dev = find_device(mon, obj_path);
-    if(dev)
-    {
-        DBusGProxy *dev_proxy = dbus_g_proxy_new_for_name(mon->con,
-                                            "org.freedesktop.UDisks",
-                                            obj_path,
-                                            "org.freedesktop.DBus.Properties");
-
-        GError* err = NULL;
-        GHashTable* props = dbus_get_all_props(dev_proxy, "org.freedesktop.UDisks.Device", &err);
-        if(props)
-        {
-            g_udisks_device_update(dev, props);
-            g_hash_table_destroy(props);
-
-            g_udisks_device_queue_event(dev, g_udisks_device_changed, mon);
-        }
-        g_object_unref(dev_proxy);
-    }
-    g_debug("device_changed: %s", obj_path);
-}
-
diff --git a/src/udisks/g-udisks-volume-monitor.h b/src/udisks/g-udisks-volume-monitor.h
index a64f35b7..035914cf 100644
--- a/src/udisks/g-udisks-volume-monitor.h
+++ b/src/udisks/g-udisks-volume-monitor.h
@@ -24,7 +24,6 @@
 #define __G_UDISKS_VOLUME_MONITOR_H__
 
 #include <gio/gio.h>
-#include <dbus/dbus-glib.h>
 
 G_BEGIN_DECLS
 
@@ -41,19 +40,6 @@ G_BEGIN_DECLS
 typedef struct _GUDisksVolumeMonitor            GUDisksVolumeMonitor;
 typedef struct _GUDisksVolumeMonitorClass       GUDisksVolumeMonitorClass;
 
-struct _GUDisksVolumeMonitor
-{
-    GNativeVolumeMonitor parent;
-    DBusGConnection* con;
-    DBusGProxy* udisks_proxy;
-
-    GList* devices;
-    GList* drives;
-    GList* volumes;
-    guint idle_handler;
-    GList* queued_events;
-};
-
 struct _GUDisksVolumeMonitorClass
 {
     GNativeVolumeMonitorClass parent_class;
diff --git a/src/udisks/g-udisks-volume.c b/src/udisks/g-udisks-volume.c
index a1a4a98f..0d6f8b6c 100644
--- a/src/udisks/g-udisks-volume.c
+++ b/src/udisks/g-udisks-volume.c
@@ -1,6 +1,7 @@
 //      g-udisks-volume.c
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -21,22 +22,27 @@
 #include <config.h>
 #endif
 
-#include "g-udisks-volume.h"
 #include <glib/gi18n-lib.h>
-#include <string.h>
-#include "udisks.h"
-#include "udisks-device.h"
 #include "g-udisks-mount.h"
+#include "g-udisks-drive.h"
 #include "dbus-utils.h"
 
+#include <string.h>
+
+struct _GUDisksVolume
+{
+    GObject parent;
+    GUDisksDevice* dev; /* weak ref */
+    char* name;
+    GList* mounts; /* of GUDisksMount */
+    GFile* activation_root;
+};
+
 typedef struct
 {
     GUDisksVolume* vol;
     GAsyncReadyCallback callback;
     gpointer user_data;
-    DBusGProxy* proxy;
-    DBusGProxyCall* call;
-    GCancellable* cancellable;
 }AsyncData;
 
 static guint sig_changed;
@@ -47,9 +53,6 @@ static void g_udisks_volume_finalize            (GObject *object);
 
 static void g_udisks_volume_eject_with_operation (GVolume* base, GMountUnmountFlags flags, GMountOperation* mount_operation, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data);
 
-// static gboolean g_udisks_volume_eject_co (UdisksVolumeEjectData* data);
-// static gboolean g_udisks_volume_eject_with_operation_co (UdisksVolumeEjectWithOperationData* data);
-
 G_DEFINE_TYPE_EXTENDED (GUDisksVolume, g_udisks_volume, G_TYPE_OBJECT, 0,
                         G_IMPLEMENT_INTERFACE (G_TYPE_VOLUME,
                                                g_udisks_volume_volume_iface_init))
@@ -63,27 +66,6 @@ static void g_udisks_volume_class_init(GUDisksVolumeClass *klass)
     g_object_class->finalize = g_udisks_volume_finalize;
 }
 
-static void g_udisks_volume_clear(GUDisksVolume* vol)
-{
-    if(vol->mount)
-    {
-        g_object_unref(vol->mount);
-        vol->mount = NULL;
-    }
-
-    if(vol->icon)
-    {
-        g_object_unref(vol->icon);
-        vol->icon = NULL;
-    }
-
-    if(vol->name)
-    {
-        g_free(vol->name);
-        vol->name = NULL;
-    }
-}
-
 static void g_udisks_volume_finalize(GObject *object)
 {
     GUDisksVolume *self;
@@ -93,9 +75,20 @@ static void g_udisks_volume_finalize(GObject *object)
 
     self = G_UDISKS_VOLUME(object);
     if(self->dev)
-        g_object_unref(self->dev);
+        g_object_remove_weak_pointer(G_OBJECT(self->dev), (gpointer *)&self->dev);
+
+    while(self->mounts)
+    {
+        g_udisks_mount_unmounted(self->mounts->data);
+        g_object_unref(self->mounts->data);
+        self->mounts = g_list_delete_link(self->mounts, self->mounts);
+    }
+
+    if(self->activation_root)
+        g_object_unref(self->activation_root);
+
+    g_free(self->name);
 
-    g_udisks_volume_clear(self);
     G_OBJECT_CLASS(g_udisks_volume_parent_class)->finalize(object);
 }
 
@@ -105,30 +98,36 @@ static void g_udisks_volume_init(GUDisksVolume *self)
 }
 
 
-GUDisksVolume *g_udisks_volume_new(GUDisksVolumeMonitor* mon, GUDisksDevice* dev)
+GUDisksVolume *g_udisks_volume_new(GUDisksDevice* dev, GFile* activation_root)
 {
     GUDisksVolume* vol = (GUDisksVolume*)g_object_new(G_TYPE_UDISKS_VOLUME, NULL);
     vol->dev = g_object_ref(dev);
-    vol->mon = mon;
+    if (activation_root)
+        vol->activation_root = g_object_ref_sink(activation_root);
+    g_object_add_weak_pointer(G_OBJECT(dev), (gpointer *)&vol->dev);
+    g_udisks_device_set_volume(dev, G_VOLUME(vol));
     return vol;
 }
 
 static gboolean g_udisks_volume_can_eject (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    return vol->dev->is_ejectable;
+    GDrive* drive = g_udisks_device_get_drive(vol->dev);
+    gboolean ejectable = drive ? g_drive_can_eject(drive) : FALSE;
+    if (drive)
+        g_object_unref(drive);
+    return ejectable;
 }
 
 static gboolean g_udisks_volume_can_mount (GVolume* base)
 {
     /* FIXME, is this correct? */
-    GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    return !vol->dev->is_mounted;
+    //GUDisksVolume* vol = G_UDISKS_VOLUME(base);
+    return TRUE;
 }
 
 static void g_udisks_volume_eject (GVolume* base, GMountUnmountFlags flags, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data)
 {
-    //GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     g_udisks_volume_eject_with_operation(base, flags, NULL, cancellable, callback, user_data);
 }
 
@@ -151,20 +150,22 @@ static void on_drive_ejected(GObject* drive, GAsyncResult* res, gpointer user_da
 static void g_udisks_volume_eject_with_operation (GVolume* base, GMountUnmountFlags flags, GMountOperation* mount_operation, GCancellable* cancellable, GAsyncReadyCallback callback, gpointer user_data)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    if(vol->drive && g_drive_can_eject(G_DRIVE(vol->drive)))
+    GDrive* drive = g_udisks_device_get_drive(vol->dev);
+    if(drive && g_drive_can_eject(drive))
     {
         EjectData* data = g_slice_new(EjectData);
         data->vol = g_object_ref(vol);
         data->callback = callback;
         data->user_data = user_data;
-        g_drive_eject_with_operation(G_DRIVE(vol->drive), flags, mount_operation,
+        g_drive_eject_with_operation(drive, flags, mount_operation,
                                      cancellable, on_drive_ejected, data);
     }
+    if(drive)
+        g_object_unref(drive);
 }
 
 static char** g_udisks_volume_enumerate_identifiers (GVolume* base)
 {
-    //GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     char** kinds = g_new0(char*, 4);
     kinds[0] = g_strdup(G_VOLUME_IDENTIFIER_KIND_LABEL);
     kinds[1] = g_strdup(G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE);
@@ -177,24 +178,25 @@ static GFile* g_udisks_volume_get_activation_root (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     /* FIXME: is this corrcet? */
-    return vol->mount ? g_mount_get_root((GMount*)vol->mount) : NULL;
+    if(vol->mounts)
+        return g_mount_get_root((GMount*)vol->mounts->data);
+    return vol->activation_root ? g_object_ref(vol->activation_root) : NULL;
 }
 
 static GDrive* g_udisks_volume_get_drive (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    return vol->drive ? (GDrive*)g_object_ref(vol->drive) : NULL;
+    return g_udisks_device_get_drive(vol->dev);
 }
 
 static GIcon* g_udisks_volume_get_icon (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    if(!vol->icon)
-    {
-        const char* icon_name = g_udisks_device_get_icon_name(vol->dev);
-        vol->icon = g_themed_icon_new_with_default_fallbacks(icon_name);
-    }
-    return (GIcon*)g_object_ref(vol->icon);
+    GDrive* drive = g_udisks_device_get_drive(vol->dev);
+    GIcon* icon = drive ? g_drive_get_icon(drive) : NULL;
+    if (drive)
+        g_object_unref(drive);
+    return icon;
 }
 
 static char* g_udisks_volume_get_identifier (GVolume* base, const char* kind)
@@ -203,11 +205,11 @@ static char* g_udisks_volume_get_identifier (GVolume* base, const char* kind)
     if(kind)
     {
         if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_LABEL) == 0)
-            return g_strdup(vol->dev->label);
+            return g_udisks_device_get_label(vol->dev);
         else if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE) == 0)
-            return g_strdup(vol->dev->dev_file);
+            return g_udisks_device_get_dev_file(vol->dev);
         else if(strcmp(kind, G_VOLUME_IDENTIFIER_KIND_UUID) == 0)
-            return g_strdup(vol->dev->uuid);
+            return g_udisks_device_get_uuid(vol->dev);
     }
     return NULL;
 }
@@ -215,26 +217,25 @@ static char* g_udisks_volume_get_identifier (GVolume* base, const char* kind)
 static GMount* g_udisks_volume_get_mount (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    if(vol->dev->is_mounted && !vol->mount)
-    {
-        /* FIXME: will this work? */
-        vol->mount = g_udisks_mount_new(vol);
-    }
-    return vol->mount ? (GMount*)g_object_ref(vol->mount) : NULL;
+    return vol->mounts ? (GMount*)g_object_ref(vol->mounts->data) : NULL;
 }
 
 static char* g_udisks_volume_get_name (GVolume* base)
 {
-    /* TODO */
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     if(!vol->name)
     {
         GUDisksDevice* dev = vol->dev;
+        GDrive* drive = g_udisks_device_get_drive(dev);
         /* build a human readable name */
 
         /* FIXME: find a better way to build a nicer volume name */
-        if(dev->label && *dev->label)
-            vol->name = g_strdup(dev->label);
+        vol->name = g_udisks_device_get_label(dev);
+        if(vol->name && !vol->name[0])
+        {
+            g_free(vol->name);
+            vol->name = NULL;
+        }
 /*
         else if(vol->dev->partition_size > 0)
         {
@@ -243,14 +244,13 @@ static char* g_udisks_volume_get_name (GVolume* base)
             g_free(size_str);
         }
 */
-        else if(dev->is_optic_disc)
-            vol->name = g_strdup(g_udisks_device_get_disc_name(dev));
-        else if(dev->dev_file_presentation && *dev->dev_file_presentation)
-            vol->name = g_path_get_basename(dev->dev_file_presentation);
-        else if(dev->dev_file && *dev->dev_file)
-            vol->name = g_path_get_basename(vol->dev->dev_file);
-        else
-            vol->name = g_path_get_basename(vol->dev->obj_path);
+        if(!vol->name && drive)
+            vol->name = g_strdup(g_udisks_drive_get_disc_name(G_UDISKS_DRIVE(drive)));
+        if(!vol->name)
+            vol->name = g_udisks_device_get_dev_basename(dev);
+
+        if (drive)
+            g_object_unref(drive);
     }
     return g_strdup(vol->name);
 }
@@ -258,23 +258,21 @@ static char* g_udisks_volume_get_name (GVolume* base)
 static char* g_udisks_volume_get_uuid (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    return g_strdup(vol->dev->uuid);
-}
-
-static void on_mount_cancelled(GCancellable* cancellable, gpointer user_data)
-{
-    AsyncData* data = (AsyncData*)user_data;
-    dbus_g_proxy_cancel_call(data->proxy, data->call);
+    return g_udisks_device_get_uuid(vol->dev);
 }
 
-static void mount_callback(DBusGProxy *proxy, char * OUT_mount_path, GError *error, gpointer user_data)
+static void mount_callback(GObject *source, GAsyncResult *result, gpointer user_data)
 {
+    GDBusProxy* proxy = (GDBusProxy *)source;
     AsyncData* data = (AsyncData*)user_data;
     GSimpleAsyncResult* res;
+    GError *error = NULL;
+    GVariant *val = g_dbus_proxy_call_finish(proxy, result, &error);
+    const char *mount_path;
+
     g_debug("mount callback!!");
     if(error)
     {
-        error = g_udisks_error_to_gio_error(error);
         res = g_simple_async_result_new_from_error(G_OBJECT(data->vol),
                                                    data->callback,
                                                    data->user_data,
@@ -288,90 +286,88 @@ static void mount_callback(DBusGProxy *proxy, char * OUT_mount_path, GError *err
                                         data->user_data,
                                         NULL);
         g_simple_async_result_set_op_res_gboolean(res, TRUE);
-
-        /* FIXME: ensure we have working mount paths to generate GMount object. */
-        if(data->vol->dev->mount_paths)
-        {
-            char** p = data->vol->dev->mount_paths;
-            for(; *p; ++p)
-                if(strcmp(*p, OUT_mount_path) == 0)
-                    break;
-            if(!*p) /* OUT_mount_path is not in mount_paths */
-            {
-                int len = g_strv_length(data->vol->dev->mount_paths);
-                data->vol->dev->mount_paths = g_realloc(data->vol->dev->mount_paths, + 2);
-                memcpy(data->vol->dev->mount_paths, data->vol->dev->mount_paths + sizeof(char*), len * sizeof(char*));
-                data->vol->dev->mount_paths[0] = g_strdup(OUT_mount_path);
-            }
-        }
-        else
-        {
-            data->vol->dev->mount_paths = g_new0(char*, 2);
-            data->vol->dev->mount_paths[0] = g_strdup(OUT_mount_path);
-            data->vol->dev->mount_paths[1] = NULL;
-        }
-
+        g_variant_unref(val);
     }
+    g_object_ref_sink(res);
     g_simple_async_result_complete(res);
     g_object_unref(res);
 
-    if(data->cancellable)
-    {
-        g_signal_handlers_disconnect_by_func(data->cancellable, on_mount_cancelled, data);
-        g_object_unref(data->cancellable);
-    }
     g_object_unref(data->vol);
-    g_object_unref(data->proxy);
     g_slice_free(AsyncData, data);
 
 }
 
-static void g_udisks_volume_mount_fn(GVolume* base, GMountMountFlags flags, GMountOperation* mount_operation, GCancellable* cancellable, GAsyncReadyCallback callback, void* user_data)
+static void g_udisks_volume_mount_fn(GVolume* base, GMountMountFlags flags,
+                                     GMountOperation* mount_operation,
+                                     GCancellable* cancellable,
+                                     GAsyncReadyCallback callback, void* user_data)
 {
     /* FIXME: need to make sure this works correctly */
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     GUDisksDevice* dev = vol->dev;
-    GUDisksVolumeMonitor* mon = vol->mon;
-    AsyncData* data = g_slice_new(AsyncData);
-    DBusGProxy* proxy = g_udisks_device_get_proxy(dev, mon->con);
-    data->vol = g_object_ref(vol);
-    data->callback = callback;
-    data->user_data = user_data;
-    data->proxy = proxy;
-
-    g_debug("mount_fn");
-
-    data->call = org_freedesktop_UDisks_Device_filesystem_mount_async(
-                    proxy, dev->type ? dev->type : "auto", NULL, mount_callback, data);
-    if(cancellable)
+    GDBusProxy* proxy = g_udisks_device_get_fs_proxy(dev);
+
+    if (proxy)
     {
-        data->cancellable = g_object_ref(cancellable);
-        g_signal_connect(cancellable, "cancelled", G_CALLBACK(on_mount_cancelled), data);
+        AsyncData* data = g_slice_new(AsyncData);
+        GVariant* fstype = g_udisks_device_get_fstype(dev);
+        GVariantBuilder b;
+
+        g_debug("send DBus request to mount %s", g_udisks_device_get_obj_path(dev));
+        data->vol = g_object_ref(vol);
+        data->callback = callback;
+        data->user_data = user_data;
+
+        g_variant_builder_init(&b, G_VARIANT_TYPE("(a{sv})"));
+        g_variant_builder_open(&b, G_VARIANT_TYPE ("a{sv}"));
+        g_variant_builder_add(&b, "{sv}", "fstype", fstype);
+        g_variant_builder_close(&b);
+        g_dbus_proxy_call(proxy, "Mount", g_variant_builder_end(&b),
+                          G_DBUS_CALL_FLAGS_NONE, -1, cancellable,
+                          mount_callback, data);
+        g_object_unref(proxy);
+        g_variant_unref(fstype);
+    }
+    else
+    {
+        GSimpleAsyncResult* res;
+        char *dev_file = g_udisks_device_get_dev_file(dev);
+
+        res = g_simple_async_result_new_error(G_OBJECT(vol), callback, user_data,
+                                              G_IO_ERROR, G_IO_ERROR_FAILED,
+                                              _("No filesystem proxy for '%s'"),
+                                              dev_file);
+        g_object_ref_sink(res);
+        g_simple_async_result_complete(res);
+        g_object_unref(res);
+        g_free(dev_file);
     }
+    g_object_unref(dev);
 }
 
 static gboolean g_udisks_volume_mount_finish(GVolume* base, GAsyncResult* res, GError** error)
 {
-    //GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     return !g_simple_async_result_propagate_error(G_SIMPLE_ASYNC_RESULT(res), error);
 }
 
 static gboolean g_udisks_volume_should_automount (GVolume* base)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
-    return vol->dev->auto_mount;
+    return g_udisks_device_can_auto_mount(vol->dev);
 }
 
 static gboolean g_udisks_volume_eject_with_operation_finish (GVolume* base, GAsyncResult* res, GError** error)
 {
     GUDisksVolume* vol = G_UDISKS_VOLUME(base);
+    GDrive* drive = g_udisks_device_get_drive(vol->dev);
     /* FIXME: is this correct? */
-    return g_drive_eject_with_operation_finish(G_DRIVE(vol->drive), res, error);
+    gboolean ret = g_drive_eject_with_operation_finish(drive, res, error);
+    g_object_unref(drive);
+    return ret;
 }
 
 static gboolean g_udisks_volume_eject_finish (GVolume* base, GAsyncResult* res, GError** error)
 {
-    //GUDisksVolume* vol = G_UDISKS_VOLUME(base);
     return g_udisks_volume_eject_with_operation_finish(base, res, error);
 }
 
@@ -400,14 +396,106 @@ static void g_udisks_volume_volume_iface_init (GVolumeIface * iface)
     sig_removed = g_signal_lookup("removed", G_TYPE_VOLUME);
 }
 
+/**
+ * g_udisks_volume_set_mounts
+ * @vol: volume instance
+ * @mount_points: new list of nount points
+ *
+ * Updates mounts list to actual one. Allocates and releases GUDisksMount
+ * objects as needed.
+ *
+ * Returns: %TRUE if list was changed since last call.
+ */
+gboolean g_udisks_volume_set_mounts(GUDisksVolume* vol, char **mount_points)
+{
+    GList *new_list = NULL, *list;
+    char **point;
+    gboolean changed = FALSE;
+
+    g_return_val_if_fail(G_IS_UDISKS_VOLUME(vol), FALSE);
+
+    for (point = mount_points; point && *point; point++)
+    {
+        GFile *new_root = g_file_new_for_path(*point), *mount_root;
+
+        for (list = vol->mounts; list; list = list->next)
+        {
+            mount_root = g_mount_get_root(list->data);
+            if (g_file_equal(new_root, mount_root))
+            {
+                g_object_unref(mount_root);
+                vol->mounts = g_list_remove_link(vol->mounts, list);
+                new_list = g_list_concat(list, new_list);
+                break;
+            }
+            g_object_unref(mount_root);
+        }
+        if (!list)
+        {
+            new_list = g_list_prepend(new_list,
+                          g_object_ref_sink(g_udisks_mount_new(vol, new_root)));
+            g_debug("adding new mount for '%s' at '%s'",
+                    strrchr(g_udisks_device_get_obj_path(vol->dev), '/'),
+                    *point);
+            /* emit mount-added signal */
+            g_udisks_device_mount_added(vol->dev, new_list->data);
+            changed = TRUE;
+        }
+        g_object_unref(new_root);
+    }
+    while(vol->mounts)
+    {
+        GFile *f_root = g_mount_get_root(vol->mounts->data);
+        char *c_root = g_file_get_path(f_root);
+        g_debug("removing gone mount '%s'", c_root);
+        g_free(c_root);
+        g_object_unref(f_root);
+        /* emit mount-removed signals */
+        g_udisks_device_mount_removed(vol->dev, vol->mounts->data);
+        g_udisks_mount_unmounted(vol->mounts->data);
+        g_object_unref(vol->mounts->data);
+        vol->mounts = g_list_delete_link(vol->mounts, vol->mounts);
+        changed = TRUE;
+    }
+    vol->mounts = g_list_reverse(new_list);
+
+    return changed;
+}
+
+/**
+ * g_udisks_volume_get_mounts
+ * @vol: volume instance
+ *
+ * Retrieves currently mounted points.
+ *
+ * Returns: (element-type GUDisksMount)(transfer container): list of mounts.
+ */
+GList *g_udisks_volume_get_mounts(GUDisksVolume* vol)
+{
+    g_return_val_if_fail(G_IS_UDISKS_VOLUME(vol), NULL);
+    return g_list_copy(vol->mounts);
+}
+
+/**
+ * g_udisks_volume_get_device
+ * @vol: volume instance
+ *
+ * Retrieves device which volume belongs to.
+ *
+ * Returns: (transfer none): GUDisksDevice instance.
+ */
+GUDisksDevice *g_udisks_volume_get_device(GUDisksVolume* vol)
+{
+    g_return_val_if_fail(G_IS_UDISKS_VOLUME(vol), NULL);
+    return vol->dev;
+}
+
 void g_udisks_volume_changed(GUDisksVolume* vol)
 {
-    g_udisks_volume_clear(vol);
     g_signal_emit(vol, sig_changed, 0);
 }
 
 void g_udisks_volume_removed(GUDisksVolume* vol)
 {
-    vol->drive = NULL;
     g_signal_emit(vol, sig_removed, 0);
 }
diff --git a/src/udisks/g-udisks-volume.h b/src/udisks/g-udisks-volume.h
index 650a1c33..9de72835 100644
--- a/src/udisks/g-udisks-volume.h
+++ b/src/udisks/g-udisks-volume.h
@@ -1,6 +1,7 @@
 //      g-udisks-volume.h
 //
 //      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>
+//      Copyright 2021 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>
 //
 //      This program is free software; you can redistribute it and/or modify
 //      it under the terms of the GNU General Public License as published by
@@ -23,9 +24,6 @@
 
 #include <gio/gio.h>
 #include "g-udisks-device.h"
-#include "g-udisks-drive.h"
-#include "g-udisks-mount.h"
-#include "g-udisks-volume-monitor.h"
 
 G_BEGIN_DECLS
 
@@ -45,17 +43,6 @@ G_BEGIN_DECLS
 typedef struct _GUDisksVolume            GUDisksVolume;
 typedef struct _GUDisksVolumeClass        GUDisksVolumeClass;
 
-struct _GUDisksVolume
-{
-    GObject parent;
-    GUDisksDevice* dev;
-    GIcon* icon;
-    char* name;
-    GUDisksDrive* drive;
-    GUDisksMount* mount;
-    GUDisksVolumeMonitor* mon;
-};
-
 struct _GUDisksVolumeClass
 {
     GObjectClass parent_class;
@@ -63,7 +50,12 @@ struct _GUDisksVolumeClass
 
 
 GType        g_udisks_volume_get_type(void);
-GUDisksVolume* g_udisks_volume_new(GUDisksVolumeMonitor* mon, GUDisksDevice* dev);
+GUDisksVolume* g_udisks_volume_new(GUDisksDevice* dev, GFile* activation_root);
+
+gboolean g_udisks_volume_set_mounts(GUDisksVolume* vol, char **mount_points);
+GList *g_udisks_volume_get_mounts(GUDisksVolume* vol);
+
+GUDisksDevice *g_udisks_volume_get_device(GUDisksVolume* vol);
 
 void g_udisks_volume_changed(GUDisksVolume* vol);
 void g_udisks_volume_removed(GUDisksVolume* vol);
diff --git a/src/udisks/gen-binding b/src/udisks/gen-binding
deleted file mode 100755
index 08ac5004..00000000
--- a/src/udisks/gen-binding
+++ /dev/null
@@ -1,3 +0,0 @@
-#!/bin/sh
-dbus-binding-tool --mode=glib-client /usr/share/dbus-1/interfaces/org.freedesktop.UDisks.xml > udisks.h
-dbus-binding-tool --mode=glib-client /usr/share/dbus-1/interfaces/org.freedesktop.UDisks.Device.xml > udisks-device.h
diff --git a/src/udisks/udisks-device.h b/src/udisks/udisks-device.h
deleted file mode 100644
index 7b3e2aef..00000000
--- a/src/udisks/udisks-device.h
+++ /dev/null
@@ -1,1147 +0,0 @@
-/* Generated by dbus-binding-tool; do not edit! */
-
-#include <glib.h>
-#include <dbus/dbus-glib.h>
-
-G_BEGIN_DECLS
-
-#ifndef _DBUS_GLIB_ASYNC_DATA_FREE
-#define _DBUS_GLIB_ASYNC_DATA_FREE
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-void
-_dbus_glib_async_data_free (gpointer stuff)
-{
-	g_slice_free (DBusGAsyncData, stuff);
-}
-#endif
-
-#ifndef DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks_Device
-#define DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks_Device
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_job_cancel (DBusGProxy *proxy, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "JobCancel", error, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_job_cancel_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_job_cancel_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_job_cancel_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_job_cancel_async (DBusGProxy *proxy, org_freedesktop_UDisks_Device_job_cancel_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "JobCancel", org_freedesktop_UDisks_Device_job_cancel_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_partition_table_create (DBusGProxy *proxy, const char * IN_scheme, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "PartitionTableCreate", error, G_TYPE_STRING, IN_scheme, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_partition_table_create_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_partition_table_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_partition_table_create_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_partition_table_create_async (DBusGProxy *proxy, const char * IN_scheme, const char ** IN_options, org_freedesktop_UDisks_Device_partition_table_create_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "PartitionTableCreate", org_freedesktop_UDisks_Device_partition_table_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_scheme, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_partition_delete (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "PartitionDelete", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_partition_delete_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_partition_delete_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_partition_delete_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_partition_delete_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_partition_delete_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "PartitionDelete", org_freedesktop_UDisks_Device_partition_delete_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_partition_create (DBusGProxy *proxy, const guint64 IN_offset, const guint64 IN_size, const char * IN_type, const char * IN_label, const char ** IN_flags, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, char** OUT_created_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "PartitionCreate", error, G_TYPE_UINT64, IN_offset, G_TYPE_UINT64, IN_size, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_created_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_partition_create_reply) (DBusGProxy *proxy, char *OUT_created_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_partition_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_created_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_created_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_partition_create_reply)data->cb) (proxy, OUT_created_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_partition_create_async (DBusGProxy *proxy, const guint64 IN_offset, const guint64 IN_size, const char * IN_type, const char * IN_label, const char ** IN_flags, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, org_freedesktop_UDisks_Device_partition_create_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "PartitionCreate", org_freedesktop_UDisks_Device_partition_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT64, IN_offset, G_TYPE_UINT64, IN_size, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_partition_modify (DBusGProxy *proxy, const char * IN_type, const char * IN_label, const char ** IN_flags, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "PartitionModify", error, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_partition_modify_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_partition_modify_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_partition_modify_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_partition_modify_async (DBusGProxy *proxy, const char * IN_type, const char * IN_label, const char ** IN_flags, org_freedesktop_UDisks_Device_partition_modify_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "PartitionModify", org_freedesktop_UDisks_Device_partition_modify_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_create (DBusGProxy *proxy, const char * IN_fstype, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemCreate", error, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_create_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_create_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_create_async (DBusGProxy *proxy, const char * IN_fstype, const char ** IN_options, org_freedesktop_UDisks_Device_filesystem_create_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemCreate", org_freedesktop_UDisks_Device_filesystem_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_set_label (DBusGProxy *proxy, const char * IN_new_label, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemSetLabel", error, G_TYPE_STRING, IN_new_label, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_set_label_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_set_label_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_set_label_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_set_label_async (DBusGProxy *proxy, const char * IN_new_label, org_freedesktop_UDisks_Device_filesystem_set_label_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemSetLabel", org_freedesktop_UDisks_Device_filesystem_set_label_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_new_label, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_mount (DBusGProxy *proxy, const char * IN_filesystem_type, const char ** IN_options, char ** OUT_mount_path, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemMount", error, G_TYPE_STRING, IN_filesystem_type, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_mount_path, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_mount_reply) (DBusGProxy *proxy, char * OUT_mount_path, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_mount_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_mount_path;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_mount_path, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_mount_reply)data->cb) (proxy, OUT_mount_path, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_mount_async (DBusGProxy *proxy, const char * IN_filesystem_type, const char ** IN_options, org_freedesktop_UDisks_Device_filesystem_mount_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemMount", org_freedesktop_UDisks_Device_filesystem_mount_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_filesystem_type, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_unmount (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemUnmount", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_unmount_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_unmount_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_unmount_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_unmount_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_filesystem_unmount_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemUnmount", org_freedesktop_UDisks_Device_filesystem_unmount_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_check (DBusGProxy *proxy, const char ** IN_options, gboolean* OUT_is_clean, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemCheck", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_BOOLEAN, OUT_is_clean, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_check_reply) (DBusGProxy *proxy, gboolean OUT_is_clean, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_check_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  gboolean OUT_is_clean;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_BOOLEAN, &OUT_is_clean, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_check_reply)data->cb) (proxy, OUT_is_clean, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_check_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_filesystem_check_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemCheck", org_freedesktop_UDisks_Device_filesystem_check_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_filesystem_list_open_files (DBusGProxy *proxy, GPtrArray** OUT_processes, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FilesystemListOpenFiles", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_INVALID)), OUT_processes, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_filesystem_list_open_files_reply) (DBusGProxy *proxy, GPtrArray *OUT_processes, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_filesystem_list_open_files_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_processes;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_INVALID)), &OUT_processes, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_filesystem_list_open_files_reply)data->cb) (proxy, OUT_processes, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_filesystem_list_open_files_async (DBusGProxy *proxy, org_freedesktop_UDisks_Device_filesystem_list_open_files_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FilesystemListOpenFiles", org_freedesktop_UDisks_Device_filesystem_list_open_files_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_luks_unlock (DBusGProxy *proxy, const char * IN_passphrase, const char ** IN_options, char** OUT_cleartext_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LuksUnlock", error, G_TYPE_STRING, IN_passphrase, G_TYPE_STRV, IN_options, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_cleartext_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_luks_unlock_reply) (DBusGProxy *proxy, char *OUT_cleartext_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_luks_unlock_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_cleartext_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_cleartext_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_luks_unlock_reply)data->cb) (proxy, OUT_cleartext_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_luks_unlock_async (DBusGProxy *proxy, const char * IN_passphrase, const char ** IN_options, org_freedesktop_UDisks_Device_luks_unlock_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LuksUnlock", org_freedesktop_UDisks_Device_luks_unlock_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_passphrase, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_luks_lock (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LuksLock", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_luks_lock_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_luks_lock_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_luks_lock_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_luks_lock_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_luks_lock_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LuksLock", org_freedesktop_UDisks_Device_luks_lock_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_luks_change_passphrase (DBusGProxy *proxy, const char * IN_current_passphrase, const char * IN_new_passphrase, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LuksChangePassphrase", error, G_TYPE_STRING, IN_current_passphrase, G_TYPE_STRING, IN_new_passphrase, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_luks_change_passphrase_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_luks_change_passphrase_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_luks_change_passphrase_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_luks_change_passphrase_async (DBusGProxy *proxy, const char * IN_current_passphrase, const char * IN_new_passphrase, org_freedesktop_UDisks_Device_luks_change_passphrase_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LuksChangePassphrase", org_freedesktop_UDisks_Device_luks_change_passphrase_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_current_passphrase, G_TYPE_STRING, IN_new_passphrase, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_md_add_spare (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdAddSpare", error, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_md_add_spare_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_md_add_spare_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_md_add_spare_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_md_add_spare_async (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, org_freedesktop_UDisks_Device_linux_md_add_spare_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdAddSpare", org_freedesktop_UDisks_Device_linux_md_add_spare_async_callback, stuff, _dbus_glib_async_data_free, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_md_expand (DBusGProxy *proxy, const GPtrArray* IN_components, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdExpand", error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_md_expand_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_md_expand_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_md_expand_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_md_expand_async (DBusGProxy *proxy, const GPtrArray* IN_components, const char ** IN_options, org_freedesktop_UDisks_Device_linux_md_expand_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdExpand", org_freedesktop_UDisks_Device_linux_md_expand_async_callback, stuff, _dbus_glib_async_data_free, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_md_remove_component (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdRemoveComponent", error, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_md_remove_component_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_md_remove_component_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_md_remove_component_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_md_remove_component_async (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, org_freedesktop_UDisks_Device_linux_md_remove_component_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdRemoveComponent", org_freedesktop_UDisks_Device_linux_md_remove_component_async_callback, stuff, _dbus_glib_async_data_free, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_md_stop (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdStop", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_md_stop_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_md_stop_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_md_stop_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_md_stop_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_linux_md_stop_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdStop", org_freedesktop_UDisks_Device_linux_md_stop_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_lvm2_lv_stop (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2LVStop", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2LVStop", org_freedesktop_UDisks_Device_linux_lvm2_lv_stop_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_linux_md_check (DBusGProxy *proxy, const char ** IN_options, guint64* OUT_number_of_errors, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdCheck", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_UINT64, OUT_number_of_errors, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_linux_md_check_reply) (DBusGProxy *proxy, guint64 OUT_number_of_errors, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_linux_md_check_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  guint64 OUT_number_of_errors;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_UINT64, &OUT_number_of_errors, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_linux_md_check_reply)data->cb) (proxy, OUT_number_of_errors, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_linux_md_check_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_linux_md_check_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdCheck", org_freedesktop_UDisks_Device_linux_md_check_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_inhibit_polling (DBusGProxy *proxy, const char ** IN_options, char ** OUT_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveInhibitPolling", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_inhibit_polling_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_inhibit_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_cookie;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_inhibit_polling_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_inhibit_polling_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_drive_inhibit_polling_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveInhibitPolling", org_freedesktop_UDisks_Device_drive_inhibit_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_uninhibit_polling (DBusGProxy *proxy, const char * IN_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveUninhibitPolling", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_uninhibit_polling_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_uninhibit_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_uninhibit_polling_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_uninhibit_polling_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_UDisks_Device_drive_uninhibit_polling_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveUninhibitPolling", org_freedesktop_UDisks_Device_drive_uninhibit_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_poll_media (DBusGProxy *proxy, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DrivePollMedia", error, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_poll_media_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_poll_media_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_poll_media_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_poll_media_async (DBusGProxy *proxy, org_freedesktop_UDisks_Device_drive_poll_media_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DrivePollMedia", org_freedesktop_UDisks_Device_drive_poll_media_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_eject (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveEject", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_eject_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_eject_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_eject_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_eject_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_drive_eject_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveEject", org_freedesktop_UDisks_Device_drive_eject_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_detach (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveDetach", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_detach_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_detach_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_detach_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_detach_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_drive_detach_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveDetach", org_freedesktop_UDisks_Device_drive_detach_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_set_spindown_timeout (DBusGProxy *proxy, const gint IN_timeout_seconds, const char ** IN_options, char ** OUT_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveSetSpindownTimeout", error, G_TYPE_INT, IN_timeout_seconds, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_set_spindown_timeout_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_set_spindown_timeout_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_cookie;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_set_spindown_timeout_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_set_spindown_timeout_async (DBusGProxy *proxy, const gint IN_timeout_seconds, const char ** IN_options, org_freedesktop_UDisks_Device_drive_set_spindown_timeout_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveSetSpindownTimeout", org_freedesktop_UDisks_Device_drive_set_spindown_timeout_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INT, IN_timeout_seconds, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_unset_spindown_timeout (DBusGProxy *proxy, const char * IN_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveUnsetSpindownTimeout", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveUnsetSpindownTimeout", org_freedesktop_UDisks_Device_drive_unset_spindown_timeout_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data (DBusGProxy *proxy, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveAtaSmartRefreshData", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveAtaSmartRefreshData", org_freedesktop_UDisks_Device_drive_ata_smart_refresh_data_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest (DBusGProxy *proxy, const char * IN_test, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveAtaSmartInitiateSelftest", error, G_TYPE_STRING, IN_test, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_async (DBusGProxy *proxy, const char * IN_test, const char ** IN_options, org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveAtaSmartInitiateSelftest", org_freedesktop_UDisks_Device_drive_ata_smart_initiate_selftest_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_test, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_Device_drive_benchmark (DBusGProxy *proxy, const gboolean IN_do_write_benchmark, const char ** IN_options, GPtrArray** OUT_read_transfer_rate_results, GPtrArray** OUT_write_transfer_rate_results, GPtrArray** OUT_access_time_results, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveBenchmark", error, G_TYPE_BOOLEAN, IN_do_write_benchmark, G_TYPE_STRV, IN_options, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), OUT_read_transfer_rate_results, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), OUT_write_transfer_rate_results, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), OUT_access_time_results, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_Device_drive_benchmark_reply) (DBusGProxy *proxy, GPtrArray *OUT_read_transfer_rate_results, GPtrArray *OUT_write_transfer_rate_results, GPtrArray *OUT_access_time_results, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_Device_drive_benchmark_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_read_transfer_rate_results;
-  GPtrArray* OUT_write_transfer_rate_results;
-  GPtrArray* OUT_access_time_results;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), &OUT_read_transfer_rate_results, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), &OUT_write_transfer_rate_results, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_INVALID)), &OUT_access_time_results, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_Device_drive_benchmark_reply)data->cb) (proxy, OUT_read_transfer_rate_results, OUT_write_transfer_rate_results, OUT_access_time_results, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_Device_drive_benchmark_async (DBusGProxy *proxy, const gboolean IN_do_write_benchmark, const char ** IN_options, org_freedesktop_UDisks_Device_drive_benchmark_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveBenchmark", org_freedesktop_UDisks_Device_drive_benchmark_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_BOOLEAN, IN_do_write_benchmark, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks_Device */
-
-G_END_DECLS
diff --git a/src/udisks/udisks.h b/src/udisks/udisks.h
deleted file mode 100644
index 9bf0baae..00000000
--- a/src/udisks/udisks.h
+++ /dev/null
@@ -1,927 +0,0 @@
-/* Generated by dbus-binding-tool; do not edit! */
-
-#include <glib.h>
-#include <dbus/dbus-glib.h>
-
-G_BEGIN_DECLS
-
-#ifndef _DBUS_GLIB_ASYNC_DATA_FREE
-#define _DBUS_GLIB_ASYNC_DATA_FREE
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-void
-_dbus_glib_async_data_free (gpointer stuff)
-{
-	g_slice_free (DBusGAsyncData, stuff);
-}
-#endif
-
-#ifndef DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks
-#define DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_enumerate_adapters (DBusGProxy *proxy, GPtrArray** OUT_devices, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "EnumerateAdapters", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), OUT_devices, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_enumerate_adapters_reply) (DBusGProxy *proxy, GPtrArray *OUT_devices, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_enumerate_adapters_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_devices;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &OUT_devices, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_enumerate_adapters_reply)data->cb) (proxy, OUT_devices, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_enumerate_adapters_async (DBusGProxy *proxy, org_freedesktop_UDisks_enumerate_adapters_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "EnumerateAdapters", org_freedesktop_UDisks_enumerate_adapters_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_enumerate_expanders (DBusGProxy *proxy, GPtrArray** OUT_devices, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "EnumerateExpanders", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), OUT_devices, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_enumerate_expanders_reply) (DBusGProxy *proxy, GPtrArray *OUT_devices, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_enumerate_expanders_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_devices;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &OUT_devices, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_enumerate_expanders_reply)data->cb) (proxy, OUT_devices, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_enumerate_expanders_async (DBusGProxy *proxy, org_freedesktop_UDisks_enumerate_expanders_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "EnumerateExpanders", org_freedesktop_UDisks_enumerate_expanders_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_enumerate_ports (DBusGProxy *proxy, GPtrArray** OUT_devices, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "EnumeratePorts", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), OUT_devices, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_enumerate_ports_reply) (DBusGProxy *proxy, GPtrArray *OUT_devices, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_enumerate_ports_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_devices;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &OUT_devices, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_enumerate_ports_reply)data->cb) (proxy, OUT_devices, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_enumerate_ports_async (DBusGProxy *proxy, org_freedesktop_UDisks_enumerate_ports_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "EnumeratePorts", org_freedesktop_UDisks_enumerate_ports_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_enumerate_devices (DBusGProxy *proxy, GPtrArray** OUT_devices, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "EnumerateDevices", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), OUT_devices, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_enumerate_devices_reply) (DBusGProxy *proxy, GPtrArray *OUT_devices, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_enumerate_devices_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  GPtrArray* OUT_devices;
-  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), &OUT_devices, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_enumerate_devices_reply)data->cb) (proxy, OUT_devices, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_enumerate_devices_async (DBusGProxy *proxy, org_freedesktop_UDisks_enumerate_devices_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "EnumerateDevices", org_freedesktop_UDisks_enumerate_devices_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_enumerate_device_files (DBusGProxy *proxy, char *** OUT_device_files, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "EnumerateDeviceFiles", error, G_TYPE_INVALID, G_TYPE_STRV, OUT_device_files, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_enumerate_device_files_reply) (DBusGProxy *proxy, char * *OUT_device_files, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_enumerate_device_files_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char ** OUT_device_files;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRV, &OUT_device_files, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_enumerate_device_files_reply)data->cb) (proxy, OUT_device_files, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_enumerate_device_files_async (DBusGProxy *proxy, org_freedesktop_UDisks_enumerate_device_files_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "EnumerateDeviceFiles", org_freedesktop_UDisks_enumerate_device_files_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_find_device_by_device_file (DBusGProxy *proxy, const char * IN_device_file, char** OUT_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FindDeviceByDeviceFile", error, G_TYPE_STRING, IN_device_file, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_find_device_by_device_file_reply) (DBusGProxy *proxy, char *OUT_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_find_device_by_device_file_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_find_device_by_device_file_reply)data->cb) (proxy, OUT_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_find_device_by_device_file_async (DBusGProxy *proxy, const char * IN_device_file, org_freedesktop_UDisks_find_device_by_device_file_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FindDeviceByDeviceFile", org_freedesktop_UDisks_find_device_by_device_file_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_device_file, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_find_device_by_major_minor (DBusGProxy *proxy, const gint64 IN_device_major, const gint64 IN_device_minor, char** OUT_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "FindDeviceByMajorMinor", error, G_TYPE_INT64, IN_device_major, G_TYPE_INT64, IN_device_minor, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_find_device_by_major_minor_reply) (DBusGProxy *proxy, char *OUT_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_find_device_by_major_minor_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_find_device_by_major_minor_reply)data->cb) (proxy, OUT_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_find_device_by_major_minor_async (DBusGProxy *proxy, const gint64 IN_device_major, const gint64 IN_device_minor, org_freedesktop_UDisks_find_device_by_major_minor_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "FindDeviceByMajorMinor", org_freedesktop_UDisks_find_device_by_major_minor_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INT64, IN_device_major, G_TYPE_INT64, IN_device_minor, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_drive_inhibit_all_polling (DBusGProxy *proxy, const char ** IN_options, char ** OUT_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveInhibitAllPolling", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_drive_inhibit_all_polling_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_drive_inhibit_all_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_cookie;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_drive_inhibit_all_polling_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_drive_inhibit_all_polling_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_UDisks_drive_inhibit_all_polling_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveInhibitAllPolling", org_freedesktop_UDisks_drive_inhibit_all_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_drive_uninhibit_all_polling (DBusGProxy *proxy, const char * IN_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveUninhibitAllPolling", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_drive_uninhibit_all_polling_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_drive_uninhibit_all_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_drive_uninhibit_all_polling_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_drive_uninhibit_all_polling_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_UDisks_drive_uninhibit_all_polling_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveUninhibitAllPolling", org_freedesktop_UDisks_drive_uninhibit_all_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_drive_set_all_spindown_timeouts (DBusGProxy *proxy, const gint IN_timeout_seconds, const char ** IN_options, char ** OUT_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveSetAllSpindownTimeouts", error, G_TYPE_INT, IN_timeout_seconds, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_drive_set_all_spindown_timeouts_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_drive_set_all_spindown_timeouts_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_cookie;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_drive_set_all_spindown_timeouts_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_drive_set_all_spindown_timeouts_async (DBusGProxy *proxy, const gint IN_timeout_seconds, const char ** IN_options, org_freedesktop_UDisks_drive_set_all_spindown_timeouts_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveSetAllSpindownTimeouts", org_freedesktop_UDisks_drive_set_all_spindown_timeouts_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INT, IN_timeout_seconds, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_drive_unset_all_spindown_timeouts (DBusGProxy *proxy, const char * IN_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "DriveUnsetAllSpindownTimeouts", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "DriveUnsetAllSpindownTimeouts", org_freedesktop_UDisks_drive_unset_all_spindown_timeouts_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_vg_start (DBusGProxy *proxy, const char * IN_uuid, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2VGStart", error, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_vg_start_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_vg_start_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_vg_start_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_vg_start_async (DBusGProxy *proxy, const char * IN_uuid, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_vg_start_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2VGStart", org_freedesktop_UDisks_linux_lvm2_vg_start_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_vg_stop (DBusGProxy *proxy, const char * IN_uuid, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2VGStop", error, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_vg_stop_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_vg_stop_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_vg_stop_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_vg_stop_async (DBusGProxy *proxy, const char * IN_uuid, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_vg_stop_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2VGStop", org_freedesktop_UDisks_linux_lvm2_vg_stop_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_vg_set_name (DBusGProxy *proxy, const char * IN_uuid, const char * IN_name, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2VGSetName", error, G_TYPE_STRING, IN_uuid, G_TYPE_STRING, IN_name, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_vg_set_name_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_vg_set_name_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_vg_set_name_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_vg_set_name_async (DBusGProxy *proxy, const char * IN_uuid, const char * IN_name, org_freedesktop_UDisks_linux_lvm2_vg_set_name_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2VGSetName", org_freedesktop_UDisks_linux_lvm2_vg_set_name_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_uuid, G_TYPE_STRING, IN_name, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_vg_add_pv (DBusGProxy *proxy, const char * IN_uuid, const char* IN_physical_volume, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2VGAddPV", error, G_TYPE_STRING, IN_uuid, DBUS_TYPE_G_OBJECT_PATH, IN_physical_volume, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_vg_add_pv_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_vg_add_pv_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_vg_add_pv_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_vg_add_pv_async (DBusGProxy *proxy, const char * IN_uuid, const char* IN_physical_volume, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_vg_add_pv_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2VGAddPV", org_freedesktop_UDisks_linux_lvm2_vg_add_pv_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_uuid, DBUS_TYPE_G_OBJECT_PATH, IN_physical_volume, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_vg_remove_pv (DBusGProxy *proxy, const char * IN_vg_uuid, const char * IN_pv_uuid, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2VGRemovePV", error, G_TYPE_STRING, IN_vg_uuid, G_TYPE_STRING, IN_pv_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_async (DBusGProxy *proxy, const char * IN_vg_uuid, const char * IN_pv_uuid, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2VGRemovePV", org_freedesktop_UDisks_linux_lvm2_vg_remove_pv_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_vg_uuid, G_TYPE_STRING, IN_pv_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_lv_set_name (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char * IN_name, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2LVSetName", error, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRING, IN_name, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_lv_set_name_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_lv_set_name_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_lv_set_name_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_lv_set_name_async (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char * IN_name, org_freedesktop_UDisks_linux_lvm2_lv_set_name_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2LVSetName", org_freedesktop_UDisks_linux_lvm2_lv_set_name_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRING, IN_name, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_lv_start (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2LVStart", error, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_lv_start_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_lv_start_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_lv_start_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_lv_start_async (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_lv_start_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2LVStart", org_freedesktop_UDisks_linux_lvm2_lv_start_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_lv_remove (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char ** IN_options, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2LVRemove", error, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_lv_remove_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_lv_remove_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_lv_remove_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_lv_remove_async (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_uuid, const char ** IN_options, org_freedesktop_UDisks_linux_lvm2_lv_remove_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2LVRemove", org_freedesktop_UDisks_linux_lvm2_lv_remove_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_uuid, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_lvm2_lv_create (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_name, const guint64 IN_size, const guint IN_num_stripes, const guint64 IN_stripe_size, const guint IN_num_mirrors, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, char** OUT_created_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxLvm2LVCreate", error, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_name, G_TYPE_UINT64, IN_size, G_TYPE_UINT, IN_num_stripes, G_TYPE_UINT64, IN_stripe_size, G_TYPE_UINT, IN_num_mirrors, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_created_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_lvm2_lv_create_reply) (DBusGProxy *proxy, char *OUT_created_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_lvm2_lv_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_created_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_created_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_lvm2_lv_create_reply)data->cb) (proxy, OUT_created_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_lvm2_lv_create_async (DBusGProxy *proxy, const char * IN_group_uuid, const char * IN_name, const guint64 IN_size, const guint IN_num_stripes, const guint64 IN_stripe_size, const guint IN_num_mirrors, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, org_freedesktop_UDisks_linux_lvm2_lv_create_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxLvm2LVCreate", org_freedesktop_UDisks_linux_lvm2_lv_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_group_uuid, G_TYPE_STRING, IN_name, G_TYPE_UINT64, IN_size, G_TYPE_UINT, IN_num_stripes, G_TYPE_UINT64, IN_stripe_size, G_TYPE_UINT, IN_num_mirrors, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_md_start (DBusGProxy *proxy, const GPtrArray* IN_components, const char ** IN_options, char** OUT_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdStart", error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRV, IN_options, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_md_start_reply) (DBusGProxy *proxy, char *OUT_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_md_start_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_md_start_reply)data->cb) (proxy, OUT_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_md_start_async (DBusGProxy *proxy, const GPtrArray* IN_components, const char ** IN_options, org_freedesktop_UDisks_linux_md_start_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdStart", org_freedesktop_UDisks_linux_md_start_async_callback, stuff, _dbus_glib_async_data_free, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_linux_md_create (DBusGProxy *proxy, const GPtrArray* IN_components, const char * IN_level, const guint64 IN_stripe_size, const char * IN_name, const char ** IN_options, char** OUT_device, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "LinuxMdCreate", error, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRING, IN_level, G_TYPE_UINT64, IN_stripe_size, G_TYPE_STRING, IN_name, G_TYPE_STRV, IN_options, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_device, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_linux_md_create_reply) (DBusGProxy *proxy, char *OUT_device, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_linux_md_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char* OUT_device;
-  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_device, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_linux_md_create_reply)data->cb) (proxy, OUT_device, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_linux_md_create_async (DBusGProxy *proxy, const GPtrArray* IN_components, const char * IN_level, const guint64 IN_stripe_size, const char * IN_name, const char ** IN_options, org_freedesktop_UDisks_linux_md_create_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "LinuxMdCreate", org_freedesktop_UDisks_linux_md_create_async_callback, stuff, _dbus_glib_async_data_free, dbus_g_type_get_collection ("GPtrArray", DBUS_TYPE_G_OBJECT_PATH), IN_components, G_TYPE_STRING, IN_level, G_TYPE_UINT64, IN_stripe_size, G_TYPE_STRING, IN_name, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_inhibit (DBusGProxy *proxy, char ** OUT_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "Inhibit", error, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_inhibit_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_inhibit_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  char * OUT_cookie;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_inhibit_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_inhibit_async (DBusGProxy *proxy, org_freedesktop_UDisks_inhibit_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "Inhibit", org_freedesktop_UDisks_inhibit_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
-}
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-gboolean
-org_freedesktop_UDisks_uninhibit (DBusGProxy *proxy, const char * IN_cookie, GError **error)
-
-{
-  return dbus_g_proxy_call (proxy, "Uninhibit", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
-}
-
-typedef void (*org_freedesktop_UDisks_uninhibit_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);
-
-static void
-org_freedesktop_UDisks_uninhibit_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
-{
-  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
-  GError *error = NULL;
-  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
-  (*(org_freedesktop_UDisks_uninhibit_reply)data->cb) (proxy, error, data->userdata);
-  return;
-}
-
-static
-#ifdef G_HAVE_INLINE
-inline
-#endif
-DBusGProxyCall*
-org_freedesktop_UDisks_uninhibit_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_UDisks_uninhibit_reply callback, gpointer userdata)
-
-{
-  DBusGAsyncData *stuff;
-  stuff = g_slice_new (DBusGAsyncData);
-  stuff->cb = G_CALLBACK (callback);
-  stuff->userdata = userdata;
-  return dbus_g_proxy_begin_call (proxy, "Uninhibit", org_freedesktop_UDisks_uninhibit_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
-}
-#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_UDisks */
-
-G_END_DECLS

