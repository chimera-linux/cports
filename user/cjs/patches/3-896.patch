From 97c5442151f3214aec838dfa8dede874fe3893d0 Mon Sep 17 00:00:00 2001
From: Philip Chimento <philip.chimento@gmail.com>
Date: Sat, 14 Oct 2023 20:26:28 -0700
Subject: [PATCH] Gtk3: Fix leak in GtkBuilder template signal connections

The widget class's GtkBuilderConnectFunc would previously capture the
newly created object instance, making it unable to be collected.

It's not actually necessary for the GtkBuilderConnectFunc to capture an
external reference to the object instance. It can be obtained from
Gtk.Builder.prototype.get_objects() because for a template, there will
always be one of the created objects that is of the template type.

There is still a leak in Gtk4 template signal connections, see !891. The
test cases are adapted from there, and are written by James Westman.
---
 installed-tests/js/testGtk3.js      | 25 ++++++++++++++++++++++++-
 installed-tests/js/testLegacyGtk.js | 28 +++++++++++++++++++++++++++-
 modules/core/overrides/Gtk.js       | 19 +++++++++++--------
 3 files changed, 62 insertions(+), 10 deletions(-)

diff --git a/installed-tests/js/testGtk3.js b/installed-tests/js/testGtk3.js
index f409f255d..2fa57da5d 100644
--- a/installed-tests/js/testGtk3.js
+++ b/installed-tests/js/testGtk3.js
@@ -4,7 +4,7 @@
 imports.gi.versions.Gtk = '3.0';
 
 const ByteArray = imports.byteArray;
-const {GLib, Gio, GObject, Gtk} = imports.gi;
+const {GLib, Gio, GjsTestTools, GObject, Gtk} = imports.gi;
 const System = imports.system;
 
 // This is ugly here, but usually it would be in a resource
@@ -304,4 +304,27 @@ describe('Gtk overrides', function () {
         expect(() => widget.show()).not.toThrow();
         expect(frameChild.visible).toBe(true);
     });
+
+    it('does not leak instance when connecting template signal', function () {
+        const LeakTestWidget = GObject.registerClass({
+            Template: ByteArray.fromString(`
+                <interface>
+                    <template class="Gjs_LeakTestWidget" parent="GtkButton">
+                        <signal name="clicked" handler="buttonClicked"/>
+                    </template>
+                </interface>`),
+        }, class LeakTestWidget extends Gtk.Button {
+            buttonClicked() {}
+        });
+
+        let widget = new LeakTestWidget();
+        GjsTestTools.save_weak(widget);
+        widget = null;
+        // It takes two GC cycles to free the widget, because of the tardy sweep
+        // problem (https://gitlab.gnome.org/GNOME/gjs/-/issues/217)
+        System.gc();
+        System.gc();
+
+        expect(GjsTestTools.get_weak()).toBeNull();
+    });
 });
diff --git a/installed-tests/js/testLegacyGtk.js b/installed-tests/js/testLegacyGtk.js
index 9e3827fbb..231c51c58 100644
--- a/installed-tests/js/testLegacyGtk.js
+++ b/installed-tests/js/testLegacyGtk.js
@@ -6,8 +6,9 @@
 imports.gi.versions.Gtk = '3.0';
 
 const ByteArray = imports.byteArray;
-const Gtk = imports.gi.Gtk;
+const {GjsTestTools, Gtk} = imports.gi;
 const Lang = imports.lang;
+const System = imports.system;
 
 const template = `
 <interface>
@@ -112,4 +113,29 @@ describe('Legacy Gtk overrides', function () {
     it('sets CSS names on classes', function () {
         expect(Gtk.Widget.get_css_name.call(MyComplexGtkSubclass)).toEqual('complex-subclass');
     });
+
+    it('does not leak instance when connecting template signal', function () {
+        const LeakTestWidget = new Lang.Class({
+            Name: 'LeakTestWidget',
+            Extends: Gtk.Button,
+            Template: ByteArray.fromString(`
+                <interface>
+                    <template class="Gjs_LeakTestWidget" parent="GtkButton">
+                        <signal name="clicked" handler="buttonClicked"/>
+                    </template>
+                </interface>`),
+
+            buttonClicked() {},
+        });
+
+        let widget = new LeakTestWidget();
+        GjsTestTools.save_weak(widget);
+        widget = null;
+        // It takes two GC cycles to free the widget, because of the tardy sweep
+        // problem (https://gitlab.gnome.org/GNOME/gjs/-/issues/217)
+        System.gc();
+        System.gc();
+
+        expect(GjsTestTools.get_weak()).toBeNull();
+    });
 });
diff --git a/modules/core/overrides/Gtk.js b/modules/core/overrides/Gtk.js
index e28b5936d..9b9ee7b16 100644
--- a/modules/core/overrides/Gtk.js
+++ b/modules/core/overrides/Gtk.js
@@ -35,14 +35,17 @@ function _init() {
 
     Gtk.Widget.prototype._init = function (params) {
         let wrapper = this;
+        const klass = this.constructor;
 
-        if (wrapper.constructor[Gtk.template]) {
+        if (klass[Gtk.template]) {
             if (!BuilderScope) {
-                Gtk.Widget.set_connect_func.call(wrapper.constructor,
+                Gtk.Widget.set_connect_func.call(klass,
                     (builder, obj, signalName, handlerName, connectObj, flags) => {
+                        const objects = builder.get_objects();
+                        const thisObj = objects.find(o => o instanceof klass);
                         const swapped = flags & GObject.ConnectFlags.SWAPPED;
                         const closure = _createClosure(
-                            builder, wrapper, handlerName, swapped, connectObj);
+                            builder, thisObj, handlerName, swapped, connectObj);
 
                         if (flags & GObject.ConnectFlags.AFTER)
                             obj.connect_after(signalName, closure);
@@ -54,17 +57,17 @@ function _init() {
 
         wrapper = GObject.Object.prototype._init.call(wrapper, params) ?? wrapper;
 
-        if (wrapper.constructor[Gtk.template]) {
-            let children = wrapper.constructor[Gtk.children] || [];
+        if (klass[Gtk.template]) {
+            let children = klass[Gtk.children] ?? [];
             for (let child of children) {
                 wrapper[child.replace(/-/g, '_')] =
-                    wrapper.get_template_child(wrapper.constructor, child);
+                    wrapper.get_template_child(klass, child);
             }
 
-            let internalChildren = wrapper.constructor[Gtk.internalChildren] || [];
+            let internalChildren = klass[Gtk.internalChildren] ?? [];
             for (let child of internalChildren) {
                 wrapper[`_${child.replace(/-/g, '_')}`] =
-                    wrapper.get_template_child(wrapper.constructor, child);
+                    wrapper.get_template_child(klass, child);
             }
         }
 
-- 
GitLab

