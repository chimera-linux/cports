diff --git a/cmake/Functions.cmake b/cmake/Functions.cmake
index e1044de8f..717163085 100644
--- a/cmake/Functions.cmake
+++ b/cmake/Functions.cmake
@@ -635,6 +635,8 @@ function(get_gn_arch result arch)
         set(${result} "mips64el" PARENT_SCOPE)
     elseif(arch STREQUAL "riscv64")
         set(${result} "riscv64" PARENT_SCOPE)
+    elseif(arch STREQUAL "power64")
+        set(${result} "ppc64" PARENT_SCOPE)
     else()
         message(FATAL_ERROR "Unknown architecture: ${arch}")
     endif()
Submodule src/3rdparty da62c2f7a..5c9c17660:
diff --git a/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h b/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h
index e43615da25e..a9d63bce778 100644
--- a/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h
+++ b/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h
@@ -82,7 +82,7 @@ PageAllocationGranularity();
 
 PA_ALWAYS_INLINE PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR size_t
 PageAllocationGranularityShift() {
-#if BUILDFLAG(IS_WIN) || defined(ARCH_CPU_PPC64)
+#if BUILDFLAG(IS_WIN)
   // Modern ppc64 systems support 4kB (shift = 12) and 64kB (shift = 16) page
   // sizes.  Since 64kB is the de facto standard on the platform and binaries
   // compiled for 64kB are likely to work on 4kB systems, 64kB is a good choice
diff --git a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc.gni b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc.gni
index 1ef0d062afa..8317d43ed6a 100644
--- a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc.gni
+++ b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc.gni
@@ -16,7 +16,7 @@ if (is_nacl) {
   # NaCl targets don't use 64-bit pointers.
   has_64_bit_pointers = false
 } else if (current_cpu == "x64" || current_cpu == "arm64" ||
-           current_cpu == "loong64" || current_cpu == "riscv64") {
+           current_cpu == "loong64" || current_cpu == "riscv64" || current_cpu == "ppc64") {
   has_64_bit_pointers = true
 } else if (current_cpu == "x86" || current_cpu == "arm") {
   has_64_bit_pointers = false
diff --git a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
index c52246a5b12..8b7f2875496 100644
--- a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
+++ b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
@@ -89,11 +89,6 @@ PA_ALWAYS_INLINE PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR size_t
 PartitionPageShift() {
   return 16;  // 64 KiB
 }
-#elif defined(ARCH_CPU_PPC64)
-PA_ALWAYS_INLINE PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR size_t
-PartitionPageShift() {
-  return 18;  // 256 KiB
-}
 #elif (BUILDFLAG(IS_APPLE) && defined(ARCH_CPU_64_BITS)) || \
     (BUILDFLAG(IS_LINUX) && defined(ARCH_CPU_ARM64))
 PA_ALWAYS_INLINE PAGE_ALLOCATOR_CONSTANTS_DECLARE_CONSTEXPR size_t
diff --git a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_forward.h b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_forward.h
index aa808f28b4d..10a2be46a82 100644
--- a/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_forward.h
+++ b/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_forward.h
@@ -28,13 +28,17 @@ namespace internal {
 // the second one 16. We could technically return something different for
 // malloc() and operator new(), but this would complicate things, and most of
 // our allocations are presumably coming from operator new() anyway.
+#if defined(__powerpc64__)
+/* we want this to be 16 here always */
+constexpr size_t kAlignment = 16;
+#else
 constexpr size_t kAlignment =
     std::max(alignof(max_align_t),
              static_cast<size_t>(__STDCPP_DEFAULT_NEW_ALIGNMENT__));
 static_assert(kAlignment <= 16,
               "PartitionAlloc doesn't support a fundamental alignment larger "
               "than 16 bytes.");
-
+#endif
 struct SlotSpanMetadata;
 class PA_LOCKABLE Lock;
 
diff --git a/src/3rdparty/chromium/base/compiler_specific.h b/src/3rdparty/chromium/base/compiler_specific.h
index 57ac1bdf568..5106f207a07 100644
--- a/src/3rdparty/chromium/base/compiler_specific.h
+++ b/src/3rdparty/chromium/base/compiler_specific.h
@@ -426,7 +426,7 @@ inline constexpr bool AnalyzerAssumeTrue(bool arg) {
 // preserve_most in clang >= 17 (see https://reviews.llvm.org/D143425).
 // See https://clang.llvm.org/docs/AttributeReference.html#preserve-most for
 // more details.
-#if defined(ARCH_CPU_64_BITS) &&                       \
+#if !defined(ARCH_CPU_PPC64) && defined(ARCH_CPU_64_BITS) && \
     !(BUILDFLAG(IS_WIN) && defined(ARCH_CPU_ARM64)) && \
     !defined(COMPONENT_BUILD) && defined(__clang__) && \
     __clang_major__ >= 17 && HAS_ATTRIBUTE(preserve_most)
index 1b86a4bb9e1..bc950831013 100755
--- a/src/3rdparty/chromium/build/download_nacl_toolchains.py
+++ b/src/3rdparty/chromium/build/download_nacl_toolchains.py
@@ -12,6 +12,10 @@ import sys
 
 
 def Main(args):
+  # If `disable_nacl=1` is in GYP_DEFINES, exit
+  if 'disable_nacl=1' in os.environ.get('GYP_DEFINES', ''):
+    return 0
+
   script_dir = os.path.dirname(os.path.abspath(__file__))
   src_dir = os.path.dirname(script_dir)
   nacl_dir = os.path.join(src_dir, 'native_client')
diff --git a/src/3rdparty/chromium/sandbox/features.gni b/src/3rdparty/chromium/sandbox/features.gni
index 8434144118b..c92bf1a4bc0 100644
--- a/src/3rdparty/chromium/sandbox/features.gni
+++ b/src/3rdparty/chromium/sandbox/features.gni
@@ -9,7 +9,8 @@
 use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
-                   current_cpu == "mipsel" || current_cpu == "mips64el")
+                   current_cpu == "mipsel" || current_cpu == "mips64el" ||
+                   current_cpu == "ppc64")
 
 # SSBD (Speculative Store Bypass Disable) is a mitigation of Spectre Variant 4.
 # As Spectre Variant 4 can be mitigated by site isolation, opt-out SSBD on site
diff --git a/src/3rdparty/chromium/sandbox/linux/BUILD.gn b/src/3rdparty/chromium/sandbox/linux/BUILD.gn
index 483488a3f78..89a0fef3886 100644
--- a/src/3rdparty/chromium/sandbox/linux/BUILD.gn
+++ b/src/3rdparty/chromium/sandbox/linux/BUILD.gn
@@ -383,6 +383,8 @@ component("sandbox_services") {
 
 source_set("sandbox_services_headers") {
   sources = [
+    "system_headers/ppc64_linux_syscalls.h",
+    "system_headers/ppc64_linux_ucontext.h",
     "system_headers/arm64_linux_syscalls.h",
     "system_headers/arm_linux_syscalls.h",
     "system_headers/arm_linux_ucontext.h",
diff --git a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
index 1d0590b7dd6..986e4f61871 100644
--- a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
+++ b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
@@ -56,6 +56,13 @@
 #define MAX_PUBLIC_SYSCALL __NR_syscalls
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__powerpc64__)
+
+#include <asm-generic/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL __NR_syscalls
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff --git a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
index 87d5825aa3d..c5d507e3ab4 100644
--- a/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
+++ b/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
@@ -343,6 +343,51 @@ struct regs_struct {
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+
+#elif defined(__powerpc64__)
+#include <asm/ptrace.h>
+
+typedef struct pt_regs regs_struct;
+
+#ifdef ARCH_CPU_LITTLE_ENDIAN
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64LE
+#else
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64
+#endif
+
+#define SECCOMP_REG(_ctx, _reg) (((struct pt_regs *)(_ctx)->uc_mcontext.regs)->gpr[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 0)
+#define SECCOMP_IP(_ctx) ((struct pt_regs *)(_ctx)->uc_mcontext.regs)->nip
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 8)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).gpr[0]
+#define SECCOMP_PT_IP(_regs) (_regs).nip
+#define SECCOMP_PT_PARM1(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_PARM2(_regs) (_regs).gpr[4]
+#define SECCOMP_PT_PARM3(_regs) (_regs).gpr[5]
+#define SECCOMP_PT_PARM4(_regs) (_regs).gpr[6]
+#define SECCOMP_PT_PARM5(_regs) (_regs).gpr[7]
+#define SECCOMP_PT_PARM6(_regs) (_regs).gpr[8]
+
 #else
 #error Unsupported target platform
 
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
index 7bde501115b..ea29a6c976a 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
@@ -89,7 +89,7 @@ bool IsBaselinePolicyWatched(int sysno) {
          SyscallSets::IsNuma(sysno) ||
          SyscallSets::IsPrctl(sysno) ||
          SyscallSets::IsProcessGroupOrSession(sysno) ||
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
          SyscallSets::IsSocketCall(sysno) ||
 #endif
@@ -255,7 +255,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -276,7 +276,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
@@ -339,7 +339,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return Error(EPERM);
   }
 
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
   if (SyscallSets::IsSocketCall(sysno))
     return RestrictSocketcallCommand();
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
index dbbf1fb510b..342b7be4cc6 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
@@ -329,7 +329,7 @@ TEST_BASELINE_SIGSYS(__NR_sysinfo)
 TEST_BASELINE_SIGSYS(__NR_syslog)
 TEST_BASELINE_SIGSYS(__NR_timer_create)
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
 TEST_BASELINE_SIGSYS(__NR_inotify_init)
 TEST_BASELINE_SIGSYS(__NR_vserver)
 #endif
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
index 4bf133a4e2f..0b536581938 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
@@ -357,7 +357,16 @@ intptr_t SIGSYSFstatatHandler(const struct arch_seccomp_data& args,
   if (args.nr == __NR_fstatat_default) {
     if (*reinterpret_cast<const char*>(args.args[1]) == '\0' &&
         args.args[3] == static_cast<uint64_t>(AT_EMPTY_PATH)) {
-      return syscall(__NR_fstat_default, static_cast<int>(args.args[0]),
+          int fd = static_cast<int>(args.args[0]);
+#if defined(__powerpc64__)
+      // On ppc64+glibc, some syscalls seem to accidentally negate the first
+      // parameter which causes checks against it to fail. For now, manually
+      // negate them back.
+      // TODO: Investigate the root cause and fix in glibc
+      if (fd < 0)
+        fd = -fd;
+#endif
+      return syscall(__NR_fstat_default, fd,
                      reinterpret_cast<default_stat_struct*>(args.args[2]));
     }
     return -reinterpret_cast<intptr_t>(fs_denied_errno);
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
index ba995ace6d4..c535d7d8898 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
@@ -36,7 +36,7 @@
 #include "sandbox/linux/system_headers/linux_time.h"
 
 #if (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) && \
-    !defined(__arm__) && !defined(__aarch64__) &&             \
+    !defined(__arm__) && !defined(__aarch64__) && !defined(__powerpc64__) && \
     !defined(PTRACE_GET_THREAD_AREA)
 // Also include asm/ptrace-abi.h since ptrace.h in older libc (for instance
 // the one in Ubuntu 16.04 LTS) is missing PTRACE_GET_THREAD_AREA.
@@ -45,6 +45,11 @@
 #include <asm/ptrace-abi.h>
 #endif
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 
 #if !defined(F_DUPFD_CLOEXEC)
@@ -102,6 +107,14 @@ inline bool IsArchitectureMips() {
 #endif
 }
 
+inline bool IsArchitecturePPC64() {
+#if defined(__powerpc64__)
+  return true;
+#else
+  return false;
+#endif
+}
+
 // Ubuntu's version of glibc has a race condition in sem_post that can cause
 // it to call futex(2) with bogus op arguments. To workaround this, we need
 // to allow those futex(2) calls to fail with EINVAL, instead of crashing the
@@ -271,6 +284,8 @@ ResultExpr RestrictFcntlCommands() {
   uint64_t kOLargeFileFlag = O_LARGEFILE;
   if (IsArchitectureX86_64() || IsArchitectureI386() || IsArchitectureMips())
     kOLargeFileFlag = 0100000;
+  else if (IsArchitecturePPC64())
+    kOLargeFileFlag = 0200000;
 
   const Arg<int> cmd(1);
   const Arg<long> long_arg(2);
@@ -294,7 +309,16 @@ ResultExpr RestrictFcntlCommands() {
               F_SETLKW,
               F_GETLK,
               F_DUPFD,
-              F_DUPFD_CLOEXEC},
+              F_DUPFD_CLOEXEC
+#if defined(__powerpc64__)
+// On PPC64, F_SETLK, F_GETLK, F_SETLKW are defined as the 64-bit variants
+// but glibc will sometimes still use the 32-bit versions. Allow both.
+              ,
+              5, /* F_GETLK (32) */
+              6, /* F_SETLK (32) */
+              7  /* F_SETLKW (32) */
+#endif
+             },
              Allow())
       .Case(F_SETFL,
             If((long_arg & ~kAllowedMask) == 0, Allow()).Else(CrashSIGSYS()))
@@ -304,7 +328,7 @@ ResultExpr RestrictFcntlCommands() {
   // clang-format on
 }
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 ResultExpr RestrictSocketcallCommand() {
   // Unfortunately, we are unable to restrict the first parameter to
   // socketpair(2). Whilst initially sounding bad, it's noteworthy that very
@@ -459,7 +483,7 @@ ResultExpr RestrictPtrace() {
 #endif
   return Switch(request)
       .Cases({
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
                  PTRACE_GETREGS, PTRACE_GETFPREGS, PTRACE_GET_THREAD_AREA,
                  PTRACE_GETREGSET,
 #endif
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
index 171191ec518..a36cd8d8cbd 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
@@ -52,7 +52,7 @@ SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictMprotectFlags();
 // O_NONBLOCK | O_SYNC | O_LARGEFILE | O_CLOEXEC | O_NOATIME.
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictFcntlCommands();
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 // Restrict socketcall(2) to only allow socketpair(2), send(2), recv(2),
 // sendto(2), recvfrom(2), shutdown(2), sendmsg(2) and recvmsg(2).
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictSocketcallCommand();
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
index 27ea264070d..29b04e259ff 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
@@ -28,7 +28,7 @@ bool SyscallSets::IsKill(int sysno) {
 bool SyscallSets::IsAllowedGettime(int sysno) {
   switch (sysno) {
     case __NR_gettimeofday:
-#if defined(__i386__) || defined(__x86_64__) || \
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_time:
 #endif
@@ -51,12 +51,12 @@ bool SyscallSets::IsAllowedGettime(int sysno) {
                                     // filtered by RestrictClockID().
     case __NR_clock_nanosleep_time64:  // Parameters filtered by RestrictClockID().
 #endif
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_ftime:  // Obsolete.
 #endif
     case __NR_settimeofday:  // Privileged.
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_stime:
 #endif
@@ -136,7 +136,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_faccessat2:
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -155,7 +155,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_memfd_create:
     case __NR_mkdirat:
     case __NR_mknodat:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldlstat:
     case __NR_oldstat:
 #endif
@@ -168,7 +168,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_stat64:
 #endif
     case __NR_statfs:  // EPERM not a valid errno.
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_statfs64:
 #endif
@@ -180,7 +180,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_truncate64:
 #endif
     case __NR_unlinkat:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_utime:
 #endif
     case __NR_utimensat:  // New.
@@ -220,7 +220,7 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
 #endif
       return true;
 // TODO(jln): these should be denied gracefully as well (moved below).
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_fadvise64:  // EPERM not a valid errno.
 #endif
 #if defined(__i386__)
@@ -232,12 +232,12 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
     case __NR_fdatasync:  // EPERM not a valid errno.
     case __NR_flock:      // EPERM not a valid errno.
     case __NR_fstatfs:    // Give information about the whole filesystem.
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_fstatfs64:
 #endif
     case __NR_fsync:  // EPERM not a valid errno.
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
@@ -245,6 +245,8 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
+#elif defined(__powerpc64__)
+    case __NR_sync_file_range2: // EPERM not a valid errno.
 #endif
     default:
       return false;
@@ -264,7 +266,7 @@ bool SyscallSets::IsDeniedFileSystemAccessViaFd(int sysno) {
     case __NR_getdents:    // EPERM not a valid errno.
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_readdir:
 #endif
@@ -306,7 +308,7 @@ bool SyscallSets::IsGetSimpleId(int sysno) {
 bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
   switch (sysno) {
     case __NR_capset:
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_ioperm:  // Intel privilege.
     case __NR_iopl:    // Intel privilege.
 #endif
@@ -361,9 +363,11 @@ bool SyscallSets::IsAllowedSignalHandling(int sysno) {
     // whose stack pointers no longer point to their main stack, e.g. stack
     // overflow.
     case __NR_sigaltstack:
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+#ifndef __powerpc64__
     case __NR_rt_sigtimedwait_time64:
+#endif
     case __NR_sigaction:
     case __NR_sigprocmask:
     case __NR_sigreturn:
@@ -377,7 +381,7 @@ bool SyscallSets::IsAllowedSignalHandling(int sysno) {
     case __NR_signalfd:
 #endif
     case __NR_signalfd4:
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_sigpending:
     case __NR_sigsuspend:
@@ -402,7 +406,7 @@ bool SyscallSets::IsAllowedOperationOnFd(int sysno) {
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_shutdown:
 #endif
       return true;
@@ -435,7 +439,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
     case __NR_exit_group:
     case __NR_wait4:
     case __NR_waitid:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_waitpid:
 #endif
       return true;
@@ -499,7 +503,7 @@ bool SyscallSets::IsAllowedEpoll(int sysno) {
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -513,7 +517,7 @@ bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   }
 }
 
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
 // Big multiplexing system call for sockets.
 bool SyscallSets::IsSocketCall(int sysno) {
@@ -528,7 +532,7 @@ bool SyscallSets::IsSocketCall(int sysno) {
 }
 #endif
 
-#if defined(__x86_64__) || defined(__arm__) || defined(__mips__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || defined(__powerpc64__)
 bool SyscallSets::IsNetworkSocketInformation(int sysno) {
   switch (sysno) {
     case __NR_getpeername:
@@ -553,7 +557,7 @@ bool SyscallSets::IsAllowedAddressSpaceAccess(int sysno) {
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || \
@@ -582,7 +586,7 @@ bool SyscallSets::IsAllowedAddressSpaceAccess(int sysno) {
 bool SyscallSets::IsAllowedGeneralIo(int sysno) {
   switch (sysno) {
     case __NR_lseek:
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR__llseek:
 #endif
@@ -602,27 +606,27 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_read:
     case __NR_readv:
     case __NR_pread64:
-#if defined(__arm__) || \
+#if defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_select:
 #endif
-#if defined(__i386__) || defined(__arm__) || defined(__mips__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips__) || defined(__powerpc64__)
     case __NR__newselect:
 #endif
-#if defined(__arm__) || \
+#if defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -677,7 +681,7 @@ bool SyscallSets::IsAllowedBasicScheduler(int sysno) {
     case __NR_nanosleep:
       return true;
     case __NR_getpriority:
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_nice:
 #endif
@@ -689,7 +693,7 @@ bool SyscallSets::IsAllowedBasicScheduler(int sysno) {
 
 bool SyscallSets::IsAdminOperation(int sysno) {
   switch (sysno) {
-#if defined(__i386__) || defined(__arm__) || \
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_bdflush:
 #endif
@@ -706,7 +710,7 @@ bool SyscallSets::IsAdminOperation(int sysno) {
 
 bool SyscallSets::IsKernelModule(int sysno) {
   switch (sysno) {
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_create_module:
     case __NR_get_kernel_syms:  // Should ENOSYS.
     case __NR_query_module:
@@ -738,7 +742,7 @@ bool SyscallSets::IsFsControl(int sysno) {
     case __NR_quotactl:
     case __NR_swapoff:
     case __NR_swapon:
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_umount:
 #endif
@@ -755,7 +759,7 @@ bool SyscallSets::IsNuma(int sysno) {
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -790,13 +794,13 @@ bool SyscallSets::IsGlobalProcessEnvironment(int sysno) {
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_getrlimit:
 #endif
-#if defined(__i386__) || defined(__arm__)
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__)
     case __NR_ugetrlimit:
 #endif
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_ulimit:
 #endif
@@ -831,7 +835,7 @@ bool SyscallSets::IsGlobalSystemStatus(int sysno) {
 #endif
     case __NR_sysinfo:
     case __NR_uname:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_olduname:
     case __NR_oldolduname:
 #endif
@@ -913,8 +917,15 @@ bool SyscallSets::IsSystemVSemaphores(int sysno) {
 }
 #endif
 
+#if defined(__powerpc64__) && !defined(__NR_shmget)
+#define __NR_shmget 395
+#define __NR_shmctl 396
+#define __NR_shmat 397
+#define __NR_shmdt 398
+#endif
+
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__) ||                                         \
+    defined(__aarch64__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
 // These give a lot of ambient authority and bypass the setuid sandbox.
 bool SyscallSets::IsSystemVSharedMemory(int sysno) {
@@ -945,7 +956,7 @@ bool SyscallSets::IsSystemVMessageQueue(int sysno) {
 }
 #endif
 
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
 // Big system V multiplexing system call.
 bool SyscallSets::IsSystemVIpc(int sysno) {
@@ -965,7 +976,7 @@ bool SyscallSets::IsAnySystemV(int sysno) {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
-#elif defined(__i386__) || \
+#elif defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
   return IsSystemVIpc(sysno);
 #endif
@@ -1023,7 +1034,7 @@ bool SyscallSets::IsFaNotify(int sysno) {
 bool SyscallSets::IsTimer(int sysno) {
   switch (sysno) {
     case __NR_getitimer:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_alarm:
 #endif
     case __NR_setitimer:
@@ -1105,17 +1116,17 @@ bool SyscallSets::IsMisc(int sysno) {
     case __NR_syncfs:
     case __NR_vhangup:
 // The system calls below are not implemented.
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_afs_syscall:
 #endif
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_break:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_getpmsg:
 #endif
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_gtty:
     case __NR_idle:
@@ -1124,20 +1135,20 @@ bool SyscallSets::IsMisc(int sysno) {
     case __NR_prof:
     case __NR_profil:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_putpmsg:
 #endif
 #if defined(__x86_64__)
     case __NR_security:
 #endif
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_stty:
 #endif
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
     case __NR_vserver:
 #endif
       return true;
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
index 9be7b03ec43..35f6f157e9d 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
@@ -46,13 +46,14 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsDeniedGetOrModifySocket(int sysno);
 
 #if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__powerpc64__)
   // Big multiplexing system call for sockets.
   static bool IsSocketCall(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -83,7 +84,7 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsSystemVSemaphores(int sysno);
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__) ||                                         \
+    defined(__aarch64__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
   // These give a lot of ambient authority and bypass the setuid sandbox.
   static bool IsSystemVSharedMemory(int sysno);
@@ -94,7 +95,7 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsSystemVMessageQueue(int sysno);
 #endif
 
-#if defined(__i386__) || \
+#if defined(__i386__) || defined(__powerpc64__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc
index 02cbb047c15..04deabf6300 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc
@@ -18,7 +18,7 @@ namespace sandbox {
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_PPC64_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -306,12 +306,56 @@ asm(// We need to be able to tell the kernel exactly where we made a
     // Enter the kernel
     "svc 0\n"
     "2:ret\n"
+    ".cfi_endproc\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__powerpc64__)
+    ".text\n"
+    ".align 4\n"
+    ".type SyscallAsm @function\n"
+    "SyscallAsm:\n"
+    ".cfi_startproc\n"
+
+    // Check if r3 is negative
+    "cmpdi 3, 0\n"
+    "bgt 2f\n"
+
+    // Load address of 3f into r3 and return
+    "mflr 10\n"
+    "bl 1f\n"
+    "1: mflr 3\n"
+    "mtlr 10\n"
+    "addi 3, 3, 4*13\n"
+    "blr\n"
+
+    // Load arguments from array into r3-8
+    // save param 3 in r10
+    "2:\n"
+    "mr 0, 3\n"
+    "ld 3, 0(4)\n"
+    "ld 5, 16(4)\n"
+    "ld 6, 24(4)\n"
+    "ld 7, 32(4)\n"
+    "ld 8, 40(4)\n"
+    "ld 4, 8(4)\n"
+    "li 9, 0\n"
+
+    // Enter kernel
+    "sc\n"
+
+    // Magic return address
+    "3:\n"
+   // Like MIPS, ppc64 return values are always positive.
+    // Check for error in cr0.SO and negate upon error
+    "bc 4, 3, 4f\n"
+    "neg 3, 3\n"
+    "4: blr\n"
+
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
 extern "C" {
 intptr_t SyscallAsm(intptr_t nr, const intptr_t args[6]);
 }
@@ -425,6 +469,8 @@ intptr_t Syscall::Call(int nr,
     ret = inout;
   }
 
+#elif defined(__powerpc64__)
+  intptr_t ret = SyscallAsm(nr, args);
 #else
 #error "Unimplemented architecture"
 #endif
@@ -441,8 +487,18 @@ void Syscall::PutValueInUcontext(intptr_t ret_val, ucontext_t* ctx) {
     // needs to be changed back.
     ret_val = -ret_val;
     SECCOMP_PARM4(ctx) = 1;
-  } else
+  } else {
     SECCOMP_PARM4(ctx) = 0;
+  }
+#endif
+#if defined(__powerpc64__)
+  // Same as MIPS, need to invert ret and set error register (cr0.SO)
+  if (ret_val <= -1 && ret_val >= -4095) {
+    ret_val = -ret_val;
+    ((struct pt_regs *)ctx->uc_mcontext.regs)->ccr |= (1 << 28);
+  } else {
+    ((struct pt_regs *)ctx->uc_mcontext.regs)->ccr &= ~(1 << 28);
+  }
 #endif
   SECCOMP_RESULT(ctx) = static_cast<greg_t>(ret_val);
 }
diff --git a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
index 7f262aaff65..02142a81053 100644
--- a/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
+++ b/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
@@ -232,6 +232,20 @@ void Trap::SigSys(int nr, LinuxSigInfo* info, ucontext_t* ctx) {
       SetIsInSigHandler();
     }
 
+#if defined(__powerpc64__)
+    // On ppc64+glibc, some syscalls seem to accidentally negate the first
+    // parameter which causes checks against it to fail. For now, manually
+    // negate them back.
+    // TODO(shawn@anastas.io): investigate this issue further
+    auto nr = SECCOMP_SYSCALL(ctx);
+    if (nr == __NR_openat || nr == __NR_mkdirat || nr == __NR_faccessat || nr == __NR_readlinkat ||
+        nr == __NR_renameat || nr == __NR_renameat2 || nr == __NR_newfstatat || nr == __NR_unlinkat) {
+        if (static_cast<int>(SECCOMP_PARM1(ctx)) > 0) {
+            SECCOMP_PARM1(ctx) = -SECCOMP_PARM1(ctx);
+        }
+    }
+#endif
+
     // Copy the seccomp-specific data into a arch_seccomp_data structure. This
     // is what we are showing to TrapFnc callbacks that the system call
     // evaluator registered with the sandbox.
diff --git a/src/3rdparty/chromium/sandbox/linux/services/credentials.cc b/src/3rdparty/chromium/sandbox/linux/services/credentials.cc
index e284c59d239..803286d0446 100644
--- a/src/3rdparty/chromium/sandbox/linux/services/credentials.cc
+++ b/src/3rdparty/chromium/sandbox/linux/services/credentials.cc
@@ -80,7 +80,7 @@ bool ChrootToSafeEmptyDir() {
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
@@ -89,7 +89,8 @@ bool ChrootToSafeEmptyDir() {
 
   int clone_flags = CLONE_FS | LINUX_SIGCHLD;
   void* tls = nullptr;
-#if (defined(ARCH_CPU_X86_64) || defined(ARCH_CPU_ARM_FAMILY)) && \
+#if 0 && (defined(ARCH_CPU_X86_64) || defined(ARCH_CPU_PPC64_FAMILY) || \
+     defined(ARCH_CPU_ARM_FAMILY)) &&                            \
     !defined(MEMORY_SANITIZER)
   // Use CLONE_VM | CLONE_VFORK as an optimization to avoid copying page tables.
   // Since clone writes to the new child's TLS before returning, we must set a
@@ -97,6 +98,11 @@ bool ChrootToSafeEmptyDir() {
   // glibc performs syscalls by calling a function pointer in TLS, so we do not
   // attempt this optimization.
   // TODO(crbug.com/1247458) Broken in MSan builds after LLVM f1bb30a4956f.
+  //
+  // NOTE: Without CLONE_VM, fontconfig will attempt to reload configuration
+  // in every thread.  Since the rendered threads are sandboxed without
+  // filesystem access (e.g. to /etc/fonts/fonts.conf) this will cause font
+  // configuraiton loading failures and no fonts will be displayed!
   clone_flags |= CLONE_VM | CLONE_VFORK | CLONE_SETTLS;
 
   // PTHREAD_STACK_MIN can be dynamic in glibc2.34+, so it is not possible to
diff --git a/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc b/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc
index 7650e983b38..de71401f852 100644
--- a/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc
+++ b/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc
@@ -61,7 +61,7 @@ long sys_clone(unsigned long flags,
 #if defined(ARCH_CPU_X86_64)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
diff --git a/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc b/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc
index a55b548a8ec..6b333222d6b 100644
--- a/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc
+++ b/src/3rdparty/chromium/sandbox/linux/syscall_broker/broker_process.cc
@@ -169,7 +169,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
 #if defined(__NR_fstatat64)
     case __NR_fstatat64:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:
 #endif
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
diff --git a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h
index 8690a96eb01..eb366ae7e61 100644
--- a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h
+++ b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h
@@ -39,6 +39,10 @@
 #define EM_AARCH64 183
 #endif
 
+#ifndef EM_PPC64
+#define EM_PPC64 21
+#endif
+
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
 #endif
@@ -71,6 +75,14 @@
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
 
+#ifndef AUDIT_ARCH_PPC64
+#define AUDIT_ARCH_PPC64 (EM_PPC64 | __AUDIT_ARCH_64BIT)
+#endif
+
+#ifndef AUDIT_ARCH_PPC64LE
+#define AUDIT_ARCH_PPC64LE (EM_PPC64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
+
 // For prctl.h
 #ifndef PR_SET_SECCOMP
 #define PR_SET_SECCOMP               22
diff --git a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h
index 69ccaf10815..25340e6ced6 100644
--- a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h
+++ b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h
@@ -13,7 +13,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
diff --git a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h
index 3aae8cbced7..6a78036c00a 100644
--- a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h
+++ b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_stat.h
@@ -173,6 +173,28 @@ struct kernel_stat {
   unsigned int __unused4;
   unsigned int __unused5;
 };
+#elif defined(__powerpc64__)
+struct kernel_stat {
+  unsigned long	st_dev;
+  unsigned long	st_ino;
+  unsigned long	st_nlink;
+  unsigned int	st_mode;
+  unsigned int	st_uid;
+  unsigned int	st_gid;
+  unsigned long	st_rdev;
+  long		st_size;
+  unsigned long	st_blksize;
+  unsigned long	st_blocks;
+  unsigned long	st_atime_;
+  unsigned long	st_atime_nsec_;
+  unsigned long	st_mtime_;
+  unsigned long	st_mtime_nsec_;
+  unsigned long	st_ctime_;
+  unsigned long	st_ctime_nsec_;
+  unsigned long	__unused4;
+  unsigned long	__unused5;
+  unsigned long	__unused6;
+};
 #endif
 
 #if !defined(AT_EMPTY_PATH)
diff --git a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h
index 438147b4018..a68d007da53 100644
--- a/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h
+++ b/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h
@@ -35,5 +35,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff --git a/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h b/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h
new file mode 100644
index 00000000000..ccacffe22ea
--- /dev/null
+++ b/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+
+#include <asm/unistd.h>
+
+//TODO: is it necessary to redefine syscall numbers for PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
diff --git a/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc b/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc
index 7de8e76b74f..4397ff4aa1b 100644
--- a/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc
+++ b/src/3rdparty/chromium/sandbox/policy/linux/bpf_renderer_policy_linux.cc
@@ -15,6 +15,11 @@
 #include "sandbox/linux/system_headers/linux_syscalls.h"
 #include "sandbox/policy/linux/sandbox_linux.h"
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 // TODO(vignatti): replace the local definitions below with #include
 // <linux/dma-buf.h> once kernel version 4.6 becomes widely used.
 #include <linux/types.h>
@@ -71,7 +76,7 @@ ResultExpr RendererProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_ftruncate64:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_getrlimit:
     case __NR_setrlimit:
 // We allow setrlimit to dynamically adjust the address space limit as
diff --git a/src/3rdparty/chromium/sandbox/policy/linux/bpf_utility_policy_linux.cc b/src/3rdparty/chromium/sandbox/policy/linux/bpf_utility_policy_linux.cc
index e299ce998b9..090f3e706f5 100644
--- a/src/3rdparty/chromium/sandbox/policy/linux/bpf_utility_policy_linux.cc
+++ b/src/3rdparty/chromium/sandbox/policy/linux/bpf_utility_policy_linux.cc
@@ -34,7 +34,7 @@ ResultExpr UtilityProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_fdatasync:
     case __NR_fsync:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_getrlimit:
 #endif
 #if defined(__i386__) || defined(__arm__)
diff --git a/src/3rdparty/chromium/third_party/abseil-cpp/absl/base/internal/unscaledcycleclock_config.h b/src/3rdparty/chromium/third_party/abseil-cpp/absl/base/internal/unscaledcycleclock_config.h
index 24b324ac99f..33715130d44 100644
--- a/src/3rdparty/chromium/third_party/abseil-cpp/absl/base/internal/unscaledcycleclock_config.h
+++ b/src/3rdparty/chromium/third_party/abseil-cpp/absl/base/internal/unscaledcycleclock_config.h
@@ -21,7 +21,7 @@
 
 // The following platforms have an implementation of a hardware counter.
 #if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__) || \
-    defined(__powerpc__) || defined(__ppc__) || defined(__riscv) ||     \
+    ((defined(__powerpc__) || defined(__ppc__)) && defined(__GLIBC__)) || defined(__riscv) ||     \
     defined(_M_IX86) || (defined(_M_X64) && !defined(_M_ARM64EC))
 #define ABSL_HAVE_UNSCALED_CYCLECLOCK_IMPLEMENTATION 1
 #else
diff --git a/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h b/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h
index 3929b1b7349..23d5e504f8a 100644
--- a/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h
+++ b/src/3rdparty/chromium/third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h
@@ -60,7 +60,7 @@
 #elif defined(__i386__) || defined(__x86_64__)
 #define ABSL_STACKTRACE_INL_HEADER \
   "absl/debugging/internal/stacktrace_x86-inl.inc"
-#elif defined(__ppc__) || defined(__PPC__)
+#elif (defined(__ppc__) || defined(__PPC__)) && defined(__GLIBC__)
 #define ABSL_STACKTRACE_INL_HEADER \
   "absl/debugging/internal/stacktrace_powerpc-inl.inc"
 #elif defined(__aarch64__)
diff --git a/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h b/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h
index bf6df8800c1..d8360ef5aa8 100644
--- a/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h
+++ b/src/3rdparty/chromium/third_party/angle/src/compiler/translator/InfoSink.h
@@ -93,7 +93,16 @@ class TInfoSinkBase
             stream.precision(8);
             stream << f;
         }
-        sink.append(stream.str());
+
+        // Hack to work around a bug where negative floating point values
+        // are rendered like '.0.5' instead of '-0.5'
+        std::string res(stream.str());
+
+        if (signbit(f)) { // test if f is negative
+            res[0] = '-';
+        }
+
+        sink.append(res);
         return *this;
     }
     // Write boolean values as their names instead of integral value.
diff --git a/src/3rdparty/chromium/third_party/boringssl/BUILD.gn b/src/3rdparty/chromium/third_party/boringssl/BUILD.gn
index c4e79254477..7f858a65870 100644
--- a/src/3rdparty/chromium/third_party/boringssl/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/boringssl/BUILD.gn
@@ -114,6 +114,11 @@ if (is_msan) {
     sources = crypto_sources_nasm
     visibility = [ ":*" ]  # Only targets in this file can depend on this.
   }
+} else if (current_cpu == "ppc64") {
+  source_set("boringssl_asm") {
+    visibility = [ ":*" ]  # Only targets in this file can depend on this.
+    public_configs = [ ":no_asm_config" ]
+  }
 } else {
   # All other targets use GAS-compatible assembler. BoringSSL's assembly files
   # are all wrapped in processor checks for the corresponding target, so there
diff --git a/src/3rdparty/chromium/third_party/boringssl/src/include/openssl/target.h b/src/3rdparty/chromium/third_party/boringssl/src/include/openssl/target.h
index 12736416f36..432876bcfdd 100644
--- a/src/3rdparty/chromium/third_party/boringssl/src/include/openssl/target.h
+++ b/src/3rdparty/chromium/third_party/boringssl/src/include/openssl/target.h
@@ -54,6 +54,9 @@
 #define OPENSSL_32_BIT
 #elif defined(__myriad2__)
 #define OPENSSL_32_BIT
+#elif defined(__powerpc64__)
+#define OPENSSL_64_BIT
+#define OPENSSL_PPC64
 #else
 // Note BoringSSL only supports standard 32-bit and 64-bit two's-complement,
 // little-endian architectures. Functions will not produce the correct answer
diff --git a/src/3rdparty/chromium/third_party/breakpad/BUILD.gn b/src/3rdparty/chromium/third_party/breakpad/BUILD.gn
index 779c83da0a2..640931b6974 100644
--- a/src/3rdparty/chromium/third_party/breakpad/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/breakpad/BUILD.gn
@@ -615,7 +615,6 @@ if (is_linux || is_chromeos || is_android) {
       "breakpad/src/client/minidump_file_writer.h",
       "breakpad/src/common/convert_UTF.cc",
       "breakpad/src/common/convert_UTF.h",
-      "breakpad/src/common/linux/breakpad_getcontext.S",
       "breakpad/src/common/linux/elf_core_dump.cc",
       "breakpad/src/common/linux/elf_core_dump.h",
       "breakpad/src/common/linux/elfutils.cc",
@@ -655,6 +654,15 @@ if (is_linux || is_chromeos || is_android) {
 
     libs = [ "dl" ]
 
+    if (current_cpu == "ppc64") {
+        defines = [ "HAVE_GETCONTEXT" ]
+        libs += [ "ucontext" ]
+    } else {
+        sources += [
+            "breakpad/src/common/linux/breakpad_getcontext.S"
+        ]
+    }
+
     include_dirs = [
       ".",
       "breakpad/src",
@@ -704,7 +712,6 @@ if (is_linux || is_chromeos || is_android) {
       "breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc",
       "breakpad/src/client/linux/minidump_writer/minidump_writer_unittest_utils.cc",
       "breakpad/src/client/linux/minidump_writer/proc_cpuinfo_reader_unittest.cc",
-      "breakpad/src/common/linux/breakpad_getcontext_unittest.cc",
       "breakpad/src/common/linux/elf_core_dump_unittest.cc",
       "breakpad/src/common/linux/file_id_unittest.cc",
       "breakpad/src/common/linux/linux_libc_support_unittest.cc",
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
index ea4b6f6a295..37bbb909411 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
@@ -51,6 +51,8 @@ typedef MDRawContextRISCV64 RawContextCPU;
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__powerpc64__)
+typedef MDRawContextPPC64 RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
index 6288a056e09..de4f24e2821 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
@@ -336,7 +336,45 @@ void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
 #error "Unexpected __riscv_xlen"
 #endif
 }
-#endif  // __riscv
+
+#elif defined(__powerpc64__)
+
+#include <asm/elf.h>
+#include <asm/ptrace.h>
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+    return mcontext.gp_regs[PT_NIP];
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = mcontext.gp_regs[i];
+
+    out->lr = mcontext.gp_regs[PT_LNK];
+    out->srr0 = mcontext.gp_regs[PT_NIP];
+    out->srr1 = mcontext.gp_regs[PT_MSR];
+    out->cr = mcontext.gp_regs[PT_CCR];
+    out->xer = mcontext.gp_regs[PT_XER];
+    out->ctr = mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = ((uint64_t *)&mcontext.fp_regs)[i];
+
+    out->float_save.fpscr = ((uint64_t *)&mcontext.fp_regs)[ELF_NFPREG-1];
+
+    for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] = \
+            {(((uint64_t)vregs.vrregs[i][0]) << 32) 
+                          | vregs.vrregs[i][1], 
+            (((uint64_t)vregs.vrregs[i][2]) << 32)
+                         | vregs.vrregs[i][3]};
+
+    out->vrsave = vregs.vrsave;
+    out->vector_save.save_vscr = {0, vregs.vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+#endif  // __powerpc64__
 
 void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
   assert(gp_regs || size);
@@ -350,6 +388,11 @@ void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
     *gp_regs = mcontext.__gregs;
   if (size)
     *size = sizeof(mcontext.__gregs);
+#elif defined(__powerpc64__)
+  if (gp_regs)
+    *gp_regs = mcontext.gp_regs;
+  if (size)
+    *size = sizeof(mcontext.gp_regs);
 #else
   if (gp_regs)
     *gp_regs = &regs;
@@ -384,6 +427,11 @@ void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
 # else
 #  error "Unexpected __riscv_flen"
 # endif
+#elif defined(__powerpc64__)
+  if (fp_regs)
+    *fp_regs = &mcontext.fp_regs;
+  if (size)
+    *size = sizeof(mcontext.fp_regs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
@@ -392,4 +440,13 @@ void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
 #endif
 }
 
+#if defined(__powerpc64__)
+void ThreadInfo::GetVectorRegisters(void** v_regs, size_t* size) {
+    if (v_regs)
+        *v_regs = &vregs;
+    if (size)
+        *size = sizeof(vregs);
+}
+#endif
+
 }  // namespace google_breakpad
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
index af786bcc968..604925b23ae 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
@@ -70,6 +70,10 @@ struct ThreadInfo {
 #elif defined(__mips__) || defined(__riscv)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
+#elif defined(__powerpc64__)
+  // Use the structures defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
+  vrregset_t vregs;
 #endif
 
   // Returns the instruction pointer (platform-dependent impl.).
@@ -83,6 +87,11 @@ struct ThreadInfo {
 
   // Returns the pointer and size of float point register area.
   void GetFloatingPointRegisters(void** fp_regs, size_t* size);
+
+#if defined(__powerpc64__)
+  // Returns the pointer and size of the vector register area. (PPC64 only)
+  void GetVectorRegisters(void** v_regs, size_t* size);
+#endif
 };
 
 }  // namespace google_breakpad
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
index 76497683555..a0390ef220c 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
@@ -324,6 +324,51 @@ void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
 #error "Unexpected __riscv_xlen"
 #endif
 }
+
+#elif defined(__powerpc64__)
+
+#include <asm/elf.h>
+#include <asm/ptrace.h>
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[PT_NIP];
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const vrregset_t* vregs) {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = uc->uc_mcontext.gp_regs[i];
+
+    out->lr = uc->uc_mcontext.gp_regs[PT_LNK];    
+    out->srr0 = uc->uc_mcontext.gp_regs[PT_NIP];
+    out->srr1 = uc->uc_mcontext.gp_regs[PT_MSR];
+    out->cr = uc->uc_mcontext.gp_regs[PT_CCR];
+   out->xer = uc->uc_mcontext.gp_regs[PT_XER];
+    out->ctr = uc->uc_mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = ((uint64_t *)&uc->uc_mcontext.fp_regs)[i];
+
+    out->float_save.fpscr = ((uint64_t *)&uc->uc_mcontext.fp_regs)[ELF_NFPREG-1];
+
+   for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] =
+            {(((uint64_t)vregs->vrregs[i][0]) << 32) 
+                         | vregs->vrregs[i][1], 
+             (((uint64_t)vregs->vrregs[i][2]) << 32)
+                         | vregs->vrregs[i][3]};
+
+    out->vrsave = vregs->vrsave;
+    out->vector_save.save_vscr = {0, vregs->vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+
 #endif
 
 }  // namespace google_breakpad
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
index 60cbf90047b..f7e97d2bf0e 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
@@ -54,6 +54,9 @@ struct UContextReader {
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(__powerpc64__)
+  static void FillCPUContext(RawContextCPU *out, const ucontext_t *uc,
+                             const vrregset_t* vregs);
 #else
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc);
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
index 9e23c1194e2..300dbf82983 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
@@ -108,6 +108,11 @@
 #define PR_SET_PTRACER 0x59616d61
 #endif
 
+/* musl hack, can't include asm/ptrace.h as that causes conflicts */
+#if defined(__powerpc64__) && !defined(PT_NIP)
+#define PT_NIP 32
+#endif
+
 namespace google_breakpad {
 
 namespace {
@@ -464,6 +469,13 @@ bool ExceptionHandler::HandleSignal(int /*sig*/, siginfo_t* info, void* uc) {
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
+#elif defined(__powerpc64__)
+  // On PPC64, we must copy VR state
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  if (uc_ptr->uc_mcontext.v_regs) {
+    memcpy(&g_crash_context_.vector_state, uc_ptr->uc_mcontext.v_regs,
+           sizeof(g_crash_context_.vector_state));
+  }
 #elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
   ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
@@ -701,10 +713,17 @@ bool ExceptionHandler::WriteMinidump() {
   }
 #endif
 
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__)
+#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__) && !defined(__powerpc64__)
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
 #endif
+
+#if defined(__powerpc64__)
+  // Vector registers must be copied on PPC64
+  memcpy(&context.vector_state, context.context.uc_mcontext.v_regs,
+         sizeof(context.vector_state));
+#endif
+
   context.tid = sys_gettid();
 
   // Add an exception stream to the minidump for better reporting.
@@ -728,6 +747,9 @@ bool ExceptionHandler::WriteMinidump() {
 #elif defined(__riscv)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.__gregs[REG_PC]);
+#elif defined(__powerpc64__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.gp_regs[PT_NIP]);
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
index f8bc1ead79a..a640ba5f986 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
@@ -200,7 +200,11 @@ class ExceptionHandler {
     siginfo_t siginfo;
     pid_t tid;  // the crashing thread.
     ucontext_t context;
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+    // PPC64's FP state is a part of ucontext_t like MIPS but the vector
+    // state is not, so a struct is needed.
+    vstate_t vector_state;
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
     fpstate_t float_state;
 #endif
   };
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
index b2d8d46811d..40b5ce297ee 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
@@ -321,7 +321,7 @@ TEST(ExceptionHandlerTest, ParallelChildCrashesDontHang) {
       ASSERT_EQ(SIGSEGV, WTERMSIG(status));
       return;
     } else {
-      usleep(100000);
+      usleep(200000);
     }
   }
 
@@ -576,6 +576,8 @@ const unsigned char kIllegalInstruction[] = {
 #if defined(__mips__)
   // mfc2 zero,Impl - usually illegal in userspace.
   0x48, 0x00, 0x00, 0x48
+#elif defined(__powerpc64__)
+  0x01, 0x01, 0x01, 0x01 // Crashes on a tested POWER9 cpu
 #else
   // This crashes with SIGILL on x86/x86-64/arm.
   0xff, 0xff, 0xff, 0xff
@@ -771,10 +773,10 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryMaxBound) {
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  // Use 4k here because the OS will hand out a single page even
+  // Use the page size here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = getpagesize();  // bytes
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
index 93dae35e5c1..1e3f08aefe0 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
@@ -141,7 +141,9 @@ class MicrodumpWriter {
                   const MicrodumpExtraInfo& microdump_extra_info,
                   LinuxDumper* dumper)
       : ucontext_(context ? &context->context : NULL),
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -348,6 +350,8 @@ class MicrodumpWriter {
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__powerpc64__)
+    const char kArch[] = "ppc64";
 #else
 # error "This code has not been ported to your platform yet"
 #endif
@@ -420,7 +424,9 @@ class MicrodumpWriter {
   void DumpCPUState() {
     RawContextCPU cpu;
     my_memset(&cpu, 0, sizeof(RawContextCPU));
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+    UContextReader::FillCPUContext(&cpu, ucontext_, vector_state_);
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
     UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
 #else
     UContextReader::FillCPUContext(&cpu, ucontext_);
@@ -616,7 +622,9 @@ class MicrodumpWriter {
   void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
 
   const ucontext_t* const ucontext_;
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
   const google_breakpad::fpstate_t* const float_state_;
 #endif
   LinuxDumper* dumper_;
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
index b1d570eb4de..328429e2ca1 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
@@ -282,10 +282,19 @@ TEST(MicrodumpWriterTest, BasicWithMappings) {
   CrashAndGetMicrodump(mappings, MicrodumpExtraInfo(), &buf);
   ASSERT_TRUE(ContainsMicrodump(buf));
 
+  int page_size = getpagesize();
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  // This test is only available for the following page sizes
+  ASSERT_TRUE((page_size == 4096) || (page_size == 65536));
+  if (page_size == 4096) { 
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000010000 000000000000002A 0000000000010000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
index 4bf9094e982..f85d24737cf 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
@@ -118,6 +118,9 @@ bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
     stack_pointer = reinterpret_cast<uint8_t*>(
         info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
@@ -213,7 +216,10 @@ bool LinuxCoreDumper::EnumerateThreads() {
         memset(&info, 0, sizeof(ThreadInfo));
         info.tgid = status->pr_pgrp;
         info.ppid = status->pr_ppid;
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        for (int i = 0; i < 31; i++)
+            info.mcontext.gp_regs[i] = status->pr_reg[i];
+#elif defined(__mips__)
 # if defined(__ANDROID__)
         for (int i = EF_R0; i <= EF_R31; i++)
           info.mcontext.gregs[i - EF_R0] = status->pr_reg[i];
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc
index 85922a9c46e..5870567ce7b 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc
@@ -770,7 +770,9 @@ bool LinuxDumper::GetStackInfo(const void** stack, size_t* stack_len,
       reinterpret_cast<uint8_t*>(int_stack_pointer & ~(page_size - 1));
 
   // The number of bytes of stack which we try to capture.
-  static const ptrdiff_t kStackToCapture = 32 * 1024;
+  // This now depends on page_size to avoid missing data
+  // on systems with larger page sizes.
+  static const ptrdiff_t kStackToCapture = 8 * page_size;
 
   const MappingInfo* mapping = FindMapping(stack_pointer);
   if (!mapping)
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
index 2d5b2e52b60..a6d3dad71dc 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
@@ -64,7 +64,7 @@ namespace google_breakpad {
 typedef Elf32_auxv_t elf_aux_entry;
 #elif defined(__x86_64) || defined(__aarch64__) || \
      (defined(__mips__) && _MIPS_SIM != _ABIO32) || \
-     (defined(__riscv) && __riscv_xlen == 64)
+     (defined(__riscv) && __riscv_xlen == 64) || defined(__powerpc64__)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
index 5a135fda0e9..665c1435753 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
@@ -56,6 +56,8 @@
 #define TID_PTR_REGISTER "$1"
 #elif defined(__riscv)
 #define TID_PTR_REGISTER "x4"
+#elif defined(__powerpc64__)
+#define TID_PTR_REGISTER "r8"
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
index 2adc39e1223..f2054e99f48 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
@@ -157,14 +157,23 @@ bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid)
 #ifdef PTRACE_GETREGSET
   struct iovec io;
   info->GetGeneralPurposeRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
     return false;
   }
 
   info->GetFloatingPointRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
     return false;
   }
+
+#if defined(__powerpc64__)
+  // Grab the vector registers on PPC64 too
+  info->GetVectorRegisters(&io.iov_base, &io.iov_len);
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PPC_VMX, (void*)&io) == -1) {
+    return false;
+  }
+#endif // defined(__powerpc64__)
+
   return true;
 #else
   return false;
@@ -312,6 +321,9 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
   stack_pointer = reinterpret_cast<uint8_t*>(
       info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
index 16a9daf1d00..3ed5c98a4ed 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
@@ -470,6 +470,9 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
 #elif defined(__riscv)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.__gregs[4]);
+#elif defined(__powerpc64__)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.mcontext.gp_regs[8]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -569,6 +572,8 @@ TEST_F(LinuxPtraceDumperTest, SanitizeStackCopy) {
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
 #elif defined(__riscv)
   uintptr_t heap_addr = thread_info.mcontext.__gregs[4];
+#elif defined(__powerpc64__)
+  uintptr_t heap_addr = thread_info.mcontext.gp_regs[8];
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
index a95dd25480d..242d738c545 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
@@ -144,7 +144,9 @@ class MinidumpWriter {
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -476,7 +478,9 @@ class MinidumpWriter {
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+        UContextReader::FillCPUContext(cpu.get(), ucontext_, vector_state_);
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
 #else
         UContextReader::FillCPUContext(cpu.get(), ucontext_);
@@ -953,7 +957,7 @@ class MinidumpWriter {
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -973,7 +977,9 @@ class MinidumpWriter {
 
     // processor_architecture should always be set, do this first
     sys_info->processor_architecture =
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        MD_CPU_ARCHITECTURE_PPC64;
+#elif defined(__mips__)
 # if _MIPS_SIM == _ABIO32
         MD_CPU_ARCHITECTURE_MIPS;
 # elif _MIPS_SIM == _ABI64
@@ -1440,7 +1446,9 @@ class MinidumpWriter {
   const char* path_;  // Path to the file where the minidum should be written.
 
   const ucontext_t* const ucontext_;  // also from the signal handler
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
   const google_breakpad::fpstate_t* const float_state_;  // ditto
 #endif
   LinuxDumper* dumper_;
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
index 24e3c7bdc26..b6f72586f96 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
@@ -47,6 +47,8 @@ class ExceptionHandler;
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
+#elif defined(__powerpc64__)
+typedef vrregset_t vstate_t;
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
 typedef std::remove_pointer<fpregset_t>::type fpstate_t;
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
index effedc5e174..95f229c97fb 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -723,6 +723,9 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 #elif defined(__riscv)
   context.context.uc_mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__powerpc64__)
+  context.context.uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
index a7b96eb591f..3424edc80f5 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
@@ -72,7 +72,7 @@ bool MemoryMappedFile::Map(const char* path, size_t offset) {
 
 #if defined(__x86_64__) || defined(__aarch64__) || \
    (defined(__mips__) && _MIPS_SIM == _ABI64) || \
-   (defined(__riscv) && __riscv_xlen == 64)
+   (defined(__riscv) && __riscv_xlen == 64) || defined(__powerpc64__)
 
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
index b7a61a70e81..b71b5682f45 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
@@ -179,9 +179,10 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = getpagesize();
+  char *data1 = static_cast<char*>(malloc(2 * page_size));
+  EXPECT_TRUE(data1 != NULL);
+  size_t data1_size = (2 * page_size);
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
index 8ef68913be1..37f05e62929 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
@@ -60,8 +60,9 @@ TEST(PageAllocatorTest, LargeObject) {
 
   EXPECT_EQ(0U, allocator.pages_allocated());
   uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  uint64_t expected_pages = 1 + ((10000 - 1) / getpagesize());
   ASSERT_FALSE(p == NULL);
-  EXPECT_EQ(3U, allocator.pages_allocated());
+  EXPECT_EQ(expected_pages, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
     uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
     ASSERT_FALSE(p == NULL);
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
index 09e4690d576..3396bca2258 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
@@ -98,6 +98,8 @@ ExploitabilityFor(const string& filename) {
 }
 
 TEST(ExploitabilityTest, TestWindowsEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("ascii_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -130,9 +132,12 @@ TEST(ExploitabilityTest, TestWindowsEngine) {
             ExploitabilityFor("read_av_clobber_write.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_LOW,
             ExploitabilityFor("read_av_conditional.dmp"));
+#endif
 }
 
 TEST(ExploitabilityTest, TestLinuxEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if defined(__i386) || defined(__x86_64)
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_INTERESTING,
             ExploitabilityFor("linux_null_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -165,7 +170,8 @@ TEST(ExploitabilityTest, TestLinuxEngine) {
             ExploitabilityFor("linux_executable_heap.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_jmp_to_module_not_exe_region.dmp"));
-#ifdef __linux__
+#endif
+#if defined(__linux__) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_write_to_nonwritable_module.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
diff --git a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
index 3e310bc7d89..d2a87fff852 100644
--- a/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
+++ b/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
@@ -82,6 +82,8 @@
   #define ELF_ARCH  EM_AARCH64
 #elif defined(__riscv)
   #define ELF_ARCH  EM_RISCV
+#elif defined(__powerpc64__)
+  #define ELF_ARCH  EM_PPC64
 #endif
 
 #if defined(__arm__)
@@ -92,6 +94,8 @@ typedef user_regs user_regs_struct;
 #elif defined (__mips__) || defined(__riscv)
 // This file-local typedef simplifies the source code.
 typedef gregset_t user_regs_struct;
+#elif defined(__powerpc64__)
+typedef struct pt_regs user_regs_struct;
 #endif
 
 using google_breakpad::MDTypeHelper;
@@ -323,6 +327,9 @@ struct CrashedProcess {
 #endif
 #if defined(__aarch64__)
     user_fpsimd_struct fpregs;
+#endif
+#if defined(__powerpc64__)
+    mcontext_t mcontext;
 #endif
     uintptr_t stack_addr;
     const uint8_t* stack;
@@ -599,6 +606,38 @@ ParseThreadRegisters(CrashedProcess::Thread* thread,
 #error "Unexpected __riscv_xlen"
 #endif
 }
+#elif defined(__powerpc64__)
+static void
+ParseThreadRegisters(CrashedProcess::Thread* thread,
+                     const MinidumpMemoryRange& range) {
+  const MDRawContextPPC64* rawregs = range.GetData<MDRawContextPPC64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+    thread->mcontext.gp_regs[i] = rawregs->gpr[i];
+
+  thread->mcontext.gp_regs[PT_LNK] = rawregs->lr;
+  thread->mcontext.gp_regs[PT_NIP] = rawregs->srr0;
+  thread->mcontext.gp_regs[PT_MSR] = rawregs->srr1;
+  thread->mcontext.gp_regs[PT_CCR] = rawregs->cr;
+  thread->mcontext.gp_regs[PT_XER] = rawregs->xer;
+  thread->mcontext.gp_regs[PT_CTR] = rawregs->ctr;
+  thread->mcontext.v_regs->vrsave = rawregs->vrsave;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+      thread->mcontext.fp_regs[i] = rawregs->float_save.fpregs[i];
+
+  thread->mcontext.fp_regs[NFPREG-1] = rawregs->float_save.fpscr;
+
+  for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++) {
+      thread->mcontext.v_regs->vrregs[i][0] = rawregs->vector_save.save_vr[i].high >> 32;
+      thread->mcontext.v_regs->vrregs[i][1] = rawregs->vector_save.save_vr[i].high;
+      thread->mcontext.v_regs->vrregs[i][2] = rawregs->vector_save.save_vr[i].low >> 32;
+      thread->mcontext.v_regs->vrregs[i][3] = rawregs->vector_save.save_vr[i].low;
+  }
+
+  thread->mcontext.v_regs->vscr.vscr_word = rawregs->vector_save.save_vscr.low & 0xFFFFFFFF;
+}
+
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -704,6 +743,12 @@ ParseSystemInfo(const Options& options, CrashedProcess* crashinfo,
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__powerpc64__)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_PPC64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports PPC64.\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h
index a41ffe668a5..5cf5468f08d 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 #define CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 
+#include <cstddef>
 #include_next <sys/user.h>
 
 #include <features.h>
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h
index 12413de02b6..1cc0484c50a 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h
@@ -687,6 +687,71 @@ struct MinidumpContextRISCV64 {
   uint32_t fcsr;
 };
 
+
+//! \brief ppc64-specific flags for MinidumpPPC64::context_flags
+//! Based on minidump_cpu_ppc64.h from breakpad
+enum MinidumpContextPPC64Flags : uint32_t {
+  //! \brief Identifies the context as PPC64.
+  kMinidumpContextPPC64 = 0x01000000,
+
+  //! \brief Indicates the validity of general purpose registers.
+  //!
+  //! Registers `r0`-`r31`, `nip`, `msr`, `lr`, etc. are valid.
+  kMinidumpContextPPC64Base = kMinidumpContextPPC64 | 0x00000001,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Registers `fp0`-`fp31`, `fpscr` are valid.
+  kMinidumpContextPPC64Floating = kMinidumpContextPPC64 | 0x00000008,
+
+  //! \brief Indicates the validity of Altivec/VMX registers.
+  //!
+  //! Registers `v0`-`v31`, `vscr`, `vrsave`.
+  kMinidumpContextPPC64Vector = kMinidumpContextPPC64 | 0x00000020,
+
+  //! \brief Indicates the validity of all registers
+  kMinidumpContextPPC64All = kMinidumpContextPPC64Base     |
+                             kMinidumpContextPPC64Floating |
+                             kMinidumpContextPPC64Vector
+};
+
+//! \brief A PPC64 CPU context carried in a minidump file.
+//! Based on minidump_cpu_ppc64.h from breakpad.
+struct MinidumpContextPPC64 {
+  uint64_t context_flags;
+
+  //! \brief General purpose registers.
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+
+  //! \brief Floating point registers.
+  double fpregs[32];
+
+  //! \brief FPU status register.
+  double fpscr;
+
+  //! \brief Altivec/VMX vector registers.
+  struct {
+      //! \brief Vector registers are 128bits.
+      uint128_struct save_vr[32];
+      uint128_struct save_vscr;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad5[4];
+
+      //! \brief VRSAVE register.
+      uint32_t save_vrsave;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad6[7];
+  } vregs;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
index 84c0148203c..cda4dfcae07 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
@@ -109,6 +109,13 @@ MinidumpContextWriter::CreateFromSnapshot(const CPUContext* context_snapshot) {
       break;
     }
 
+    case kCPUArchitecturePPC64: {
+      context = std::make_unique<MinidumpContextPPC64Writer>();
+      reinterpret_cast<MinidumpContextPPC64Writer*>(context.get())
+          ->InitalizeFromSnapshot(context_snapshot->ppc64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -601,4 +608,47 @@ size_t MinidumpContextRISCV64Writer::ContextSize() const {
   return sizeof(context_);
 }
 
+MinidumpContextPPC64Writer::MinidumpContextPPC64Writer()
+  : MinidumpContextWriter(), context_() {
+    context_.context_flags = kMinidumpContextPPC64;
+}
+
+MinidumpContextPPC64Writer::~MinidumpContextPPC64Writer() = default;
+
+void MinidumpContextPPC64Writer::InitalizeFromSnapshot(
+    const CPUContextPPC64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextPPC64);
+
+  context_.context_flags = kMinidumpContextPPC64All;
+
+  memcpy(context_.regs, context_snapshot->regs, sizeof(context_.regs));
+  context_.nip = context_snapshot->nip;
+  context_.msr = context_snapshot->msr;
+  context_.ccr = context_snapshot->ccr;
+  context_.xer = context_snapshot->xer;
+  context_.lnk = context_snapshot->lnk;
+  context_.ctr = context_snapshot->ctr;
+
+  memcpy(context_.fpregs, context_snapshot->fpregs, sizeof(context_.fpregs));
+  context_.fpscr = context_snapshot->fpscr;
+
+  memcpy(context_.vregs.save_vr, context_snapshot->vregs.save_vr,
+         sizeof(context_.vregs.save_vr));
+  memcpy(&context_.vregs.save_vscr, &context_snapshot->vregs.save_vscr,
+         sizeof(context_.vregs.save_vscr));
+  context_.vregs.save_vrsave = context_snapshot->vregs.save_vrsave;
+}
+
+bool MinidumpContextPPC64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextPPC64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
index 8e39c6692f2..6ffb2204727 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
@@ -413,6 +413,43 @@ class MinidumpContextRISCV64Writer final : public MinidumpContextWriter {
   MinidumpContextRISCV64 context_;
 };
 
+class MinidumpContextPPC64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextPPC64Writer();
+  ~MinidumpContextPPC64Writer() override;
+
+  //! \brief Initalizes the MinidumpContextPPC64 based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitalizeFromSnapshot(const CPUContextPPC64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this object’s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextPPC64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextPPC64 context_;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
index 9eebe81b296..11241bad4d4 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
@@ -328,6 +328,21 @@ TYPED_TEST(MinidumpContextWriter, RISCV64_FromSnapshot) {
                    TypeParam>(context, ExpectMinidumpContextRISCV64, kSeed);
 }
 
+TEST(MinidumpContextWriter, PPC64_Zeros) {
+  EmptyContextTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+    ExpectMinidumpContextPPC64);
+}
+
+TEST(MinidumpContextWriter, PPC64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextPPC64 context_ppc64;
+  CPUContext context;
+  context.ppc64 = &context_ppc64;
+  InitializeCPUContextPPC64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+      context, ExpectMinidumpContextPPC64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 1abb46c3181..409a6cfd6db 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -177,6 +177,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips64";
 #elif defined(ARCH_CPU_RISCV64)
   static constexpr char kCPU[] = "riscv64";
+#elif defined(ARCH_CPU_PPC64)
+  static constexpr char kCPU[] = "ppc64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index c1c6fba58fe..3fced916558 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -122,6 +122,11 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
   for (size_t i = 0; i < std::size(context.riscv64->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.riscv64->regs[i]);
   }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  MaybeCaptureMemoryAround(delegate, context.ppc64->nip);
+  for (size_t i = 0; i < std::size(context.ppc64->regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.ppc64->regs[i]);
+  }
 #else
 #error Port.
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 26d45f84122..5637f31788d 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -47,6 +47,9 @@ enum CPUArchitecture {
 
   //! \brief 64-bit RISC-V.
   kCPUArchitectureRISCV64,
+
+  //! \brief 64-bit PPC64.
+  kCPUArchitecturePPC64,
 };
 
 }  // namespace crashpad
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc
index 492a0f7f914..f4447afcd91 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc
@@ -173,6 +173,8 @@ uint64_t CPUContext::InstructionPointer() const {
       return arm64->pc;
     case kCPUArchitectureRISCV64:
       return riscv64->pc;
+    case kCPUArchitecturePPC64:
+      return ppc64->nip;
     default:
       NOTREACHED();
       return ~0ull;
@@ -191,6 +193,8 @@ uint64_t CPUContext::StackPointer() const {
       return arm64->sp;
     case kCPUArchitectureRISCV64:
       return riscv64->regs[1];
+    case kCPUArchitecturePPC64:
+      return ppc64->regs[1];
     default:
       NOTREACHED();
       return ~0ull;
@@ -232,6 +236,7 @@ bool CPUContext::Is64Bit() const {
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
     case kCPUArchitectureRISCV64:
+    case kCPUArchitecturePPC64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h
index c3640c328c6..255ccf7b11b 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -371,6 +371,24 @@ struct CPUContextRISCV64 {
   uint32_t fcsr;
 };
 
+//! \brief A context structure carrying PPC64 CPU state.
+struct CPUContextPPC64 {
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+  double fpregs[32];
+  double fpscr;
+  struct {
+    uint128_struct save_vr[32];
+    uint128_struct save_vscr;
+    uint32_t save_vrsave;
+  } vregs;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -412,6 +430,7 @@ struct CPUContext {
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
     CPUContextRISCV64* riscv64;
+    CPUContextPPC64* ppc64;
   };
 };
 
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 507d1b44dd0..99b3e5755d6 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 #define CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 
+#include <cstring>
 #include "build/build_config.h"
 #include "snapshot/cpu_context.h"
 #include "snapshot/linux/signal_context.h"
@@ -188,6 +189,78 @@ void InitializeCPUContextRISCV64(const ThreadContext::t64_t& thread_context,
 
 #endif  // ARCH_CPU_RISCV64 || DOXYGEN
 
+#if defined(ARCH_CPU_PPC64_FAMILY) || DOXYGEN
+
+//! \brief Initalizes a CPUContextPPC64 structure from native context
+//!     structures on Linux.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[in] vector_context The native vector context.
+//! \param[out] context The CPUContextPPC64 structure to initalize.
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    const VectorContext::v64_t& vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.gpr, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.fpregs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const SignalThreadContext64 &thread_context,
+    const SignalFloatContext64 &float_context,
+    const SignalVectorContext64 &vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.regs, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.regs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+
+#endif
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc
index 62c5d4e85d8..b59b51db78a 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc
@@ -195,6 +195,8 @@ void TestAgainstTarget(PtraceConnection* connection) {
               device == 0 && inode == 0 && mapping_name == "[vdso]";
 #if defined(ARCH_CPU_X86)
           static constexpr char kPrefix[] = "linux-gate.so.";
+#elif defined(ARCH_CPU_PPC64)
+          static constexpr char kPrefix[] = "linux-vdso64.so.";
 #else
           static constexpr char kPrefix[] = "linux-vdso.so.";
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 677afdaa773..f7cf736790a 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -367,6 +367,69 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
   return internal::ReadContext(reader, context_address, context_.riscv64);
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  LinuxVMAddress gp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, gp_regs);
+
+  typename Traits::SignalThreadContext thread_context;
+  if (!memory->Read(gp_regs_address, sizeof(thread_context), &thread_context)) {
+    LOG(ERROR) << "Couldn't read gp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress fp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, fp_regs);
+
+  typename Traits::SignalFloatContext fp_context;
+  if (!memory->Read(fp_regs_address, sizeof(fp_context), &fp_context)) {
+    LOG(ERROR) << "Couldn't read fp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress v_regs_ptr_address = context_address +
+                                  offsetof(UContext, mcontext) +
+                                  offsetof(typename Traits::MContext, vmx_reserve) + 8;
+
+  typename Traits::SignalVectorContext v_context;
+  if (!memory->Read(v_regs_ptr_address, sizeof(v_context), &v_context)) {
+    LOG(ERROR) << "Couldn't read v_regs!";
+    return false;
+  }
+
+  InitializeCPUContextPPC64<ContextTraits64>(thread_context, fp_context,
+                            v_context, dest_context);
+
+  return true;
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.ppc64);
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits32>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  // PPC64 is 64-bit
+  return false;
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index f931d33002a..27e5922c539 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -91,6 +91,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
index b351ccaa7f8..8525aaba7ff 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
@@ -326,6 +326,28 @@ void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
             0);
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+using NativeCPUContext = ucontext_t;
+
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < 32; ++reg) {
+    context->uc_mcontext.gp_regs[reg] = reg;
+  }
+
+  memset(&context->uc_mcontext.fp_regs, 44,
+      sizeof(context->uc_mcontext.fp_regs));
+}
+
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitecturePPC64);
+
+  for (size_t reg = 0; reg < 32; ++reg) {
+    EXPECT_EQ(actual.ppc64->regs[reg], expected.uc_mcontext.gp_regs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(actual.ppc64->fpregs, expected.uc_mcontext.fp_regs,
+            sizeof(actual.ppc64->fpregs)), 0);
+}
 #else
 #error Port.
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index 45713386d95..d3f2d0e7cea 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -129,6 +129,8 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
                                     : thread_info.thread_context.t32.regs[29];
 #elif defined(ARCH_CPU_RISCV64)
   stack_pointer = thread_info.thread_context.t64.regs[1];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  stack_pointer = thread_info.thread_context.t64.gpr[1];
 #else
 #error Port.
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 89e697a08ba..5039180679f 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -456,6 +456,90 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
                   offsetof(ucontext_t, uc_mcontext.__fpregs),
               "context offset mismatch");
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+struct SignalThreadContext64 {
+  uint64_t regs[32];
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t orig_r3;
+  uint64_t ctr;
+  uint64_t lnk;
+  uint64_t xer;
+  uint64_t ccr;
+  uint64_t softe;
+  uint64_t trap;
+  uint64_t dar;
+  uint64_t dsisr;
+  uint64_t result;
+  uint64_t dscr;
+  uint64_t fpr0[3];
+};
+
+struct SignalFloatContext64 {
+  double regs[32];
+  double fpscr;
+};
+
+struct SignalVectorContext64 {
+  int32_t vrregs[32][4];
+  struct {
+    int32_t __pad[3];
+    int32_t vscr_word;
+  } vscr;
+  int32_t vrsave;
+  int32_t __pad[3];
+} __attribute__((__aligned__(16)));
+
+
+#pragma pack(pop)
+struct MContext64 {
+  uint64_t reserved[4];
+  int32_t signal;
+  int32_t __pad0;
+  uint64_t handler;
+  uint64_t oldmask;
+  uint64_t pt_regs_ptr;
+  SignalThreadContext64 gp_regs;
+  SignalFloatContext64  fp_regs;
+  SignalVectorContext64 *v_regs;
+  int64_t vmx_reserve[101];
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = SignalThreadContext64;
+  using SignalFloatContext = SignalFloatContext64;
+  using SignalVectorContext = SignalVectorContext64;
+  using CPUContext = CPUContextPPC64;
+};
+
+struct ContextTraits32 : public Traits32 {};
+
+struct UContext {
+  uint64_t flags;
+  uint64_t link;
+  SignalStack<ContextTraits64> stack;
+  Sigset<ContextTraits64> sigmask;
+  MContext64 mcontext;
+};
+#pragma pack(push, 1)
+
+static_assert(sizeof(UContext) == sizeof(ucontext_t),
+              "ucontext_t size mismatch");
+static_assert(sizeof(MContext64) == sizeof(mcontext_t),
+              "mcontext_t size mismatch");
+static_assert(sizeof(SignalThreadContext64) == sizeof(gregset_t),
+              "gregset_t size mismatch");
+static_assert(sizeof(SignalFloatContext64) == sizeof(fpregset_t),
+              "fpregset_t size mismatch");
+static_assert(sizeof(SignalVectorContext64) == sizeof(vrregset_t),
+              "vrregset_t size mismatch");
+static_assert(offsetof(UContext, mcontext) ==
+              offsetof(ucontext_t, uc_mcontext), "mcontext offset mismatch");
+static_assert(offsetof(MContext64, gp_regs) ==
+              offsetof(mcontext_t, gp_regs), "gp_regs offset mismatch");
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index 20b95fba538..0bd42c3b4a0 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -207,6 +207,8 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
                                     : kCPUArchitectureMIPSEL;
 #elif defined(ARCH_CPU_RISCV64)
   return kCPUArchitectureRISCV64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return kCPUArchitecturePPC64;
 #else
 #error port to your architecture
 #endif
@@ -225,6 +227,9 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return 0;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -248,6 +253,9 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return std::string();
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -384,6 +392,9 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return false;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
index c03cbaae567..a70f9ac8a4d 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
@@ -112,6 +112,8 @@ bool WriteTestModule(const base::FilePath& module_path,
   module.ehdr.e_machine = EM_MIPS;
 #elif defined(ARCH_CPU_RISCV64)
   module.ehdr.e_machine = EM_RISCV;
+#elif defined(ARCH_CPU_PPC64)
+  module.ehdr.e_machine = EM_PPC64;
 #endif
 
 #if defined(ARCH_CPU_RISCV64)
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index 85882e8ee46..c6aa5af39ae 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -196,6 +196,14 @@ bool ThreadSnapshotLinux::Initialize(
   InitializeCPUContextRISCV64(thread.thread_info.thread_context.t64,
                               thread.thread_info.float_context.f64,
                               context_.riscv64);
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+  InitializeCPUContextPPC64<ContextTraits64>(
+      thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      thread.thread_info.vector_context.v64,
+      context_.ppc64);
 #else
 #error Port.
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index 5795bfb985a..a290eeecfb5 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -76,6 +76,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc
index 1bdaf7b6f5f..3e8b4326e60 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc
@@ -56,6 +56,11 @@ bool AuxiliaryVector::Read(PtraceConnection* connection) {
     if (type == AT_IGNORE) {
       continue;
     }
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    if (type == AT_IGNOREPPC) {
+      continue;
+    }
+#endif
     if (!MapInsertOrReplace(&values_, type, value, nullptr)) {
       LOG(ERROR) << "duplicate auxv entry";
       return false;
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc
index d8129ada781..73e6079b508 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -429,6 +429,64 @@ bool GetThreadArea64(pid_t tid,
   return true;
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+// PPC64 has had HAVE_ARCH_TRACEHOOK set since 2.6.27 (even before x86 had it).
+// That means we can simply use PTRACE_GETREGESET.
+
+template <typename Destination>
+bool GetRegisterSet(pid_t tid, int set, Destination* dest, bool can_log) {
+  iovec iov;
+  iov.iov_base = reinterpret_cast<void*>(dest);
+  iov.iov_len = sizeof(*dest);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(set), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(*dest)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size";
+    return false;
+  }
+  return true;
+}
+
+bool GetVectorRegisters64(pid_t tid,
+                          VectorContext* context,
+                          bool can_log) {
+  return GetRegisterSet(tid, NT_PPC_VMX, &context->v64, can_log);
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return GetRegisterSet(tid, NT_PRFPREG, &context->f64, can_log);
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  // PPC64 doesn't have PTRACE_GET_THREAD_AREA since the thread pointer
+  // is stored in GPR 13.
+  ThreadContext::t64_t tc;
+  if (!GetRegisterSet(tid, NT_PRSTATUS, &tc, can_log)) {
+    LOG_IF(ERROR, can_log) << "Unable to get thread pointer!";
+    return false;
+  }
+
+  *address = tc.gpr[13];
+
+  return true;
+}
+
+// Stubs for 32-bit functions not applicable on PPC64
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) { return false; }
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext &context,
+                     LinuxVMAddress *address,
+                     bool can_log) { return false; }
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -527,6 +585,9 @@ bool Ptracer::GetThreadInfo(pid_t tid, ThreadInfo* info) {
   if (is_64_bit_) {
     return GetGeneralPurposeRegisters64(tid, &info->thread_context, can_log_) &&
            GetFloatingPointRegisters64(tid, &info->float_context, can_log_) &&
+#if defined(ARCH_CPU_PPC64_FAMILY)
+           GetVectorRegisters64(tid, &info->vector_context, can_log_) &&
+#endif
            GetThreadArea64(tid,
                            info->thread_context,
                            &info->thread_specific_data_address,
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h
index 808b35a3aff..c134e789f38 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -34,6 +34,11 @@
 #include <asm/ptrace.h>
 #endif
 
+#if defined(ARCH_CPU_PPC64_FAMILY)
+#include <sys/ucontext.h>
+#include <asm/ptrace.h>
+#endif
+
 namespace crashpad {
 
 //! \brief The set of general purpose registers for an architecture family.
@@ -87,6 +92,8 @@ union ThreadContext {
     uint32_t padding1_;
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // PPC64 is 64-bit
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -144,6 +151,21 @@ union ThreadContext {
     // Reflects user_regs_struct in asm/ptrace.h.
     uint64_t pc;
     uint64_t regs[31];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects struct pt_regs in asm/ptrace.h.
+    uint64_t gpr[32];
+    uint64_t nip;
+    uint64_t msr;
+    uint64_t orig_gpr3;
+    uint64_t ctr;
+    uint64_t lnk;
+    uint64_t xer;
+    uint64_t ccr;
+    uint64_t softe;
+    uint64_t trap;
+    uint64_t dar;
+    uint64_t dsisr;
+    uint64_t result;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -156,6 +178,8 @@ union ThreadContext {
   using NativeThreadContext = user_regs;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
 // No appropriate NativeThreadsContext type available for MIPS
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  using NativeThreadContext = struct pt_regs;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64 || ARCH_CPU_RISCV64
@@ -233,6 +257,9 @@ union FloatContext {
     uint32_t fpu_id;
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Crashpad's PPC support is 64-bit only, so this
+    // 32bit-only struct is declared as empty.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -271,6 +298,10 @@ union FloatContext {
     // Reflects __riscv_d_ext_state in asm/ptrace.h
     uint64_t fpregs[32];
     uint64_t fcsr;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects fpregset_t in sys/ucontext.h
+    double fpregs[32];
+    double fpscr;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -302,6 +333,8 @@ union FloatContext {
 // No appropriate floating point context native type for available MIPS.
 #elif defined(ARCH_CPU_RISCV64)
   static_assert(sizeof(f64) == sizeof(__riscv_d_ext_state), "Size mismatch");
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  static_assert(sizeof(f64) == sizeof(fpregset_t), "Size mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86
@@ -309,6 +342,26 @@ union FloatContext {
 static_assert(std::is_standard_layout<FloatContext>::value,
               "Not standard layout");
 
+//! \brief The vector registers used for an architecture family
+union VectorContext {
+  struct v32_t {} v32;
+#if defined(ARCH_CPU_PPC64_FAMILY)
+  __attribute__((__aligned__(16))) // Vector context must be doubleword aligned.
+#endif
+  struct v64_t {
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects vrregset_t in sys/ucontext.h
+    uint32_t vrregs[32][4];
+    struct {
+      uint32_t __pad[3];
+      uint32_t vscr_word;
+    } vscr;
+    uint32_t vrsave;
+    uint32_t __pad[3];
+#endif
+  } v64;
+};
+
 //! \brief A collection of `ptrace`-able information about a thread.
 struct ThreadInfo {
   ThreadInfo();
@@ -320,6 +373,9 @@ struct ThreadInfo {
   //! \brief The floating point registers for the thread.
   FloatContext float_context;
 
+  //! \brief (Optional) The vector registers used for the thread.
+  VectorContext vector_context;
+
   //! \brief The thread-local storage address for the thread.
   LinuxVMAddress thread_specific_data_address;
 };
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
index ac7707b48ca..5cb99e1ff1b 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -70,6 +70,7 @@ using NativeCPUContext = ucontext_t;
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
 //!     Linux               | RISCV64      | `a0`
+//!     Linux               | PPC64        | `r3`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
index cfad85738e5..d9fab44a9d9 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
@@ -34,7 +34,7 @@
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
-#elif defined(__mips__)
+#elif defined(__mips__) || defined(__powerpc64__)
   .balign 4, 0x0
 #elif defined(__riscv)
   .balign 4, 0x0
@@ -429,6 +429,216 @@ CAPTURECONTEXT_SYMBOL2:
   jr $ra
 
   .set at
+#elif defined(__powerpc64__)
+  // Store r0-r31
+  std 0, 0xe8(3)   // context->uc_mcontext.gp_regs[0]
+  std 1, 0xf0(3)   // context->uc_mcontext.gp_regs[1]
+  std 2, 0xf8(3)   // context->uc_mcontext.gp_regs[2]
+  // note that r3's original value was lost
+  std 3, 0x100(3)  // context->uc_mcontext.gp_regs[3]
+  std 4, 0x108(3)  // context->uc_mcontext.gp_regs[4]
+  std 5, 0x110(3)  // context->uc_mcontext.gp_regs[5]
+  std 6, 0x118(3)  // context->uc_mcontext.gp_regs[6]
+  std 7, 0x120(3)  // context->uc_mcontext.gp_regs[7]
+  std 8, 0x128(3)  // context->uc_mcontext.gp_regs[8]
+  std 9, 0x130(3)  // context->uc_mcontext.gp_regs[9]
+  std 10, 0x138(3) // context->uc_mcontext.gp_regs[10]
+  std 11, 0x140(3) // context->uc_mcontext.gp_regs[11]
+  std 12, 0x148(3) // context->uc_mcontext.gp_regs[12]
+  std 13, 0x150(3) // context->uc_mcontext.gp_regs[13]
+  std 14, 0x158(3) // context->uc_mcontext.gp_regs[14]
+  std 15, 0x160(3) // context->uc_mcontext.gp_regs[15]
+  std 16, 0x168(3) // context->uc_mcontext.gp_regs[16]
+  std 17, 0x170(3) // context->uc_mcontext.gp_regs[17]
+  std 18, 0x178(3) // context->uc_mcontext.gp_regs[18]
+  std 19, 0x180(3) // context->uc_mcontext.gp_regs[19]
+  std 20, 0x188(3) // context->uc_mcontext.gp_regs[20]
+  std 21, 0x190(3) // context->uc_mcontext.gp_regs[21]
+  std 22, 0x198(3) // context->uc_mcontext.gp_regs[22]
+  std 23, 0x1a0(3) // context->uc_mcontext.gp_regs[23]
+  std 24, 0x1a8(3) // context->uc_mcontext.gp_regs[24]
+  std 25, 0x1b0(3) // context->uc_mcontext.gp_regs[25]
+  std 26, 0x1b8(3) // context->uc_mcontext.gp_regs[26]
+  std 27, 0x1c0(3) // context->uc_mcontext.gp_regs[27]
+  std 28, 0x1c8(3) // context->uc_mcontext.gp_regs[28]
+  std 29, 0x1d0(3) // context->uc_mcontext.gp_regs[29]
+  std 30, 0x1d8(3) // context->uc_mcontext.gp_regs[30]
+  std 31, 0x1e0(3) // context->uc_mcontext.gp_regs[31]
+
+  // For NIP, we can use the value in the link register
+  mflr 0
+  std 0, 0x1e8(3) // context->uc_mcontext.gp_regs[PT_NIP]
+
+  // CTR
+  mfctr 0
+  std 0, 0x200(3) // context->uc_mcontext.gp_regs[PT_CTR]
+
+  // For LNK, we'll use the caller's LR save area (2 stack frames up).
+  // r4 can be used as a scratch register since it has already been saved.
+  ld 4, 0(1)
+  ld 4, 16(4)
+  std 4, 0x208(3) // context->uc_mcontext.gp_regs[PT_LNK]
+
+  // XER
+  mfxer 0
+  std 0, 0x210(3) // context->uc_mcontext.gp_regs[PT_XER]
+
+  // CCR
+  mfcr 0
+  std 0, 0x218(3) // context->uc_mcontext.gp_regs[PT_CCR]
+
+  // MSR, orig_r3, MQ, TRAP, DAR, DSISR, RESULT, DSCR,
+  // not used or not relevant,  zero them out.
+  li 4, 0
+  std 4, 0x1f0(3) // context->uc_mcontext.gp_regs[PT_MSR]
+  std 4, 0x1f8(3) // context->uc_mcontext.gp_regs[PT_ORIG_R3]
+  std 4, 0x220(3) // context->uc_mcontext.gp_regs[PT_MQ]
+  std 4, 0x228(3) // context->uc_mcontext.gp_regs[PT_TRAP]
+  std 4, 0x230(3) // context->uc_mcontext.gp_regs[PT_DAR]
+  std 4, 0x238(3) // context->uc_mcontext.gp_regs[PT_DSISR]
+  std 4, 0x240(3) // context->uc_mcontext.gp_regs[PT_RESULT]
+  std 4, 0x248(3) // context->uc_mcontext.gp_regs[PT_DSCR]
+
+  // Update context->uc_mcontext.regs to point to gp_regs
+  addi 0, 3, 0xe8
+  std 0, 0xe0(3)
+
+  // Save floating point registers 0-31
+  stfd 0, 0x268(3)  // context->uc_mcontext.fp_regs[0]
+  stfd 1, 0x270(3)  // context->uc_mcontext.fp_regs[1]
+  stfd 2, 0x278(3)  // context->uc_mcontext.fp_regs[2]
+  stfd 3, 0x280(3)  // context->uc_mcontext.fp_regs[3]
+  stfd 4, 0x288(3)  // context->uc_mcontext.fp_regs[4]
+  stfd 5, 0x290(3)  // context->uc_mcontext.fp_regs[5]
+  stfd 6, 0x298(3)  // context->uc_mcontext.fp_regs[6]
+  stfd 7, 0x2a0(3)  // context->uc_mcontext.fp_regs[7]
+  stfd 8, 0x2a8(3)  // context->uc_mcontext.fp_regs[8]
+  stfd 9, 0x2b0(3)  // context->uc_mcontext.fp_regs[9]
+  stfd 10, 0x2b8(3) // context->uc_mcontext.fp_regs[10]
+  stfd 11, 0x2c0(3) // context->uc_mcontext.fp_regs[11]
+  stfd 12, 0x2c8(3) // context->uc_mcontext.fp_regs[12]
+  stfd 13, 0x2d0(3) // context->uc_mcontext.fp_regs[13]
+  stfd 14, 0x2d8(3) // context->uc_mcontext.fp_regs[14]
+  stfd 15, 0x2e0(3) // context->uc_mcontext.fp_regs[15]
+  stfd 16, 0x2e8(3) // context->uc_mcontext.fp_regs[16]
+  stfd 17, 0x2f0(3) // context->uc_mcontext.fp_regs[17]
+  stfd 18, 0x2f8(3) // context->uc_mcontext.fp_regs[18]
+  stfd 19, 0x300(3) // context->uc_mcontext.fp_regs[19]
+  stfd 20, 0x308(3) // context->uc_mcontext.fp_regs[20]
+  stfd 21, 0x310(3) // context->uc_mcontext.fp_regs[21]
+  stfd 22, 0x318(3) // context->uc_mcontext.fp_regs[22]
+  stfd 23, 0x320(3) // context->uc_mcontext.fp_regs[23]
+  stfd 24, 0x328(3) // context->uc_mcontext.fp_regs[24]
+  stfd 25, 0x330(3) // context->uc_mcontext.fp_regs[25]
+  stfd 26, 0x338(3) // context->uc_mcontext.fp_regs[26]
+  stfd 27, 0x340(3) // context->uc_mcontext.fp_regs[27]
+  stfd 28, 0x348(3) // context->uc_mcontext.fp_regs[28]
+  stfd 29, 0x350(3) // context->uc_mcontext.fp_regs[29]
+  stfd 30, 0x358(3) // context->uc_mcontext.fp_regs[30]
+  stfd 31, 0x360(3) // context->uc_mcontext.fp_regs[31]
+
+  // FPSCR
+  mffs 0
+  stfd 0, 0x368(3) // context->uc_mcontext.fp_regs[32]
+
+  // Save VMX Vector registers
+  // Update r4 to contain the base address of vmx_reserve
+  addi 4, 3, 0x378
+  // Ensure that it is quadword aligned
+  andi. 5, 4, 0xF
+  beq 1f // No alignment is necessary
+  // Address is doubleword aligned and not quadword aligned, add 8
+  addi 4, 4, 8
+
+1:
+  // Store VMX registers 0-31
+  // r4 will contain the base address
+  // r5 will contain the index
+  li 5, 0
+  stvx 0, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 0]
+  addi 5, 5, 16
+  stvx 1, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 1]
+  addi 5, 5, 16
+  stvx 2, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 2]
+  addi 5, 5, 16
+  stvx 3, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 3]
+  addi 5, 5, 16
+  stvx 4, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 4]
+  addi 5, 5, 16
+  stvx 5, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 5]
+  addi 5, 5, 16
+  stvx 6, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 6]
+  addi 5, 5, 16
+  stvx 7, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 7]
+  addi 5, 5, 16
+  stvx 8, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 8]
+  addi 5, 5, 16
+  stvx 9, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 9]
+  addi 5, 5, 16
+  stvx 10, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 10]
+  addi 5, 5, 16
+  stvx 11, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 11]
+  addi 5, 5, 16
+  stvx 12, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 12]
+  addi 5, 5, 16
+  stvx 13, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 13]
+  addi 5, 5, 16
+  stvx 14, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 14]
+  addi 5, 5, 16
+  stvx 15, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 15]
+  addi 5, 5, 16
+  stvx 16, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 16]
+  addi 5, 5, 16
+  stvx 17, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 17]
+  addi 5, 5, 16
+  stvx 18, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 18]
+  addi 5, 5, 16
+  stvx 19, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 19]
+  addi 5, 5, 16
+  stvx 20, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 20]
+  addi 5, 5, 16
+  stvx 21, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 21]
+  addi 5, 5, 16
+  stvx 22, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 22]
+  addi 5, 5, 16
+  stvx 23, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 23]
+  addi 5, 5, 16
+  stvx 24, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 24]
+  addi 5, 5, 16
+  stvx 25, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 25]
+  addi 5, 5, 16
+  stvx 26, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 26]
+  addi 5, 5, 16
+  stvx 27, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 27]
+  addi 5, 5, 16
+  stvx 28, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 28]
+  addi 5, 5, 16
+  stvx 29, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 29]
+  addi 5, 5, 16
+  stvx 30, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 30]
+  addi 5, 5, 16
+  stvx 31, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 31]
+  addi 5, 5, 16
+
+  // VSCR
+  mfvscr 0
+  stvx 0, 4, 5
+  addi 5, 5, 16
+
+  // VRSAVE
+  mfvrsave 0
+  stwx 0, 4, 5
+
+  // Update context->uc_mcontext.v_regs to point to vmx_reserve + alignment.
+  std 4, 0x370(3)
+
+  // Zero out all unused fields
+  li 4, 0
+  std 4, 0xc8(3) // context->uc_mcontext.signal
+  std 4, 0xd0(3) // context->uc_mcontext.handler
+  std 4, 0xd8(3) // context->uc_mcontext.oldmask
+
+  blr
 
 #elif defined(__riscv)
 
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
index 2cd92c841aa..5c154ce356f 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
@@ -48,7 +48,7 @@ void TestCaptureContext() {
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
 #if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
-    !defined(MEMORY_SANITIZER)
+    !defined(MEMORY_SANITIZER) && !defined(ARCH_CPU_PPC64_FAMILY)
   // Sanitizers can cause enough code bloat that the “nearby” check would
   // likely fail.
   const uintptr_t kReferencePC =
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
index 55820b9ee7a..478f9787f71 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
@@ -35,6 +35,8 @@ void SanityCheckContext(const NativeCPUContext& context) {
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  EXPECT_EQ(context.uc_mcontext.gp_regs[3], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_RISCV64)
   EXPECT_EQ(context.uc_mcontext.__gregs[10],
             FromPointerCast<uintptr_t>(&context));
@@ -52,6 +54,8 @@ uintptr_t ProgramCounterFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[PT_NIP];
 #elif defined(ARCH_CPU_RISCV64)
   return context.uc_mcontext.__gregs[0];
 #endif
@@ -68,6 +72,8 @@ uintptr_t StackPointerFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[1];
 #elif defined(ARCH_CPU_RISCV64)
   return context.uc_mcontext.__gregs[2];
 #endif
diff --git a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index df63a77296d..d91ae3fde4f 100644
--- a/src/3rdparty/chromium/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/src/3rdparty/chromium/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -239,6 +239,12 @@ std::string UserAgent() {
 #endif
 #elif defined (ARCH_CPU_RISCV64)
     static constexpr char arch[] = "riscv64";
+#elif defined(__powerpc64__)
+#if defined(ARCH_CPU_LITTLE_ENDIAN)
+    static constexpr char arch[] = "ppc64le";
+#elif defined(ARCH_CPU_BIG_ENDIAN)
+    static constexpr char arch[] = "ppc64";
+#endif
 #else
 #error Port
 #endif
diff --git a/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64/config.h b/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64/config.h
new file mode 100644
index 00000000000..7834eee6b84
--- /dev/null
+++ b/src/3rdparty/chromium/third_party/dav1d/config/linux/ppc64/config.h
@@ -0,0 +1,48 @@
+/*
+ * Autogenerated by the Meson build system.
+ * Do not edit, your changes will be lost.
+ */
+
+#pragma once
+
+#define ARCH_AARCH64 0
+
+#define ARCH_ARM 0
+
+#define ARCH_PPC64LE 1
+
+#define ARCH_X86 0
+
+#define ARCH_X86_32 0
+
+#define ARCH_X86_64 0
+
+#define CONFIG_16BPC 1
+
+#define CONFIG_8BPC 1
+
+// #define CONFIG_LOG 1 -- Logging is controlled by Chromium
+
+#define ENDIANNESS_BIG 0
+
+#define HAVE_ASM 1
+
+#define HAVE_AS_FUNC 0
+
+#define HAVE_C11_GENERIC 1
+
+#define HAVE_CLOCK_GETTIME 1
+
+#define HAVE_DLSYM 1
+
+#define HAVE_GETAUXVAL 1
+
+#define HAVE_POSIX_MEMALIGN 1
+
+// #define HAVE_PTHREAD_GETAFFINITY_NP 1 -- Controlled by Chomium
+
+// #define HAVE_PTHREAD_SETAFFINITY_NP 1 -- Controlled by Chomium
+
+#define HAVE_UNISTD_H 1
+
+#define TRIM_DSP_FUNCTIONS 1
diff --git a/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/dav1d_types.h b/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/dav1d_types.h
index 0b4bd72f0e6..a0caa5e710d 100644
--- a/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/dav1d_types.h
+++ b/src/3rdparty/chromium/third_party/dav1d/libdav1d/src/ppc/dav1d_types.h
@@ -51,4 +51,19 @@
 #define u16l_to_i32(v) ((i32x4) vec_mergel((u16x8) v, vec_splat_u16(0)))
 #define i16l_to_i32(v) ((i32x4) vec_unpackl((i16x8)v))
 
+#if defined(__clang__)
+#undef vec_splats
+#define vec_splats(N)                     \
+    _Generic((N),                         \
+        unsigned char:      ((u8x16)(N)), \
+        signed char:        ((i8x16)(N)), \
+        unsigned short:     ((u16x8)(N)), \
+        signed short:       ((i16x8)(N)), \
+        unsigned int:       ((u32x4)(N)), \
+        signed int:         ((i32x4)(N)), \
+        unsigned long long: ((u64x2)(N)), \
+        signed long long:   ((i64x2)(N))  \
+    )
+#endif
+
 #endif /* DAV1D_SRC_PPC_TYPES_H */
diff --git a/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Assert.cpp b/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Assert.cpp
index b4bf6c577b2..01aed4feff4 100644
--- a/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Assert.cpp
+++ b/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Assert.cpp
@@ -39,9 +39,9 @@ void BreakPoint() {
     __asm__ __volatile__("ebreak");
 #elif DAWN_PLATFORM_IS(MIPS)
     __asm__ __volatile__("break");
-#elif DAWN_PLATFORM_IS(S390) || DAWN_PLATFORM_IS_(S390X)
+#elif DAWN_PLATFORM_IS(S390) || DAWN_PLATFORM_IS(S390X)
     __asm__ __volatile__(".word 0x0001");
-#elif DAWN_PLATFORM_IS(PPC) || DAWN_PLATFORM_IS_(PPC64)
+#elif DAWN_PLATFORM_IS(PPC) || DAWN_PLATFORM_IS(PPC64)
     __asm__ __volatile__("twge 2,2");
 #else
 #error "Unsupported platform"
diff --git a/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Platform.h b/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Platform.h
index ddaf1ad0e3b..1df97bbccbc 100644
--- a/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Platform.h
+++ b/src/3rdparty/chromium/third_party/dawn/src/dawn/common/Platform.h
@@ -140,15 +140,15 @@
 #define DAWN_PLATFORM_IS_MIPS64 1
 #endif
 
-#elif defiend(__s390__)
+#elif defined(__s390__)
 #define DAWN_PLATFORM_IS_S390 1
-#elif defiend(__s390x__)
+#elif defined(__s390x__)
 #define DAWN_PLATFORM_IS_S390X 1
 
-#elif defined(__PPC__)
-#define DAWN_PLATFORM_IS_PPC 1
 #elif defined(__PPC64__)
 #define DAWN_PLATFORM_IS_PPC64 1
+#elif defined(__PPC__)
+#define DAWN_PLATFORM_IS_PPC 1
 
 #else
 #error "Unsupported platform."
@@ -166,7 +166,7 @@
 static_assert(sizeof(sizeof(char)) == 8, "Expect sizeof(size_t) == 8");
 #elif defined(DAWN_PLATFORM_IS_I386) || defined(DAWN_PLATFORM_IS_ARM32) ||   \
     defined(DAWN_PLATFORM_IS_RISCV32) || defined(DAWN_PLATFORM_IS_MIPS32) || \
-    defined(DAWN_PLATFORM_IS_S390) || defined(DAWN_PLATFORM_IS_PPC32) ||     \
+    defined(DAWN_PLATFORM_IS_S390) || defined(DAWN_PLATFORM_IS_PPC) ||     \
     defined(DAWN_PLATFORM_IS_EMSCRIPTEN) || defined(DAWN_PLATFORM_IS_LOONGARCH32)
 #define DAWN_PLATFORM_IS_32_BIT 1
 static_assert(sizeof(sizeof(char)) == 4, "Expect sizeof(size_t) == 4");
diff --git a/src/3rdparty/chromium/third_party/eigen3/BUILD.gn b/src/3rdparty/chromium/third_party/eigen3/BUILD.gn
index f810260543a..9d597a2f1e9 100644
--- a/src/3rdparty/chromium/third_party/eigen3/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/eigen3/BUILD.gn
@@ -19,7 +19,7 @@ config("eigen_includes") {
     "EIGEN_HAS_TYPE_TRAITS=0",
   ]
 
-  if (target_os == "win" && target_cpu == "arm64") {
+  if ((target_os == "win" && target_cpu == "arm64") || target_cpu == "ppc64") {
     # https://crbug.com/1182242 - Neon extensions are temporarily disabled
     # for this component on Windows on Arm due to compilation errors.
     defines += [ "EIGEN_DONT_VECTORIZE" ]
diff --git a/src/3rdparty/chromium/third_party/highway/src/hwy/detect_targets.h b/src/3rdparty/chromium/third_party/highway/src/hwy/detect_targets.h
index 847235de835..ff0b9f8f2f0 100644
--- a/src/3rdparty/chromium/third_party/highway/src/hwy/detect_targets.h
+++ b/src/3rdparty/chromium/third_party/highway/src/hwy/detect_targets.h
@@ -121,6 +121,10 @@
 #define HWY_SCALAR (1LL << 62)
 #define HWY_HIGHEST_TARGET_BIT_SCALAR 62
 
+#ifdef __powerpc64__
+#define HWY_COMPILE_ONLY_SCALAR 1
+#endif
+
 // Do not use bit 63 - would be confusing to have negative numbers.
 
 //------------------------------------------------------------------------------
diff --git a/src/3rdparty/chromium/third_party/highway/src/hwy/targets.cc b/src/3rdparty/chromium/third_party/highway/src/hwy/targets.cc
index 55ea147280d..9b6e6f0f24a 100644
--- a/src/3rdparty/chromium/third_party/highway/src/hwy/targets.cc
+++ b/src/3rdparty/chromium/third_party/highway/src/hwy/targets.cc
@@ -46,7 +46,7 @@
 // sys/auxv.h does not always include asm/hwcap.h, or define HWCAP*, hence we
 // still include this directly. See #1199.
 #ifndef TOOLCHAIN_MISS_ASM_HWCAP_H
-#include <asm/hwcap.h>
+#include <asm/cputable.h>
 #endif
 #ifndef TOOLCHAIN_MISS_SYS_AUXV_H
 #include <sys/auxv.h>
diff --git a/src/3rdparty/chromium/third_party/libaom/BUILD.gn b/src/3rdparty/chromium/third_party/libaom/BUILD.gn
index 622da283de0..2a51eb23b4d 100644
--- a/src/3rdparty/chromium/third_party/libaom/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/libaom/BUILD.gn
@@ -43,6 +43,8 @@ if (current_cpu == "x86") {
   cpu_arch_full = "generic"
 } else if (current_cpu == "loong64") {
   cpu_arch_full = "generic"
+} else if (current_cpu == "ppc64") {
+  cpu_arch_full = "generic"
 } else {
   cpu_arch_full = current_cpu
 }
diff --git a/src/3rdparty/chromium/third_party/libpng/pngpriv.h b/src/3rdparty/chromium/third_party/libpng/pngpriv.h
index 583c26f9bde..e03d697c5ae 100644
--- a/src/3rdparty/chromium/third_party/libpng/pngpriv.h
+++ b/src/3rdparty/chromium/third_party/libpng/pngpriv.h
@@ -196,11 +196,7 @@
 #endif
 
 #ifndef PNG_POWERPC_VSX_OPT
-#  if defined(__PPC64__) && defined(__ALTIVEC__) && defined(__VSX__)
-#     define PNG_POWERPC_VSX_OPT 2
-#  else
-#     define PNG_POWERPC_VSX_OPT 0
-#  endif
+#  define PNG_POWERPC_VSX_OPT 0
 #endif
 
 #ifndef PNG_INTEL_SSE_OPT
diff --git a/src/3rdparty/chromium/third_party/libvpx/BUILD.gn b/src/3rdparty/chromium/third_party/libvpx/BUILD.gn
index 159473390bc..c27693e0380 100644
--- a/src/3rdparty/chromium/third_party/libvpx/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/libvpx/BUILD.gn
@@ -47,6 +47,8 @@ if (current_cpu == "x86") {
   }
 } else if (current_cpu == "riscv64") {
   cpu_arch_full = "generic"
+} else if (current_cpu == "ppc64") {
+  cpu_arch_full = "generic"
 } else if (current_cpu == "loong64") {
   cpu_arch_full = "loongarch"
 } else {
@@ -428,7 +430,7 @@ static_library("bundled_libvpx") {
       public_deps = [ ":libvpx_arm64_headers" ]
     }
   } else if (current_cpu == "ppc64") {
-    sources = libvpx_srcs_ppc64
+    sources = libvpx_srcs_generic
   } else if (current_cpu == "riscv64") {
     sources = libvpx_srcs_generic
     public_deps = [ ":libvpx_generic_headers" ]
diff --git a/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh b/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh
index 07eb4f25781..7f689d0b898 100755
--- a/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh
+++ b/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh
@@ -207,7 +207,7 @@ function convert_srcs_to_project_files() {
 
 # Clean files from previous make.
 function make_clean() {
-  make clean > /dev/null
+  gmake clean > /dev/null
   rm -f libvpx_srcs.txt
 }
 
@@ -405,7 +405,7 @@ gen_config_files linux/mipsel "--target=mips32-linux-gcc ${all_platforms}"
 gen_config_files linux/mips64el "--target=mips64-linux-gcc ${all_platforms}"
 gen_config_files linux/loongarch \
   "--target=loongarch64-linux-gcc ${all_platforms}"
-gen_config_files linux/ppc64 "--target=ppc64le-linux-gcc ${all_platforms}"
+gen_config_files linux/ppc64 "--target=generic-gnu ${all_platforms}"
 gen_config_files linux/generic "--target=generic-gnu $HIGHBD ${all_platforms}"
 gen_config_files win/arm64 \
   "--target=arm64-win64-vs15 ${all_platforms} ${HIGHBD}"
@@ -468,7 +468,7 @@ gen_rtcd_header linux/arm64-highbd armv8
 gen_rtcd_header linux/mipsel mipsel
 gen_rtcd_header linux/mips64el mips64el
 gen_rtcd_header linux/loongarch loongarch
-gen_rtcd_header linux/ppc64 ppc
+gen_rtcd_header linux/ppc64 generic
 gen_rtcd_header linux/generic generic
 gen_rtcd_header win/arm64 armv8
 gen_rtcd_header win/ia32 x86 "${require_sse2}"
@@ -491,7 +491,7 @@ if [[ -z $ONLY_CONFIGS ]]; then
   echo "Generate X86 source list."
   config=$(print_config linux/ia32)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_x86
 
   # Copy vpx_version.h. The file should be the same for all platforms.
@@ -505,43 +505,43 @@ if [[ -z $ONLY_CONFIGS ]]; then
   # object should not perturb the other builds.
   config=$(print_config win/x64)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_x86_64
 
   echo "Generate ARM source list."
   config=$(print_config linux/arm)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm
 
   echo "Generate ARM NEON source list."
   config=$(print_config linux/arm-neon)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm_neon
 
   echo "Generate ARM NEON CPU DETECT source list."
   config=$(print_config linux/arm-neon-cpu-detect)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm_neon_cpu_detect
 
   echo "Generate ARM64 source list."
   config=$(print_config linux/arm64)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm64
 
   echo "Generate ARM NEON HighBD source list."
   config=$(print_config linux/arm-neon-highbd)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm_neon_highbd
 
   echo "Generate ARM64 HighBD source list."
   config=$(print_config linux/arm64-highbd)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_arm64_highbd
 
   echo "ARM64 Windows and Mac use the ARM64 Linux HighBD source list." \
@@ -550,7 +550,7 @@ if [[ -z $ONLY_CONFIGS ]]; then
   echo "Generate MIPS source list."
   config=$(print_config_basic linux/mipsel)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_mips
 
   echo "MIPS64 source list is identical to MIPS source list." \
@@ -559,26 +559,26 @@ if [[ -z $ONLY_CONFIGS ]]; then
   echo "Generate LOONGARCH source list."
   config=$(print_config_basic linux/loongarch)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_loongarch
 
   echo "Generate ppc64 source list."
   config=$(print_config_basic linux/ppc64)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_ppc64
 
 
   echo "Generate NaCl source list."
   config=$(print_config_basic nacl)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_nacl
 
   echo "Generate GENERIC source list."
   config=$(print_config_basic linux/generic)
   make_clean
-  make libvpx_srcs.txt target=libs $config > /dev/null
+  gmake libvpx_srcs.txt target=libs $config > /dev/null
   convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_generic
 fi
 
diff --git a/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h b/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
index 99a4b444918..b8d0db369f6 100644
--- a/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
+++ b/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
@@ -4638,7 +4638,7 @@ struct kernel_statx {
       LSS_REG(2, buf);
       LSS_BODY(void*, mmap2, "0"(__r2));
     }
-#else
+#elif !defined(__powerpc64__)
     #define __NR__mmap2 __NR_mmap2
     LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                          size_t,                   l, int,               p,
@@ -4749,7 +4749,7 @@ struct kernel_statx {
   #if defined(__i386__) ||                                                    \
       defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
-      defined(__PPC__) ||                                                     \
+     (defined(__PPC__) && !defined(__powerpc64__)) ||                         \
      (defined(__s390__) && !defined(__s390x__))
     /* On these architectures, implement mmap() with mmap2(). */
     LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
@@ -4872,11 +4872,11 @@ struct kernel_statx {
       LSS_SC_BODY(4, int, 8, d, type, protocol, sv);
     }
   #endif
-  #if defined(__NR_recvmsg)
+  #if defined(__NR_recvmsg) && !defined(__PPC__)
     LSS_INLINE _syscall3(ssize_t, recvmsg, int, s, struct kernel_msghdr*, msg,
                          int, flags)
   #endif
-  #if defined(__NR_sendmsg)
+  #if defined(__NR_sendmsg) && !defined(__PPC__)
     LSS_INLINE _syscall3(ssize_t, sendmsg, int, s, const struct kernel_msghdr*,
                          msg, int, flags)
   #endif
@@ -4885,13 +4885,13 @@ struct kernel_statx {
                          int, flags, const struct kernel_sockaddr*, to,
                          unsigned int, tolen)
   #endif
-  #if defined(__NR_shutdown)
+  #if defined(__NR_shutdown) && !defined(__PPC__)
     LSS_INLINE _syscall2(int, shutdown, int, s, int, how)
   #endif
-  #if defined(__NR_socket)
+  #if defined(__NR_socket) && !defined(__PPC__)
     LSS_INLINE _syscall3(int, socket, int, domain, int, type, int, protocol)
   #endif
-  #if defined(__NR_socketpair)
+  #if defined(__NR_socketpair) && !defined(__PPC__)
     LSS_INLINE _syscall4(int, socketpair, int, d, int, type, int, protocol,
                          int*, sv)
   #endif
@@ -4947,6 +4947,7 @@ struct kernel_statx {
   # endif
   #endif
   #if defined(__NR_fstatat64)
+    #undef fstatat64
     LSS_INLINE _syscall4(int,   fstatat64,        int,   d,
                          const char *,      p,
                          struct kernel_stat64 *,   b,    int,   f)
diff --git a/src/3rdparty/chromium/third_party/pffft/src/pffft.c b/src/3rdparty/chromium/third_party/pffft/src/pffft.c
index bdac4d78499..51e0f2cacc4 100644
--- a/src/3rdparty/chromium/third_party/pffft/src/pffft.c
+++ b/src/3rdparty/chromium/third_party/pffft/src/pffft.c
@@ -100,6 +100,7 @@
    Altivec support macros 
 */
 #if !defined(PFFFT_SIMD_DISABLE) && (defined(__ppc__) || defined(__ppc64__))
+#include <altivec.h>
 typedef vector float v4sf;
 #  define SIMD_SZ 4
 #  define VZERO() ((vector float) vec_splat_u8(0))
diff --git a/src/3rdparty/chromium/third_party/skia/src/core/SkRasterPipeline.h b/src/3rdparty/chromium/third_party/skia/src/core/SkRasterPipeline.h
index dc5fb4b8f24..f696f25a8b9 100644
--- a/src/3rdparty/chromium/third_party/skia/src/core/SkRasterPipeline.h
+++ b/src/3rdparty/chromium/third_party/skia/src/core/SkRasterPipeline.h
@@ -24,7 +24,7 @@ enum SkColorType : int;
 struct SkImageInfo;
 struct skcms_TransferFunction;
 
-#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32)
+#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32) && !defined(__powerpc__)
     #define SK_HAS_MUSTTAIL 1
 #else
     #define SK_HAS_MUSTTAIL 0
diff --git a/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c b/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c
index dc6e6d64305..6d348c02bb5 100644
--- a/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c
+++ b/src/3rdparty/chromium/third_party/sqlite/src/amalgamation/sqlite3.c
@@ -14576,7 +14576,9 @@ typedef INT16_TYPE LogEst;
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) || \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
@@ -203065,7 +203067,8 @@ struct RtreeMatchArg {
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) || \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff --git a/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c b/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c
index da5e2a97a8c..e2cab63ebaa 100644
--- a/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c
+++ b/src/3rdparty/chromium/third_party/sqlite/src/ext/rtree/rtree.c
@@ -474,7 +474,9 @@ struct RtreeMatchArg {
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) || \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff --git a/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h b/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h
index ab94b56c638..9d2791eb0db 100644
--- a/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h
+++ b/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h
@@ -905,7 +905,8 @@ typedef INT16_TYPE LogEst;
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) || \
+     defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
diff --git a/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn b/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
index 59e52303c5c..d780239c847 100644
--- a/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
@@ -583,6 +583,7 @@ swiftshader_llvm_source_set("swiftshader_llvm_most") {
     "llvm/lib/MC/MCAsmInfoCOFF.cpp",
     "llvm/lib/MC/MCAsmInfoDarwin.cpp",
     "llvm/lib/MC/MCAsmInfoELF.cpp",
+    "llvm/lib/MC/MCAsmInfoXCOFF.cpp",
     "llvm/lib/MC/MCAsmMacro.cpp",
     "llvm/lib/MC/MCAsmStreamer.cpp",
     "llvm/lib/MC/MCAssembler.cpp",
@@ -638,6 +639,7 @@ swiftshader_llvm_source_set("swiftshader_llvm_most") {
     "llvm/lib/MC/MCWinCOFFStreamer.cpp",
     "llvm/lib/MC/MCWinEH.cpp",
     "llvm/lib/MC/MCXCOFFStreamer.cpp",
+    "llvm/lib/MC/MCXCOFFObjectTargetWriter.cpp",
     "llvm/lib/MC/MachObjectWriter.cpp",
     "llvm/lib/MC/StringTableBuilder.cpp",
     "llvm/lib/MC/SubtargetFeature.cpp",
diff --git a/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-16.0/BUILD.gn b/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-16.0/BUILD.gn
index 13f5cc3658c..434610051ed 100644
--- a/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-16.0/BUILD.gn
+++ b/src/3rdparty/chromium/third_party/swiftshader/third_party/llvm-16.0/BUILD.gn
@@ -765,6 +765,7 @@ swiftshader_llvm_source_set("swiftshader_llvm_source_set_0") {
     "llvm/lib/MC/MCAsmInfoCOFF.cpp",
     "llvm/lib/MC/MCAsmInfoDarwin.cpp",
     "llvm/lib/MC/MCAsmInfoELF.cpp",
+    "llvm/lib/MC/MCAsmInfoXCOFF.cpp",
     "llvm/lib/MC/MCAsmMacro.cpp",
     "llvm/lib/MC/MCAsmStreamer.cpp",
     "llvm/lib/MC/MCAssembler.cpp",
@@ -825,6 +826,7 @@ swiftshader_llvm_source_set("swiftshader_llvm_source_set_0") {
     "llvm/lib/MC/MCWinCOFFStreamer.cpp",
     "llvm/lib/MC/MCWinEH.cpp",
     "llvm/lib/MC/MCXCOFFStreamer.cpp",
+    "llvm/lib/MC/MCXCOFFObjectTargetWriter.cpp",
     "llvm/lib/MC/MachObjectWriter.cpp",
     "llvm/lib/MC/SPIRVObjectWriter.cpp",
     "llvm/lib/MC/StringTableBuilder.cpp",
diff --git a/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h b/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h
index 9d945ef7fc1..77da679f622 100644
--- a/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h
+++ b/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h
@@ -89,6 +89,18 @@
 #elif defined(__EMSCRIPTEN__)
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
+#elif defined(__PPC__)
+#define WEBRTC_ARCH_PPC_FAMILY
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define WEBRTC_ARCH_LITTLE_ENDIAN
+#else
+#define WEBRTC_ARCH_BIG_ENDIAN
+#endif
+#if defined(__LP64__)
+#define WEBRTC_ARCH_64_BITS
+#else
+#define WEBRTC_ARCH_32_BITS
+#endif
 #else
 #error Please add support for your architecture in rtc_base/system/arch.h
 #endif
diff --git a/src/3rdparty/chromium/ui/gl/features.gni b/src/3rdparty/chromium/ui/gl/features.gni
index 83266614af0..29d3a227d56 100644
--- a/src/3rdparty/chromium/ui/gl/features.gni
+++ b/src/3rdparty/chromium/ui/gl/features.gni
@@ -37,5 +37,5 @@ declare_args() {
        is_chromeos_ash || is_fuchsia) &&
       (target_cpu == "x86" || target_cpu == "x64" || target_cpu == "arm" ||
        target_cpu == "arm64" || target_cpu == "mipsel" ||
-       target_cpu == "mips64el" || target_cpu == "riscv64")
+       target_cpu == "mips64el" || target_cpu == "riscv64" || target_cpu == "ppc64")
 }
diff --git a/src/3rdparty/chromium/v8/BUILD.gn b/src/3rdparty/chromium/v8/BUILD.gn
index b83b22ea0d5..aabbded4647 100644
--- a/src/3rdparty/chromium/v8/BUILD.gn
+++ b/src/3rdparty/chromium/v8/BUILD.gn
@@ -1333,6 +1333,12 @@ config("toolchain") {
     }
     if (host_byteorder == "little") {
       defines += [ "V8_TARGET_ARCH_PPC_LE" ]
+      cflags += [
+        # Enable usage of AltiVec, VSX, and other POWER8 and higher features
+        "-mcpu=power8",
+        "-maltivec",
+        "-mvsx",
+      ]
     } else if (host_byteorder == "big") {
       defines += [ "V8_TARGET_ARCH_PPC_BE" ]
       if (current_os == "aix") {
diff --git a/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index d6ac210e8d4..c85e30e8921 100644
--- a/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -796,11 +796,13 @@ Handle<HeapObject> RegExpMacroAssemblerPPC::GetCode(Handle<String> source) {
       __ mov(r3, Operand(stack_limit));
       __ LoadU64(r3, MemOperand(r3));
       __ sub(r3, sp, r3, LeaveOE, SetRC);
+      Operand extra_space_for_variables(num_registers_ * kSystemPointerSize);
+
       // Handle it if the stack pointer is already below the stack limit.
       __ ble(&stack_limit_hit, cr0);
       // Check if there is room for the variable number of registers above
       // the stack limit.
-      __ CmpU64(r3, Operand(num_registers_ * kSystemPointerSize), r0);
+      __ CmpU64(r3, extra_space_for_variables, r0);
       __ bge(&stack_ok);
       // Exit with OutOfMemory exception. There is not enough space on the stack
       // for our working registers.
@@ -808,7 +810,7 @@ Handle<HeapObject> RegExpMacroAssemblerPPC::GetCode(Handle<String> source) {
       __ b(&return_r3);
 
       __ bind(&stack_limit_hit);
-      CallCheckStackGuardState(r3);
+      CallCheckStackGuardState(r3, extra_space_for_variables);
       __ cmpi(r3, Operand::Zero());
       // If returned value is non-zero, we exit with the returned value as
       // result.
@@ -1210,7 +1212,7 @@ void RegExpMacroAssemblerPPC::ClearRegisters(int reg_from, int reg_to) {
 
 // Private methods:
 
-void RegExpMacroAssemblerPPC::CallCheckStackGuardState(Register scratch) {
+void RegExpMacroAssemblerPPC::CallCheckStackGuardState(Register scratch, Operand extra_space) {
   DCHECK(!isolate()->IsGeneratingEmbeddedBuiltins());
   DCHECK(!masm_->options().isolate_independent_code);
 
@@ -1241,6 +1243,8 @@ void RegExpMacroAssemblerPPC::CallCheckStackGuardState(Register scratch) {
   __ li(r0, Operand::Zero());
   __ StoreU64WithUpdate(r0, MemOperand(sp, -stack_space * kSystemPointerSize));
 
+  // Extra space for variables to consider in stack check.
+  __ mov(r6, extra_space);
   // RegExp code frame pointer.
   __ mr(r5, frame_pointer());
   // InstructionStream of self.
@@ -1283,7 +1287,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 
 int RegExpMacroAssemblerPPC::CheckStackGuardState(Address* return_address,
                                                   Address raw_code,
-                                                  Address re_frame) {
+                                                  Address re_frame,
+                                                  uintptr_t extra_space) {
   Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
@@ -1293,7 +1298,8 @@ int RegExpMacroAssemblerPPC::CheckStackGuardState(Address* return_address,
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
       frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
-      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset),
+      extra_space);
 }
 
 
diff --git a/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.h b/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.h
index 5f4b24a78d4..455e1d9eeef 100644
--- a/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.h
+++ b/src/3rdparty/chromium/v8/src/regexp/ppc/regexp-macro-assembler-ppc.h
@@ -88,7 +88,7 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerPPC
   // returning.
   // {raw_code} is an Address because this is called via ExternalReference.
   static int CheckStackGuardState(Address* return_address, Address raw_code,
-                                  Address re_frame);
+                                  Address re_frame, uintptr_t extra_space);
 
  private:
   // Offsets from frame_pointer() of function parameters and stored registers.
@@ -154,7 +154,7 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerPPC
   // Check whether we are exceeding the stack limit on the backtrack stack.
   void CheckStackLimit();
 
-  void CallCheckStackGuardState(Register scratch);
+  void CallCheckStackGuardState(Register scratch, Operand extra_space_for_variables = Operand::Zero());
   void CallIsCharacterInRangeArray(const ZoneList<CharacterRange>* ranges);
 
   // The ebp-relative location of a regexp register.
diff --git a/src/3rdparty/chromium/v8/test/BUILD.gn b/src/3rdparty/chromium/v8/test/BUILD.gn
index 6a04cbca45f..53ef9f998dd 100644
--- a/src/3rdparty/chromium/v8/test/BUILD.gn
+++ b/src/3rdparty/chromium/v8/test/BUILD.gn
@@ -42,7 +42,7 @@ group("gn_all") {
       "benchmarks/cpp:gn_all",
       "cctest:cctest",
       "unittests:generate-bytecode-expectations",
-      "unittests:v8_unittests",
+      #"unittests:v8_unittests",
     ]
   }
 }
@@ -98,7 +98,7 @@ group("v8_bot_default") {
     "message:v8_message",
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
-    "unittests:v8_unittests",
+    #"unittests:v8_unittests",
     "webkit:v8_webkit",
   ]
 
@@ -123,7 +123,7 @@ group("v8_default") {
     "message:v8_message",
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
-    "unittests:v8_unittests",
+    #"unittests:v8_unittests",
   ]
 
   if (v8_enable_webassembly) {
