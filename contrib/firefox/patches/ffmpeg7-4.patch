From a73b9687612c893b2c7d43b0a92750f3de166ef3 Mon Sep 17 00:00:00 2001
From: Paul Adenot <paul@paul.cx>
Date: Tue, 30 Apr 2024 14:21:45 +0000
Subject: [PATCH] Bug 1889978 - Vendor ffmpeg master, after 7.0, update and
 reapply patch, remove old files, move bsf files into the bsf directory.
 r=media-playback-reviewers,alwu

This stubs out `libavcodec/dovi_rpu.h`.

Differential Revision: https://phabricator.services.mozilla.com/D206923
---
 CLOBBER                                       |    2 +-
 config/system-headers.mozbuild                |    2 +
 media/ffvpx/README_MOZILLA                    |    3 +
 media/ffvpx/changes.patch                     |  118 +-
 media/ffvpx/libavcodec/allcodecs.c            |   12 +-
 media/ffvpx/libavcodec/atsc_a53.c             |    1 +
 media/ffvpx/libavcodec/audio_frame_queue.c    |    2 +-
 media/ffvpx/libavcodec/av1.h                  |    1 +
 media/ffvpx/libavcodec/av1_parse.h            |   16 +-
 media/ffvpx/libavcodec/av1dec.c               |  163 ++-
 media/ffvpx/libavcodec/av1dec.h               |    4 +
 media/ffvpx/libavcodec/avcodec.c              |   61 +-
 media/ffvpx/libavcodec/avcodec.h              |  761 ++++++------
 media/ffvpx/libavcodec/avcodec.symbols        |   22 +-
 media/ffvpx/libavcodec/avcodec_internal.h     |   18 +-
 media/ffvpx/libavcodec/avdct.c                |   47 +-
 media/ffvpx/libavcodec/avpicture.c            |   82 --
 media/ffvpx/libavcodec/bitstream_filters.c    |    2 +-
 media/ffvpx/libavcodec/blockdsp.h             |    1 +
 .../av1_frame_split.c}                        |    0
 media/ffvpx/libavcodec/bsf/moz.build          |   21 +
 .../libavcodec/{null_bsf.c => bsf/null.c}     |    0
 .../vp9_superframe_split.c}                   |    0
 media/ffvpx/libavcodec/cbs.c                  |    1 +
 media/ffvpx/libavcodec/cbs_av1.h              |    5 +
 .../libavcodec/cbs_av1_syntax_template.c      |   37 +-
 media/ffvpx/libavcodec/codec.h                |    7 -
 media/ffvpx/libavcodec/codec_desc.c           |   16 +-
 media/ffvpx/libavcodec/codec_id.h             |    4 +-
 media/ffvpx/libavcodec/codec_internal.h       |   19 -
 media/ffvpx/libavcodec/codec_par.c            |   46 -
 media/ffvpx/libavcodec/codec_par.h            |   71 +-
 media/ffvpx/libavcodec/decode.c               |  272 +++--
 media/ffvpx/libavcodec/decode.h               |   41 +
 media/ffvpx/libavcodec/dovi_rpu.h             |   29 +
 media/ffvpx/libavcodec/encode.c               |   42 +-
 media/ffvpx/libavcodec/encode.h               |    6 +
 media/ffvpx/libavcodec/flacdec.c              |    3 +-
 media/ffvpx/libavcodec/get_bits.h             |   27 +-
 media/ffvpx/libavcodec/get_buffer.c           |   22 +-
 media/ffvpx/libavcodec/hwaccel.h              |   84 --
 media/ffvpx/libavcodec/hwaccel_internal.h     |    2 +-
 media/ffvpx/libavcodec/idctdsp.c              |   14 +-
 media/ffvpx/libavcodec/idctdsp.h              |   12 +-
 media/ffvpx/libavcodec/internal.h             |   28 +-
 .../libavcodec/{fdctdsp_init.c => itut35.h}   |   32 +-
 media/ffvpx/libavcodec/leb.h                  |   70 ++
 media/ffvpx/libavcodec/libaomenc.c            |   29 +-
 media/ffvpx/libavcodec/libdav1d.c             |  141 ++-
 media/ffvpx/libavcodec/libopusenc.c           |   19 +-
 media/ffvpx/libavcodec/libvorbisenc.c         |    1 +
 media/ffvpx/libavcodec/libvpxenc.c            |  115 +-
 media/ffvpx/libavcodec/me_cmp.h               |    1 +
 media/ffvpx/libavcodec/moz.build              |   14 +-
 media/ffvpx/libavcodec/mpegaudiodata.h        |    3 +
 .../ffvpx/libavcodec/mpegaudiodec_template.c  |    3 +-
 media/ffvpx/libavcodec/mpegaudiodectab.h      |  615 ----------
 media/ffvpx/libavcodec/mpegaudiodsp.h         |    3 +
 media/ffvpx/libavcodec/mpegvideodsp.h         |   47 -
 media/ffvpx/libavcodec/options.c              |   13 +-
 media/ffvpx/libavcodec/options_table.h        |  547 ++++-----
 .../ffvpx/libavcodec/{avpacket.c => packet.c} |    1 +
 media/ffvpx/libavcodec/packet.h               |   16 +-
 media/ffvpx/libavcodec/parser.c               |    1 +
 media/ffvpx/libavcodec/pcm.c                  |    1 +
 media/ffvpx/libavcodec/pixblockdsp.h          |   10 +-
 media/ffvpx/libavcodec/profiles.c             |    3 +-
 media/ffvpx/libavcodec/profiles.h             |    5 +-
 media/ffvpx/libavcodec/pthread_frame.c        |   18 +-
 media/ffvpx/libavcodec/ratecontrol.h          |    4 +-
 media/ffvpx/libavcodec/refstruct.c            |    8 +-
 media/ffvpx/libavcodec/utils.c                |   29 +-
 media/ffvpx/libavcodec/vaapi.h                |   86 --
 media/ffvpx/libavcodec/vaapi_decode.c         |   10 +-
 media/ffvpx/libavcodec/version.c              |   16 +-
 media/ffvpx/libavcodec/version.h              |    4 +-
 media/ffvpx/libavcodec/version_major.h        |   25 +-
 media/ffvpx/libavcodec/vlc.c                  |   11 +-
 media/ffvpx/libavcodec/vlc.h                  |   46 +-
 media/ffvpx/libavcodec/vorbis_data.c          |   14 -
 media/ffvpx/libavcodec/vorbis_data.h          |    6 +-
 media/ffvpx/libavcodec/vorbis_parser.c        |    2 +-
 media/ffvpx/libavcodec/vp8.c                  |   10 +-
 media/ffvpx/libavcodec/vp8.h                  |    2 -
 media/ffvpx/libavcodec/vp8dsp.c               |    2 +
 media/ffvpx/libavcodec/vp8dsp.h               |    1 +
 media/ffvpx/libavcodec/vp9.c                  |    1 +
 media/ffvpx/libavcodec/x86/h264_intrapred.asm |   31 +-
 .../libavcodec/x86/h264_intrapred_init.c      |   14 +-
 media/ffvpx/libavcodec/x86/moz.build          |    2 +
 media/ffvpx/libavcodec/x86/simple_idct.asm    |   37 +-
 media/ffvpx/libavcodec/x86/vp56_arith.h       |   53 -
 media/ffvpx/libavcodec/x86/vp8dsp.asm         |   30 +-
 media/ffvpx/libavcodec/x86/vp9itxfm.asm       |    2 +
 media/ffvpx/libavcodec/x86/vp9itxfm_16bpp.asm |   12 +-
 media/ffvpx/libavutil/aarch64/cpu.c           |   30 +-
 .../ffvpx/libavutil/arm/float_dsp_init_vfp.c  |    2 +-
 media/ffvpx/libavutil/avstring.c              |    2 +-
 media/ffvpx/libavutil/avutil.h                |   13 -
 media/ffvpx/libavutil/avutil.symbols          |   31 +-
 media/ffvpx/libavutil/bprint.h                |   12 +-
 media/ffvpx/libavutil/channel_layout.c        |  543 ++++-----
 media/ffvpx/libavutil/channel_layout.h        |  228 ++--
 media/ffvpx/libavutil/color_utils.c           |  234 ----
 media/ffvpx/libavutil/color_utils.h           |   56 -
 media/ffvpx/libavutil/common.h                |   21 +-
 media/ffvpx/libavutil/cpu.c                   |    6 +-
 media/ffvpx/libavutil/csp.h                   |  150 +++
 media/ffvpx/libavutil/dict.c                  |   10 +-
 media/ffvpx/libavutil/eval.c                  |    3 +-
 media/ffvpx/libavutil/fftime.h                |    1 -
 media/ffvpx/libavutil/ffversion.h             |    2 +-
 media/ffvpx/libavutil/fifo.c                  |  219 ----
 media/ffvpx/libavutil/fifo.h                  |  206 ----
 media/ffvpx/libavutil/film_grain_params.c     |   68 +-
 media/ffvpx/libavutil/film_grain_params.h     |   68 +-
 media/ffvpx/libavutil/fixed_dsp.c             |    3 +-
 media/ffvpx/libavutil/fixed_dsp.h             |    3 +-
 media/ffvpx/libavutil/float_dsp.c             |    2 +-
 media/ffvpx/libavutil/float_dsp.h             |    4 +-
 media/ffvpx/libavutil/frame.c                 |  400 +++----
 media/ffvpx/libavutil/frame.h                 |  184 ++-
 media/ffvpx/libavutil/hdr_dynamic_metadata.h  |    4 +-
 media/ffvpx/libavutil/hwcontext.c             |  290 +++--
 media/ffvpx/libavutil/hwcontext.h             |   25 +-
 media/ffvpx/libavutil/hwcontext_internal.h    |   30 +-
 media/ffvpx/libavutil/hwcontext_vaapi.c       |   52 +-
 media/ffvpx/libavutil/imgutils.c              |    2 +-
 media/ffvpx/libavutil/imgutils_internal.h     |    4 +
 media/ffvpx/libavutil/internal.h              |   16 +-
 media/ffvpx/libavutil/intreadwrite.h          |    4 +-
 media/ffvpx/libavutil/mem.c                   |    6 +-
 media/ffvpx/libavutil/mem.h                   |    2 +-
 media/ffvpx/libavutil/mem_internal.h          |   35 +-
 media/ffvpx/libavutil/moz.build               |    8 +-
 media/ffvpx/libavutil/opt.c                   | 1059 ++++++++++-------
 media/ffvpx/libavutil/opt.h                   |  601 ++++++----
 media/ffvpx/libavutil/pixdesc.c               |    9 +-
 media/ffvpx/libavutil/pixfmt.h                |   14 +-
 media/ffvpx/libavutil/rational.c              |    2 +-
 media/ffvpx/libavutil/rational.h              |    4 +
 media/ffvpx/libavutil/thread.h                |   20 +-
 media/ffvpx/libavutil/timecode.c              |    2 +-
 media/ffvpx/libavutil/timestamp.h             |   15 +-
 media/ffvpx/libavutil/tx.c                    |   22 +-
 media/ffvpx/libavutil/tx_template.c           |    2 +
 media/ffvpx/libavutil/version.h               |   27 +-
 media/ffvpx/libavutil/x86/emms.h              |   58 -
 media/ffvpx/libavutil/x86/fixed_dsp_init.c    |    4 +-
 media/ffvpx/libavutil/x86/float_dsp_init.c    |    5 +-
 media/ffvpx/libavutil/x86/intreadwrite.h      |   36 -
 media/ffvpx/libavutil/x86/moz.build           |    2 +
 media/ffvpx/libavutil/x86/tx_float.asm        |    8 +-
 media/ffvpx/libavutil/x86/tx_float_init.c     |   19 +-
 media/ffvpx/libavutil/x86/x86inc.asm          |  672 +++++++----
 media/ffvpx/libavutil/x86/x86util.asm         |    4 -
 media/ffvpx/libavutil_visibility.h            |    2 +-
 157 files changed, 4383 insertions(+), 5476 deletions(-)
 delete mode 100644 media/ffvpx/libavcodec/avpicture.c
 rename media/ffvpx/libavcodec/{av1_frame_split_bsf.c => bsf/av1_frame_split.c} (100%)
 create mode 100644 media/ffvpx/libavcodec/bsf/moz.build
 rename media/ffvpx/libavcodec/{null_bsf.c => bsf/null.c} (100%)
 rename media/ffvpx/libavcodec/{vp9_superframe_split_bsf.c => bsf/vp9_superframe_split.c} (100%)
 create mode 100644 media/ffvpx/libavcodec/dovi_rpu.h
 delete mode 100644 media/ffvpx/libavcodec/hwaccel.h
 rename media/ffvpx/libavcodec/{fdctdsp_init.c => itut35.h} (50%)
 create mode 100644 media/ffvpx/libavcodec/leb.h
 delete mode 100644 media/ffvpx/libavcodec/mpegaudiodectab.h
 delete mode 100644 media/ffvpx/libavcodec/mpegvideodsp.h
 rename media/ffvpx/libavcodec/{avpacket.c => packet.c} (99%)
 delete mode 100644 media/ffvpx/libavcodec/vaapi.h
 delete mode 100644 media/ffvpx/libavcodec/x86/vp56_arith.h
 delete mode 100644 media/ffvpx/libavutil/color_utils.c
 delete mode 100644 media/ffvpx/libavutil/color_utils.h
 create mode 100644 media/ffvpx/libavutil/csp.h
 delete mode 100644 media/ffvpx/libavutil/x86/emms.h

diff --git a/CLOBBER b/CLOBBER
index 503c67edeee1f..a55a341a655fb 100644
--- a/CLOBBER
+++ b/CLOBBER
@@ -22,4 +22,4 @@
 # changes to stick? As of bug 928195, this shouldn't be necessary! Please
 # don't change CLOBBER for WebIDL changes any more.
 
-Modified build files in third_party/libwebrtc - Bug 1888181 - Vendor libwebrtc from 414c94290a
+Bug 1889978 - Changed system header list
diff --git a/config/system-headers.mozbuild b/config/system-headers.mozbuild
index 06649230bfa03..aa17660a106c0 100644
--- a/config/system-headers.mozbuild
+++ b/config/system-headers.mozbuild
@@ -412,6 +412,8 @@ system_headers = [
     "LFocusBox.h",
     "LGrafPortView.h",
     "LHandleStream.h",
+    "libavutil/mem.h",
+    "libavutil/cpu.h",
     "libc_r.h",
     "libelf.h",
     "libelf/libelf.h",
diff --git a/media/ffvpx/README_MOZILLA b/media/ffvpx/README_MOZILLA
index b766be4abdc57..e23a199797a47 100644
--- a/media/ffvpx/README_MOZILLA
+++ b/media/ffvpx/README_MOZILLA
@@ -36,6 +36,9 @@ Then, make sure the files:
 include conditional compilation directives, by probably reverting them (or
 reverting and adjusting them if new codecs are added).
 
+Revert and adjust libavcodec `dovi_rpu.h` so that it contains just the necessary
+stubs to compile.
+
 ## Add headers for a new major ffmpeg version
 
 If a new major version of ffmpeg is being imported in the tree, it's necessary
diff --git a/media/ffvpx/changes.patch b/media/ffvpx/changes.patch
index af2aa20849406..6b8486bbff64a 100644
--- a/media/ffvpx/changes.patch
+++ b/media/ffvpx/changes.patch
@@ -1,21 +1,11 @@
-diff --git a/media/ffvpx/libavutil/eval.c b/media/ffvpx/libavutil/eval.c
-index 7642b91..e938bd5 100644
---- a/media/ffvpx/libavutil/eval.c
-+++ b/media/ffvpx/libavutil/eval.c
-@@ -34,7 +34,7 @@
- #include "internal.h"
- #include "log.h"
- #include "mathematics.h"
--#include "time.h"
-+#include "fftime.h"
- #include "avstring.h"
- #include "timer.h"
- 
-diff --git a/media/ffvpx/libavutil/time.c b/media/ffvpx/libavutil/time.c
-index dbaee02..69419e6 100644
---- a/media/ffvpx/libavutil/time.c
-+++ b/media/ffvpx/libavutil/time.c
-@@ -33,7 +33,7 @@
+--- a/libavutil/time.c	2024-02-14 14:57:10.389087159 +0100
++++ b/libavutil/time.c	2024-04-05 14:43:19.097889433 +0200
+@@ -28,17 +28,17 @@
+ #endif
+ #if HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ #if HAVE_WINDOWS_H
  #include <windows.h>
  #endif
  
@@ -24,11 +14,19 @@ index dbaee02..69419e6 100644
  #include "error.h"
  
  int64_t av_gettime(void)
-diff --git a/media/ffvpx/libavutil/parseutils.c b/media/ffvpx/libavutil/parseutils.c
-index 9fb8d0a..97ad3b9 100644
---- a/media/ffvpx/libavutil/parseutils.c
-+++ b/media/ffvpx/libavutil/parseutils.c
-@@ -28,7 +28,7 @@
+ {
+ #if HAVE_GETTIMEOFDAY
+     struct timeval tv;
+     gettimeofday(&tv, NULL);
+     return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+--- a/libavutil/parseutils.c	2024-03-26 14:03:12.080640731 +0100
++++ b/libavutil/parseutils.c	2024-04-05 14:44:56.508766832 +0200
+@@ -23,20 +23,20 @@
+ 
+ #include <time.h>
+ 
+ #include "avstring.h"
+ #include "avutil.h"
  #include "common.h"
  #include "eval.h"
  #include "log.h"
@@ -36,8 +34,22 @@ index 9fb8d0a..97ad3b9 100644
 +/* #include "random_seed.h" */
  #include "time_internal.h"
  #include "parseutils.h"
+-#include "time.h"
++#include "fftime.h"
+ 
+ #ifdef TEST
  
-@@ -367,7 +367,7 @@ int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,
+ #define av_get_random_seed av_get_random_seed_deterministic
+ static uint32_t av_get_random_seed_deterministic(void);
+ 
+ #define av_gettime() 1331972053200000
+ 
+@@ -370,17 +370,17 @@
+     av_strlcpy(color_string2, color_string + hex_offset,
+                FFMIN(slen-hex_offset+1, sizeof(color_string2)));
+     if ((tail = strchr(color_string2, ALPHA_SEP)))
+         *tail++ = 0;
+     len = strlen(color_string2);
      rgba_color[3] = 255;
  
      if (!av_strcasecmp(color_string2, "random") || !av_strcasecmp(color_string2, "bikeshed")) {
@@ -46,37 +58,29 @@ index 9fb8d0a..97ad3b9 100644
          rgba_color[0] = rgba >> 24;
          rgba_color[1] = rgba >> 16;
          rgba_color[2] = rgba >> 8;
-diff -up media/ffvpx/libavutil/fftime.h media/ffvpx/libavutil/fftime.h
---- media/ffvpx/libavutil/fftime.h	2021-12-06 14:51:40.378642713 +0100
-+++ media/ffvpx/libavutil/fftime.h	2021-12-06 14:51:54.618098212 +0100
-@@ -22,6 +22,7 @@
- #define AVUTIL_TIME_H
- 
- #include <stdint.h>
-+#include <time.h>
- 
- /**
-  * Get the current time in microseconds.
-  *
-diff --git a/media/ffvpx/compat/w32pthreads.h b/media/ffvpx/compat/w32pthreads.h
---- a/media/ffvpx/compat/w32pthreads.h
-+++ b/media/ffvpx/compat/w32pthreads.h
-@@ -39,17 +39,17 @@
- #include <windows.h>
- #include <process.h>
- #include <time.h>
- 
- #include "libavutil/attributes.h"
- #include "libavutil/common.h"
- #include "libavutil/internal.h"
- #include "libavutil/mem.h"
--#include "libavutil/time.h"
-+#include "libavutil/fftime.h"
- 
- typedef struct pthread_t {
-     void *handle;
-     void *(*func)(void* arg);
-     void *arg;
-     void *ret;
- } pthread_t;
+         rgba_color[3] = rgba;
+     } else if (hex_offset ||
+                strspn(color_string2, "0123456789ABCDEFabcdef") == len) {
+         char *tail;
+         unsigned int rgba = strtoul(color_string2, &tail, 16);
+--- a/libavutil/eval.c	2024-04-05 14:40:56.917791496 +0200
++++ b/libavutil/eval.c	2024-04-05 17:39:45.061516936 +0200
+@@ -31,17 +31,17 @@
+ #include "avutil.h"
+ #include "common.h"
+ #include "eval.h"
+ #include "ffmath.h"
+ #include "log.h"
+ #include "mathematics.h"
+ #include "mem.h"
+ #include "sfc64.h"
+-#include "time.h"
++#include "fftime.h"
+ #include "avstring.h"
+ #include "reverse.h"
  
+ typedef struct Parser {
+     const AVClass *class;
+     int stack_index;
+     char *s;
+     const double *const_values;
diff --git a/media/ffvpx/libavcodec/allcodecs.c b/media/ffvpx/libavcodec/allcodecs.c
index ef8c3a6d7db4f..f4705651fb855 100644
--- a/media/ffvpx/libavcodec/allcodecs.c
+++ b/media/ffvpx/libavcodec/allcodecs.c
@@ -61,10 +61,6 @@ extern const FFCodec ff_avrn_decoder;
 extern const FFCodec ff_avs_decoder;
 extern const FFCodec ff_avui_encoder;
 extern const FFCodec ff_avui_decoder;
-#if FF_API_AYUV_CODECID
-extern const FFCodec ff_ayuv_encoder;
-extern const FFCodec ff_ayuv_decoder;
-#endif
 extern const FFCodec ff_bethsoftvid_decoder;
 extern const FFCodec ff_bfi_decoder;
 extern const FFCodec ff_bink_decoder;
@@ -152,7 +148,6 @@ extern const FFCodec ff_h263p_encoder;
 extern const FFCodec ff_h263p_decoder;
 extern const FFCodec ff_h263_v4l2m2m_decoder;
 extern const FFCodec ff_h264_decoder;
-extern const FFCodec ff_h264_crystalhd_decoder;
 extern const FFCodec ff_h264_v4l2m2m_decoder;
 extern const FFCodec ff_h264_mediacodec_decoder;
 extern const FFCodec ff_h264_mediacodec_encoder;
@@ -211,13 +206,11 @@ extern const FFCodec ff_mpeg2video_encoder;
 extern const FFCodec ff_mpeg2video_decoder;
 extern const FFCodec ff_mpeg4_encoder;
 extern const FFCodec ff_mpeg4_decoder;
-extern const FFCodec ff_mpeg4_crystalhd_decoder;
 extern const FFCodec ff_mpeg4_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg4_mmal_decoder;
 extern const FFCodec ff_mpegvideo_decoder;
 extern const FFCodec ff_mpeg1_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg2_mmal_decoder;
-extern const FFCodec ff_mpeg2_crystalhd_decoder;
 extern const FFCodec ff_mpeg2_v4l2m2m_decoder;
 extern const FFCodec ff_mpeg2_qsv_decoder;
 extern const FFCodec ff_mpeg2_mediacodec_decoder;
@@ -228,7 +221,6 @@ extern const FFCodec ff_msmpeg4v2_encoder;
 extern const FFCodec ff_msmpeg4v2_decoder;
 extern const FFCodec ff_msmpeg4v3_encoder;
 extern const FFCodec ff_msmpeg4v3_decoder;
-extern const FFCodec ff_msmpeg4_crystalhd_decoder;
 extern const FFCodec ff_msp2_decoder;
 extern const FFCodec ff_msrle_encoder;
 extern const FFCodec ff_msrle_decoder;
@@ -365,7 +357,6 @@ extern const FFCodec ff_vbn_encoder;
 extern const FFCodec ff_vbn_decoder;
 extern const FFCodec ff_vble_decoder;
 extern const FFCodec ff_vc1_decoder;
-extern const FFCodec ff_vc1_crystalhd_decoder;
 extern const FFCodec ff_vc1image_decoder;
 extern const FFCodec ff_vc1_mmal_decoder;
 extern const FFCodec ff_vc1_qsv_decoder;
@@ -402,7 +393,6 @@ extern const FFCodec ff_wmv1_decoder;
 extern const FFCodec ff_wmv2_encoder;
 extern const FFCodec ff_wmv2_decoder;
 extern const FFCodec ff_wmv3_decoder;
-extern const FFCodec ff_wmv3_crystalhd_decoder;
 extern const FFCodec ff_wmv3image_decoder;
 extern const FFCodec ff_wnv1_decoder;
 extern const FFCodec ff_xan_wc3_decoder;
@@ -786,6 +776,8 @@ extern const FFCodec ff_libilbc_encoder;
 extern const FFCodec ff_libilbc_decoder;
 extern const FFCodec ff_libjxl_decoder;
 extern const FFCodec ff_libjxl_encoder;
+extern const FFCodec ff_liblc3_encoder;
+extern const FFCodec ff_liblc3_decoder;
 extern const FFCodec ff_libmp3lame_encoder;
 extern const FFCodec ff_libopencore_amrnb_encoder;
 extern const FFCodec ff_libopencore_amrnb_decoder;
diff --git a/media/ffvpx/libavcodec/atsc_a53.c b/media/ffvpx/libavcodec/atsc_a53.c
index 29ec71bc5f73c..1e9ea15ae0ed5 100644
--- a/media/ffvpx/libavcodec/atsc_a53.c
+++ b/media/ffvpx/libavcodec/atsc_a53.c
@@ -19,6 +19,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "libavutil/mem.h"
 #include "atsc_a53.h"
 #include "get_bits.h"
 
diff --git a/media/ffvpx/libavcodec/audio_frame_queue.c b/media/ffvpx/libavcodec/audio_frame_queue.c
index 08b4b368c7586..10b5d213929b4 100644
--- a/media/ffvpx/libavcodec/audio_frame_queue.c
+++ b/media/ffvpx/libavcodec/audio_frame_queue.c
@@ -20,7 +20,7 @@
  */
 
 #include "libavutil/attributes.h"
-#include "libavutil/common.h"
+#include "libavutil/mem.h"
 #include "audio_frame_queue.h"
 #include "encode.h"
 #include "libavutil/avassert.h"
diff --git a/media/ffvpx/libavcodec/av1.h b/media/ffvpx/libavcodec/av1.h
index 8704bc41c122f..94e88f848458d 100644
--- a/media/ffvpx/libavcodec/av1.h
+++ b/media/ffvpx/libavcodec/av1.h
@@ -58,6 +58,7 @@ enum {
 
 // Reference frames (section 6.10.24).
 enum {
+    AV1_REF_FRAME_NONE    = -1,
     AV1_REF_FRAME_INTRA   = 0,
     AV1_REF_FRAME_LAST    = 1,
     AV1_REF_FRAME_LAST2   = 2,
diff --git a/media/ffvpx/libavcodec/av1_parse.h b/media/ffvpx/libavcodec/av1_parse.h
index d0abd7ac7c3b2..2b8cce4835abf 100644
--- a/media/ffvpx/libavcodec/av1_parse.h
+++ b/media/ffvpx/libavcodec/av1_parse.h
@@ -30,6 +30,7 @@
 
 #include "av1.h"
 #include "get_bits.h"
+#include "leb.h"
 
 // OBU header fields + max leb128 length
 #define MAX_OBU_HEADER_SIZE (2 + 8)
@@ -88,19 +89,6 @@ int ff_av1_packet_split(AV1Packet *pkt, const uint8_t *buf, int length,
  */
 void ff_av1_packet_uninit(AV1Packet *pkt);
 
-static inline int64_t leb128(GetBitContext *gb) {
-    int64_t ret = 0;
-    int i;
-
-    for (i = 0; i < 8; i++) {
-        int byte = get_bits(gb, 8);
-        ret |= (int64_t)(byte & 0x7f) << (i * 7);
-        if (!(byte & 0x80))
-            break;
-    }
-    return ret;
-}
-
 static inline int parse_obu_header(const uint8_t *buf, int buf_size,
                                    int64_t *obu_size, int *start_pos, int *type,
                                    int *temporal_id, int *spatial_id)
@@ -129,7 +117,7 @@ static inline int parse_obu_header(const uint8_t *buf, int buf_size,
         *temporal_id = *spatial_id = 0;
     }
 
-    *obu_size  = has_size_flag ? leb128(&gb)
+    *obu_size  = has_size_flag ? get_leb128(&gb)
                                : buf_size - 1 - extension_flag;
 
     if (get_bits_left(&gb) < 0)
diff --git a/media/ffvpx/libavcodec/av1dec.c b/media/ffvpx/libavcodec/av1dec.c
index 7ffa7821e9a47..824725c031f8e 100644
--- a/media/ffvpx/libavcodec/av1dec.c
+++ b/media/ffvpx/libavcodec/av1dec.c
@@ -23,6 +23,7 @@
 #include "libavutil/hdr_dynamic_metadata.h"
 #include "libavutil/film_grain_params.h"
 #include "libavutil/mastering_display_metadata.h"
+#include "libavutil/mem.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
@@ -34,6 +35,7 @@
 #include "decode.h"
 #include "hwaccel_internal.h"
 #include "internal.h"
+#include "itut35.h"
 #include "hwconfig.h"
 #include "profiles.h"
 #include "refstruct.h"
@@ -620,6 +622,12 @@ static int get_pixel_format(AVCodecContext *avctx)
     *fmtp++ = pix_fmt;
     *fmtp = AV_PIX_FMT_NONE;
 
+    for (int i = 0; pix_fmts[i] != pix_fmt; i++)
+        if (pix_fmts[i] == avctx->pix_fmt) {
+            s->pix_fmt = pix_fmt;
+            return 1;
+        }
+
     ret = ff_get_format(avctx, pix_fmts);
 
     /**
@@ -715,6 +723,7 @@ static av_cold int av1_decode_free(AVCodecContext *avctx)
         av1_frame_unref(&s->cur_frame);
         av_frame_free(&s->cur_frame.f);
     }
+    av_buffer_unref(&s->seq_data_ref);
     ff_refstruct_unref(&s->seq_ref);
     ff_refstruct_unref(&s->header_ref);
     ff_refstruct_unref(&s->cll_ref);
@@ -727,6 +736,7 @@ static av_cold int av1_decode_free(AVCodecContext *avctx)
 
     ff_cbs_fragment_free(&s->current_obu);
     ff_cbs_close(&s->cbc);
+    ff_dovi_ctx_unref(&s->dovi);
 
     return 0;
 }
@@ -743,7 +753,7 @@ static int set_context_with_sequence(AVCodecContext *avctx,
     avctx->color_range =
         seq->color_config.color_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;
     avctx->color_primaries = seq->color_config.color_primaries;
-    avctx->colorspace = seq->color_config.color_primaries;
+    avctx->colorspace = seq->color_config.matrix_coefficients;
     avctx->color_trc = seq->color_config.transfer_characteristics;
 
     switch (seq->color_config.chroma_sample_position) {
@@ -771,6 +781,9 @@ static int set_context_with_sequence(AVCodecContext *avctx,
                                             seq->timing_info.num_units_in_display_tick,
                                             seq->timing_info.time_scale);
 
+    if (avctx->pix_fmt == AV_PIX_FMT_NONE)
+        avctx->pix_fmt = get_sw_pixel_format(avctx, seq);
+
     return 0;
 }
 
@@ -818,6 +831,7 @@ static av_cold int av1_decode_init(AVCodecContext *avctx)
 {
     AV1DecContext *s = avctx->priv_data;
     AV1RawSequenceHeader *seq;
+    const AVPacketSideData *sd;
     int ret;
 
     s->avctx = avctx;
@@ -869,12 +883,16 @@ static av_cold int av1_decode_init(AVCodecContext *avctx)
             goto end;
         }
 
-        avctx->pix_fmt = get_sw_pixel_format(avctx, seq);
-
         end:
         ff_cbs_fragment_reset(&s->current_obu);
     }
 
+    s->dovi.logctx = avctx;
+    s->dovi.dv_profile = 10; // default for AV1
+    sd = ff_get_coded_side_data(avctx, AV_PKT_DATA_DOVI_CONF);
+    if (sd && sd->size > 0)
+        ff_dovi_update_cfg(&s->dovi, (AVDOVIDecoderConfigurationRecord *) sd->data);
+
     return ret;
 }
 
@@ -928,13 +946,14 @@ static int export_itut_t35(AVCodecContext *avctx, AVFrame *frame,
                            const AV1RawMetadataITUTT35 *itut_t35)
 {
     GetByteContext gb;
+    AV1DecContext *s = avctx->priv_data;
     int ret, provider_code;
 
     bytestream2_init(&gb, itut_t35->payload, itut_t35->payload_size);
 
     provider_code = bytestream2_get_be16(&gb);
     switch (provider_code) {
-    case 0x31: { // atsc_provider_code
+    case ITU_T_T35_PROVIDER_CODE_ATSC: {
         uint32_t user_identifier = bytestream2_get_be32(&gb);
         switch (user_identifier) {
         case MKBETAG('G', 'A', '9', '4'): { // closed captions
@@ -946,8 +965,9 @@ static int export_itut_t35(AVCodecContext *avctx, AVFrame *frame,
             if (!ret)
                 break;
 
-            if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_A53_CC, buf))
-                av_buffer_unref(&buf);
+            ret = ff_frame_new_side_data_from_buf(avctx, frame, AV_FRAME_DATA_A53_CC, &buf, NULL);
+            if (ret < 0)
+                return ret;
 
             avctx->properties |= FF_CODEC_PROPERTY_CLOSED_CAPTIONS;
             break;
@@ -957,12 +977,12 @@ static int export_itut_t35(AVCodecContext *avctx, AVFrame *frame,
         }
         break;
     }
-    case 0x3C: { // smpte_provider_code
+    case ITU_T_T35_PROVIDER_CODE_SMTPE: {
         AVDynamicHDRPlus *hdrplus;
         int provider_oriented_code = bytestream2_get_be16(&gb);
         int application_identifier = bytestream2_get_byte(&gb);
 
-        if (itut_t35->itu_t_t35_country_code != 0xB5 ||
+        if (itut_t35->itu_t_t35_country_code != ITU_T_T35_COUNTRY_CODE_US ||
             provider_oriented_code != 1 || application_identifier != 4)
             break;
 
@@ -976,6 +996,24 @@ static int export_itut_t35(AVCodecContext *avctx, AVFrame *frame,
             return ret;
         break;
     }
+    case ITU_T_T35_PROVIDER_CODE_DOLBY: {
+        int provider_oriented_code = bytestream2_get_be32(&gb);
+        if (itut_t35->itu_t_t35_country_code != ITU_T_T35_COUNTRY_CODE_US ||
+            provider_oriented_code != 0x800)
+            break;
+
+        ret = ff_dovi_rpu_parse(&s->dovi, gb.buffer, gb.buffer_end - gb.buffer,
+                                avctx->err_recognition);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_WARNING, "Error parsing DOVI OBU.\n");
+            break; // ignore
+        }
+
+        ret = ff_dovi_attach_side_data(&s->dovi, frame);
+        if (ret < 0)
+            return ret;
+        break;
+    }
     default: // ignore unsupported provider codes
         break;
     }
@@ -990,31 +1028,39 @@ static int export_metadata(AVCodecContext *avctx, AVFrame *frame)
     int ret = 0;
 
     if (s->mdcv) {
-        AVMasteringDisplayMetadata *mastering = av_mastering_display_metadata_create_side_data(frame);
-        if (!mastering)
-            return AVERROR(ENOMEM);
+        AVMasteringDisplayMetadata *mastering;
 
-        for (int i = 0; i < 3; i++) {
-            mastering->display_primaries[i][0] = av_make_q(s->mdcv->primary_chromaticity_x[i], 1 << 16);
-            mastering->display_primaries[i][1] = av_make_q(s->mdcv->primary_chromaticity_y[i], 1 << 16);
-        }
-        mastering->white_point[0] = av_make_q(s->mdcv->white_point_chromaticity_x, 1 << 16);
-        mastering->white_point[1] = av_make_q(s->mdcv->white_point_chromaticity_y, 1 << 16);
+        ret = ff_decode_mastering_display_new(avctx, frame, &mastering);
+        if (ret < 0)
+            return ret;
+
+        if (mastering) {
+            for (int i = 0; i < 3; i++) {
+                mastering->display_primaries[i][0] = av_make_q(s->mdcv->primary_chromaticity_x[i], 1 << 16);
+                mastering->display_primaries[i][1] = av_make_q(s->mdcv->primary_chromaticity_y[i], 1 << 16);
+            }
+            mastering->white_point[0] = av_make_q(s->mdcv->white_point_chromaticity_x, 1 << 16);
+            mastering->white_point[1] = av_make_q(s->mdcv->white_point_chromaticity_y, 1 << 16);
 
-        mastering->max_luminance = av_make_q(s->mdcv->luminance_max, 1 << 8);
-        mastering->min_luminance = av_make_q(s->mdcv->luminance_min, 1 << 14);
+            mastering->max_luminance = av_make_q(s->mdcv->luminance_max, 1 << 8);
+            mastering->min_luminance = av_make_q(s->mdcv->luminance_min, 1 << 14);
 
-        mastering->has_primaries = 1;
-        mastering->has_luminance = 1;
+            mastering->has_primaries = 1;
+            mastering->has_luminance = 1;
+        }
     }
 
     if (s->cll) {
-        AVContentLightMetadata *light = av_content_light_metadata_create_side_data(frame);
-        if (!light)
-            return AVERROR(ENOMEM);
+        AVContentLightMetadata *light;
 
-        light->MaxCLL = s->cll->max_cll;
-        light->MaxFALL = s->cll->max_fall;
+        ret = ff_decode_content_light_new(avctx, frame, &light);
+        if (ret < 0)
+            return ret;
+
+        if (light) {
+            light->MaxCLL = s->cll->max_cll;
+            light->MaxFALL = s->cll->max_fall;
+        }
     }
 
     while (av_fifo_read(s->itut_t35_fifo, &itut_t35, 1) >= 0) {
@@ -1030,9 +1076,11 @@ static int export_film_grain(AVCodecContext *avctx, AVFrame *frame)
 {
     AV1DecContext *s = avctx->priv_data;
     const AV1RawFilmGrainParams *film_grain = &s->cur_frame.film_grain;
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(frame->format);
     AVFilmGrainParams *fgp;
     AVFilmGrainAOMParams *aom;
 
+    av_assert0(pixdesc);
     if (!film_grain->apply_grain)
         return 0;
 
@@ -1042,6 +1090,14 @@ static int export_film_grain(AVCodecContext *avctx, AVFrame *frame)
 
     fgp->type = AV_FILM_GRAIN_PARAMS_AV1;
     fgp->seed = film_grain->grain_seed;
+    fgp->width = frame->width;
+    fgp->height = frame->height;
+    fgp->color_range = frame->color_range;
+    fgp->color_primaries = frame->color_primaries;
+    fgp->color_trc = frame->color_trc;
+    fgp->color_space = frame->colorspace;
+    fgp->subsampling_x = pixdesc->log2_chroma_w;
+    fgp->subsampling_y = pixdesc->log2_chroma_h;
 
     aom = &fgp->codec.aom;
     aom->chroma_scaling_from_luma = film_grain->chroma_scaling_from_luma;
@@ -1174,6 +1230,23 @@ static int get_current_frame(AVCodecContext *avctx)
         avctx->skip_frame >= AVDISCARD_ALL)
         return 0;
 
+    if (s->pix_fmt == AV_PIX_FMT_NONE) {
+        ret = get_pixel_format(avctx);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to get pixel format.\n");
+            return ret;
+        }
+
+        if (!ret && FF_HW_HAS_CB(avctx, decode_params)) {
+            ret = FF_HW_CALL(avctx, decode_params, AV1_OBU_SEQUENCE_HEADER,
+                             s->seq_data_ref->data, s->seq_data_ref->size);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "HW accel decode params fail.\n");
+                return ret;
+            }
+        }
+    }
+
     ret = av1_frame_alloc(avctx, &s->cur_frame);
     if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR,
@@ -1200,14 +1273,27 @@ static int av1_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
         AV1RawOBU *obu = unit->content;
         const AV1RawOBUHeader *header;
 
+        av_log(avctx, AV_LOG_DEBUG, "OBU idx:%d, type:%d, content available:%d.\n", i, unit->type, !!obu);
+
+        if (unit->type == AV1_OBU_TILE_LIST) {
+            av_log(avctx, AV_LOG_ERROR, "Large scale tile decoding is unsupported.\n");
+            ret = AVERROR_PATCHWELCOME;
+            goto end;
+        }
+
         if (!obu)
             continue;
 
         header = &obu->header;
-        av_log(avctx, AV_LOG_DEBUG, "Obu idx:%d, obu type:%d.\n", i, unit->type);
 
         switch (unit->type) {
         case AV1_OBU_SEQUENCE_HEADER:
+            ret = av_buffer_replace(&s->seq_data_ref, unit->data_ref);
+            if (ret < 0)
+                goto end;
+
+            s->seq_data_ref->data = unit->data;
+            s->seq_data_ref->size = unit->data_size;
             ff_refstruct_replace(&s->seq_ref, unit->content_ref);
 
             s->raw_seq = &obu->obu.sequence_header;
@@ -1221,25 +1307,8 @@ static int av1_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
 
             s->operating_point_idc = s->raw_seq->operating_point_idc[s->operating_point];
 
-            if (s->pix_fmt == AV_PIX_FMT_NONE) {
-                ret = get_pixel_format(avctx);
-                if (ret < 0) {
-                    av_log(avctx, AV_LOG_ERROR,
-                           "Failed to get pixel format.\n");
-                    s->raw_seq = NULL;
-                    goto end;
-                }
-            }
+            s->pix_fmt = AV_PIX_FMT_NONE;
 
-            if (FF_HW_HAS_CB(avctx, decode_params)) {
-                ret = FF_HW_CALL(avctx, decode_params, unit->type,
-                                 unit->data, unit->data_size);
-                if (ret < 0) {
-                    av_log(avctx, AV_LOG_ERROR, "HW accel decode params fail.\n");
-                    s->raw_seq = NULL;
-                    goto end;
-                }
-            }
             break;
         case AV1_OBU_REDUNDANT_FRAME_HEADER:
             if (s->raw_frame_header)
@@ -1416,6 +1485,8 @@ static int av1_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
         ff_cbs_fragment_reset(&s->current_obu);
         s->nb_unit = 0;
     }
+    if (!ret && !frame->buf[0])
+        ret = AVERROR(EAGAIN);
 
     return ret;
 }
@@ -1500,7 +1571,7 @@ const FFCodec ff_av1_decoder = {
     .close                 = av1_decode_free,
     FF_CODEC_RECEIVE_FRAME_CB(av1_receive_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush                 = av1_decode_flush,
     .p.profiles            = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
     .p.priv_class          = &av1_class,
diff --git a/media/ffvpx/libavcodec/av1dec.h b/media/ffvpx/libavcodec/av1dec.h
index b6a0c08e48883..336eb613597cf 100644
--- a/media/ffvpx/libavcodec/av1dec.h
+++ b/media/ffvpx/libavcodec/av1dec.h
@@ -23,6 +23,7 @@
 
 #include <stdint.h>
 
+#include "libavutil/buffer.h"
 #include "libavutil/fifo.h"
 #include "libavutil/frame.h"
 #include "libavutil/pixfmt.h"
@@ -30,6 +31,7 @@
 #include "packet.h"
 #include "cbs.h"
 #include "cbs_av1.h"
+#include "dovi_rpu.h"
 
 typedef struct AV1Frame {
     AVFrame *f;
@@ -69,6 +71,7 @@ typedef struct AV1DecContext {
     CodedBitstreamFragment current_obu;
     AVPacket *pkt;
 
+    AVBufferRef *seq_data_ref;
     AV1RawOBU *seq_ref;    ///< RefStruct reference backing raw_seq
     AV1RawSequenceHeader *raw_seq;
     AV1RawOBU *header_ref; ///< RefStruct reference backing raw_frame_header
@@ -79,6 +82,7 @@ typedef struct AV1DecContext {
     AV1RawMetadataHDRCLL *cll;
     AV1RawOBU *mdcv_ref;   ///< RefStruct reference backing mdcv
     AV1RawMetadataHDRMDCV *mdcv;
+    DOVIContext dovi;
     AVFifo *itut_t35_fifo;
 
     uint16_t tile_num;
diff --git a/media/ffvpx/libavcodec/avcodec.c b/media/ffvpx/libavcodec/avcodec.c
index a6c8629f6ced3..525fe516bd2fc 100644
--- a/media/ffvpx/libavcodec/avcodec.c
+++ b/media/ffvpx/libavcodec/avcodec.c
@@ -54,6 +54,20 @@
  */
 #define FF_MAX_EXTRADATA_SIZE ((1 << 28) - AV_INPUT_BUFFER_PADDING_SIZE)
 
+const SideDataMap ff_sd_global_map[] = {
+    { AV_PKT_DATA_REPLAYGAIN ,                AV_FRAME_DATA_REPLAYGAIN },
+    { AV_PKT_DATA_DISPLAYMATRIX,              AV_FRAME_DATA_DISPLAYMATRIX },
+    { AV_PKT_DATA_SPHERICAL,                  AV_FRAME_DATA_SPHERICAL },
+    { AV_PKT_DATA_STEREO3D,                   AV_FRAME_DATA_STEREO3D },
+    { AV_PKT_DATA_AUDIO_SERVICE_TYPE,         AV_FRAME_DATA_AUDIO_SERVICE_TYPE },
+    { AV_PKT_DATA_MASTERING_DISPLAY_METADATA, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA },
+    { AV_PKT_DATA_CONTENT_LIGHT_LEVEL,        AV_FRAME_DATA_CONTENT_LIGHT_LEVEL },
+    { AV_PKT_DATA_ICC_PROFILE,                AV_FRAME_DATA_ICC_PROFILE },
+    { AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT,AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT },
+    { AV_PKT_DATA_NB },
+};
+
+
 int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2), void *arg, int *ret, int count, int size)
 {
     size_t i;
@@ -241,26 +255,6 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *code
         goto free_and_end;
     }
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    /* compat wrapper for old-style callers */
-    if (avctx->channel_layout && !avctx->channels)
-        avctx->channels = av_popcount64(avctx->channel_layout);
-
-    if ((avctx->channels && avctx->ch_layout.nb_channels != avctx->channels) ||
-        (avctx->channel_layout && (avctx->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
-                                   avctx->ch_layout.u.mask != avctx->channel_layout))) {
-        av_channel_layout_uninit(&avctx->ch_layout);
-        if (avctx->channel_layout) {
-            av_channel_layout_from_mask(&avctx->ch_layout, avctx->channel_layout);
-        } else {
-            avctx->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-        }
-        avctx->ch_layout.nb_channels = avctx->channels;
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     /* AV_CODEC_CAP_CHANNEL_CONF is a decoder-only flag; so the code below
      * in particular checks that nb_channels is set for all audio encoders. */
     if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && !avctx->ch_layout.nb_channels
@@ -282,11 +276,6 @@ FF_ENABLE_DEPRECATION_WARNINGS
     }
 
     avctx->frame_num = 0;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->frame_number = avctx->frame_num;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     avctx->codec_descriptor = avcodec_descriptor_get(avctx->codec_id);
 
     if ((avctx->codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL) &&
@@ -350,15 +339,6 @@ FF_ENABLE_DEPRECATION_WARNINGS
         if (!avctx->bit_rate)
             avctx->bit_rate = get_bit_rate(avctx);
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        /* update the deprecated fields for old-style callers */
-        avctx->channels = avctx->ch_layout.nb_channels;
-        avctx->channel_layout = avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
-                                avctx->ch_layout.u.mask : 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
         /* validate channel layout from the decoder */
         if ((avctx->ch_layout.nb_channels && !av_channel_layout_check(&avctx->ch_layout)) ||
             avctx->ch_layout.nb_channels > FF_SANE_NB_CHANNELS) {
@@ -377,7 +357,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
     return ret;
 free_and_end:
-    avcodec_close(avctx);
+    ff_codec_close(avctx);
     goto end;
 }
 
@@ -432,12 +412,12 @@ void avsubtitle_free(AVSubtitle *sub)
     memset(sub, 0, sizeof(*sub));
 }
 
-av_cold int avcodec_close(AVCodecContext *avctx)
+av_cold void ff_codec_close(AVCodecContext *avctx)
 {
     int i;
 
     if (!avctx)
-        return 0;
+        return;
 
     if (avcodec_is_open(avctx)) {
         AVCodecInternal *avci = avctx->internal;
@@ -497,9 +477,15 @@ av_cold int avcodec_close(AVCodecContext *avctx)
 
     avctx->codec = NULL;
     avctx->active_thread_type = 0;
+}
 
+#if FF_API_AVCODEC_CLOSE
+int avcodec_close(AVCodecContext *avctx)
+{
+    ff_codec_close(avctx);
     return 0;
 }
+#endif
 
 static const char *unknown_if_null(const char *str)
 {
@@ -619,6 +605,7 @@ void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
                        enc->width, enc->height);
 
             if (av_log_get_level() >= AV_LOG_VERBOSE &&
+                enc->coded_width && enc->coded_height &&
                 (enc->width != enc->coded_width ||
                  enc->height != enc->coded_height))
                 av_bprintf(&bprint, " (%dx%d)",
diff --git a/media/ffvpx/libavcodec/avcodec.h b/media/ffvpx/libavcodec/avcodec.h
index 7fb44e28f4581..83dc487251cf7 100644
--- a/media/ffvpx/libavcodec/avcodec.h
+++ b/media/ffvpx/libavcodec/avcodec.h
@@ -187,12 +187,16 @@ struct AVCodecParameters;
  * @{
  */
 
+#if FF_API_BUFFER_MIN_SIZE
 /**
  * @ingroup lavc_encoding
  * minimum encoding buffer size
  * Used to avoid some checks during header writing.
+ * @deprecated Unused: avcodec_receive_packet() does not work
+ *             with preallocated packet buffers.
  */
 #define AV_INPUT_BUFFER_MIN_SIZE 16384
+#endif
 
 /**
  * @ingroup lavc_encoding
@@ -490,29 +494,6 @@ typedef struct AVCodecContext {
      */
     int64_t bit_rate;
 
-    /**
-     * number of bits the bitstream is allowed to diverge from the reference.
-     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
-     * - encoding: Set by user; unused for constant quantizer encoding.
-     * - decoding: unused
-     */
-    int bit_rate_tolerance;
-
-    /**
-     * Global quality for codecs which cannot change it per frame.
-     * This should be proportional to MPEG-1/2/4 qscale.
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
-    int global_quality;
-
-    /**
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
-    int compression_level;
-#define FF_COMPRESSION_DEFAULT -1
-
     /**
      * AV_CODEC_FLAG_*.
      * - encoding: Set by user.
@@ -562,6 +543,22 @@ typedef struct AVCodecContext {
      */
     AVRational time_base;
 
+    /**
+     * Timebase in which pkt_dts/pts and AVPacket.dts/pts are expressed.
+     * - encoding: unused.
+     * - decoding: set by user.
+     */
+    AVRational pkt_timebase;
+
+    /**
+     * - decoding: For codecs that store a framerate value in the compressed
+     *             bitstream, the decoder may export it here. { 0, 1} when
+     *             unknown.
+     * - encoding: May be used to signal the framerate of CFR content to an
+     *             encoder.
+     */
+    AVRational framerate;
+
 #if FF_API_TICKS_PER_FRAME
     /**
      * For some codecs, the time base is closer to the field rate than the frame rate.
@@ -636,11 +633,13 @@ typedef struct AVCodecContext {
     int coded_width, coded_height;
 
     /**
-     * the number of pictures in a group of pictures, or 0 for intra_only
+     * sample aspect ratio (0 if unknown)
+     * That is the width of a pixel divided by the height of the pixel.
+     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
      * - encoding: Set by user.
-     * - decoding: unused
+     * - decoding: Set by libavcodec.
      */
-    int gop_size;
+    AVRational sample_aspect_ratio;
 
     /**
      * Pixel format, see AV_PIX_FMT_xxx.
@@ -657,6 +656,82 @@ typedef struct AVCodecContext {
      */
     enum AVPixelFormat pix_fmt;
 
+    /**
+     * Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
+     * - encoding: unused.
+     * - decoding: Set by libavcodec before calling get_format()
+     */
+    enum AVPixelFormat sw_pix_fmt;
+
+    /**
+     * Chromaticity coordinates of the source primaries.
+     * - encoding: Set by user
+     * - decoding: Set by libavcodec
+     */
+    enum AVColorPrimaries color_primaries;
+
+    /**
+     * Color Transfer Characteristic.
+     * - encoding: Set by user
+     * - decoding: Set by libavcodec
+     */
+    enum AVColorTransferCharacteristic color_trc;
+
+    /**
+     * YUV colorspace type.
+     * - encoding: Set by user
+     * - decoding: Set by libavcodec
+     */
+    enum AVColorSpace colorspace;
+
+    /**
+     * MPEG vs JPEG YUV range.
+     * - encoding: Set by user to override the default output color range value,
+     *   If not specified, libavcodec sets the color range depending on the
+     *   output format.
+     * - decoding: Set by libavcodec, can be set by the user to propagate the
+     *   color range to components reading from the decoder context.
+     */
+    enum AVColorRange color_range;
+
+    /**
+     * This defines the location of chroma samples.
+     * - encoding: Set by user
+     * - decoding: Set by libavcodec
+     */
+    enum AVChromaLocation chroma_sample_location;
+
+    /** Field order
+     * - encoding: set by libavcodec
+     * - decoding: Set by user.
+     */
+    enum AVFieldOrder field_order;
+
+    /**
+     * number of reference frames
+     * - encoding: Set by user.
+     * - decoding: Set by lavc.
+     */
+    int refs;
+
+    /**
+     * Size of the frame reordering buffer in the decoder.
+     * For MPEG-2 it is 1 IPB or 0 low delay IP.
+     * - encoding: Set by libavcodec.
+     * - decoding: Set by libavcodec.
+     */
+    int has_b_frames;
+
+    /**
+     * slice flags
+     * - encoding: unused
+     * - decoding: Set by user.
+     */
+    int slice_flags;
+#define SLICE_FLAG_CODED_ORDER    0x0001 ///< draw_horiz_band() is called in coded order instead of display
+#define SLICE_FLAG_ALLOW_FIELD    0x0002 ///< allow draw_horiz_band() with field slices (MPEG-2 field pics)
+#define SLICE_FLAG_ALLOW_PLANE    0x0004 ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
+
     /**
      * If non NULL, 'draw_horiz_band' is called by the libavcodec
      * decoder to draw a horizontal band. It improves cache usage. Not
@@ -735,14 +810,6 @@ typedef struct AVCodecContext {
      */
     float b_quant_offset;
 
-    /**
-     * Size of the frame reordering buffer in the decoder.
-     * For MPEG-2 it is 1 IPB or 0 low delay IP.
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by libavcodec.
-     */
-    int has_b_frames;
-
     /**
      * qscale factor between P- and I-frames
      * If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
@@ -794,32 +861,12 @@ typedef struct AVCodecContext {
      */
     float dark_masking;
 
-#if FF_API_SLICE_OFFSET
-    /**
-     * slice count
-     * - encoding: Set by libavcodec.
-     * - decoding: Set by user (or 0).
-     */
-    attribute_deprecated
-    int slice_count;
-
-    /**
-     * slice offsets in the frame in bytes
-     * - encoding: Set/allocated by libavcodec.
-     * - decoding: Set/allocated by user (or NULL).
-     */
-    attribute_deprecated
-    int *slice_offset;
-#endif
-
     /**
-     * sample aspect ratio (0 if unknown)
-     * That is the width of a pixel divided by the height of the pixel.
-     * Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
+     * noise vs. sse weight for the nsse comparison function
      * - encoding: Set by user.
-     * - decoding: Set by libavcodec.
+     * - decoding: unused
      */
-    AVRational sample_aspect_ratio;
+     int nsse_weight;
 
     /**
      * motion estimation comparison function
@@ -907,16 +954,6 @@ typedef struct AVCodecContext {
      */
     int me_range;
 
-    /**
-     * slice flags
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
-    int slice_flags;
-#define SLICE_FLAG_CODED_ORDER    0x0001 ///< draw_horiz_band() is called in coded order instead of display
-#define SLICE_FLAG_ALLOW_FIELD    0x0002 ///< allow draw_horiz_band() with field slices (MPEG-2 field pics)
-#define SLICE_FLAG_ALLOW_PLANE    0x0004 ///< allow draw_horiz_band() with 1 component at a time (SVQ1)
-
     /**
      * macroblock decision mode
      * - encoding: Set by user.
@@ -945,6 +982,13 @@ typedef struct AVCodecContext {
      */
     uint16_t *inter_matrix;
 
+    /**
+     * custom intra quantization matrix
+     * - encoding: Set by user, can be NULL.
+     * - decoding: unused.
+     */
+    uint16_t *chroma_intra_matrix;
+
     /**
      * precision of the intra DC coefficient - 8
      * - encoding: Set by user.
@@ -952,20 +996,6 @@ typedef struct AVCodecContext {
      */
     int intra_dc_precision;
 
-    /**
-     * Number of macroblock rows at the top which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
-    int skip_top;
-
-    /**
-     * Number of macroblock rows at the bottom which are skipped.
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
-    int skip_bottom;
-
     /**
      * minimum MB Lagrange multiplier
      * - encoding: Set by user.
@@ -994,11 +1024,11 @@ typedef struct AVCodecContext {
     int keyint_min;
 
     /**
-     * number of reference frames
+     * the number of pictures in a group of pictures, or 0 for intra_only
      * - encoding: Set by user.
-     * - decoding: Set by lavc.
+     * - decoding: unused
      */
-    int refs;
+    int gop_size;
 
     /**
      * Note: Value depends upon the compare function used for fullpel ME.
@@ -1007,44 +1037,6 @@ typedef struct AVCodecContext {
      */
     int mv0_threshold;
 
-    /**
-     * Chromaticity coordinates of the source primaries.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
-    enum AVColorPrimaries color_primaries;
-
-    /**
-     * Color Transfer Characteristic.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
-    enum AVColorTransferCharacteristic color_trc;
-
-    /**
-     * YUV colorspace type.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
-    enum AVColorSpace colorspace;
-
-    /**
-     * MPEG vs JPEG YUV range.
-     * - encoding: Set by user to override the default output color range value,
-     *   If not specified, libavcodec sets the color range depending on the
-     *   output format.
-     * - decoding: Set by libavcodec, can be set by the user to propagate the
-     *   color range to components reading from the decoder context.
-     */
-    enum AVColorRange color_range;
-
-    /**
-     * This defines the location of chroma samples.
-     * - encoding: Set by user
-     * - decoding: Set by libavcodec
-     */
-    enum AVChromaLocation chroma_sample_location;
-
     /**
      * Number of slices.
      * Indicates number of picture subdivisions. Used for parallelized
@@ -1054,24 +1046,9 @@ typedef struct AVCodecContext {
      */
     int slices;
 
-    /** Field order
-     * - encoding: set by libavcodec
-     * - decoding: Set by user.
-     */
-    enum AVFieldOrder field_order;
-
     /* audio only */
     int sample_rate; ///< samples per second
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * number of audio channels
-     * @deprecated use ch_layout.nb_channels
-     */
-    attribute_deprecated
-    int channels;
-#endif
-
     /**
      * audio sample format
      * - encoding: Set by user.
@@ -1079,6 +1056,14 @@ typedef struct AVCodecContext {
      */
     enum AVSampleFormat sample_fmt;  ///< sample format
 
+    /**
+     * Audio channel layout.
+     * - encoding: must be set by the caller, to one of AVCodec.ch_layouts.
+     * - decoding: may be set by the caller if known e.g. from the container.
+     *             The decoder can then override during decoding as needed.
+     */
+    AVChannelLayout ch_layout;
+
     /* The following data should not be initialized. */
     /**
      * Number of samples per channel in an audio frame.
@@ -1091,21 +1076,6 @@ typedef struct AVCodecContext {
      */
     int frame_size;
 
-#if FF_API_AVCTX_FRAME_NUMBER
-    /**
-     * Frame counter, set by libavcodec.
-     *
-     * - decoding: total number of frames returned from the decoder so far.
-     * - encoding: total number of frames passed to the encoder so far.
-     *
-     *   @note the counter is not incremented if encoding/decoding resulted in
-     *   an error.
-     *   @deprecated use frame_num instead
-     */
-    attribute_deprecated
-    int frame_number;
-#endif
-
     /**
      * number of bytes per packet if constant and known or 0
      * Used by some WAV based audio codecs.
@@ -1119,26 +1089,6 @@ typedef struct AVCodecContext {
      */
     int cutoff;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * Audio channel layout.
-     * - encoding: set by user.
-     * - decoding: set by user, may be overwritten by libavcodec.
-     * @deprecated use ch_layout
-     */
-    attribute_deprecated
-    uint64_t channel_layout;
-
-    /**
-     * Request decoder to use this channel layout if it can (0 for default)
-     * - encoding: unused
-     * - decoding: Set by user.
-     * @deprecated use "downmix" codec private option
-     */
-    attribute_deprecated
-    uint64_t request_channel_layout;
-#endif
-
     /**
      * Type of service that the audio stream conveys.
      * - encoding: Set by user.
@@ -1154,6 +1104,41 @@ typedef struct AVCodecContext {
      */
     enum AVSampleFormat request_sample_fmt;
 
+    /**
+     * Audio only. The number of "priming" samples (padding) inserted by the
+     * encoder at the beginning of the audio. I.e. this number of leading
+     * decoded samples must be discarded by the caller to get the original audio
+     * without leading padding.
+     *
+     * - decoding: unused
+     * - encoding: Set by libavcodec. The timestamps on the output packets are
+     *             adjusted by the encoder so that they always refer to the
+     *             first sample of the data actually contained in the packet,
+     *             including any added padding.  E.g. if the timebase is
+     *             1/samplerate and the timestamp of the first input sample is
+     *             0, the timestamp of the first output packet will be
+     *             -initial_padding.
+     */
+    int initial_padding;
+
+    /**
+     * Audio only. The amount of padding (in samples) appended by the encoder to
+     * the end of the audio. I.e. this number of decoded samples must be
+     * discarded by the caller from the end of the stream to get the original
+     * audio without any trailing padding.
+     *
+     * - decoding: unused
+     * - encoding: unused
+     */
+    int trailing_padding;
+
+    /**
+     * Number of samples to skip after a discontinuity
+     * - decoding: unused
+     * - encoding: set by libavcodec
+     */
+    int seek_preroll;
+
     /**
      * This callback is called at the beginning of each frame to get data
      * buffer(s) for it. There may be one contiguous buffer for all the data or
@@ -1237,6 +1222,29 @@ typedef struct AVCodecContext {
     int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);
 
     /* - encoding parameters */
+    /**
+     * number of bits the bitstream is allowed to diverge from the reference.
+     *           the reference can be CBR (for CBR pass1) or VBR (for pass2)
+     * - encoding: Set by user; unused for constant quantizer encoding.
+     * - decoding: unused
+     */
+    int bit_rate_tolerance;
+
+    /**
+     * Global quality for codecs which cannot change it per frame.
+     * This should be proportional to MPEG-1/2/4 qscale.
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int global_quality;
+
+    /**
+     * - encoding: Set by user.
+     * - decoding: unused
+     */
+    int compression_level;
+#define FF_COMPRESSION_DEFAULT -1
+
     float qcompress;  ///< amount of qscale change between easy & hard scenes (0.0-1.0)
     float qblur;      ///< amount of qscale smoothing over time (0.0-1.0)
 
@@ -1411,22 +1419,6 @@ typedef struct AVCodecContext {
      */
     int err_recognition;
 
-#if FF_API_REORDERED_OPAQUE
-    /**
-     * opaque 64-bit number (generally a PTS) that will be reordered and
-     * output in AVFrame.reordered_opaque
-     * - encoding: Set by libavcodec to the reordered_opaque of the input
-     *             frame corresponding to the last returned packet. Only
-     *             supported by encoders with the
-     *             AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability.
-     * - decoding: Set by user.
-     *
-     * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
-     */
-    attribute_deprecated
-    int64_t reordered_opaque;
-#endif
-
     /**
      * Hardware accelerator in use
      * - encoding: unused.
@@ -1458,6 +1450,75 @@ typedef struct AVCodecContext {
      */
     void *hwaccel_context;
 
+    /**
+     * A reference to the AVHWFramesContext describing the input (for encoding)
+     * or output (decoding) frames. The reference is set by the caller and
+     * afterwards owned (and freed) by libavcodec - it should never be read by
+     * the caller after being set.
+     *
+     * - decoding: This field should be set by the caller from the get_format()
+     *             callback. The previous reference (if any) will always be
+     *             unreffed by libavcodec before the get_format() call.
+     *
+     *             If the default get_buffer2() is used with a hwaccel pixel
+     *             format, then this AVHWFramesContext will be used for
+     *             allocating the frame buffers.
+     *
+     * - encoding: For hardware encoders configured to use a hwaccel pixel
+     *             format, this field should be set by the caller to a reference
+     *             to the AVHWFramesContext describing input frames.
+     *             AVHWFramesContext.format must be equal to
+     *             AVCodecContext.pix_fmt.
+     *
+     *             This field should be set before avcodec_open2() is called.
+     */
+    AVBufferRef *hw_frames_ctx;
+
+    /**
+     * A reference to the AVHWDeviceContext describing the device which will
+     * be used by a hardware encoder/decoder.  The reference is set by the
+     * caller and afterwards owned (and freed) by libavcodec.
+     *
+     * This should be used if either the codec device does not require
+     * hardware frames or any that are used are to be allocated internally by
+     * libavcodec.  If the user wishes to supply any of the frames used as
+     * encoder input or decoder output then hw_frames_ctx should be used
+     * instead.  When hw_frames_ctx is set in get_format() for a decoder, this
+     * field will be ignored while decoding the associated stream segment, but
+     * may again be used on a following one after another get_format() call.
+     *
+     * For both encoders and decoders this field should be set before
+     * avcodec_open2() is called and must not be written to thereafter.
+     *
+     * Note that some decoders may require this field to be set initially in
+     * order to support hw_frames_ctx at all - in that case, all frames
+     * contexts used must be created on the same device.
+     */
+    AVBufferRef *hw_device_ctx;
+
+    /**
+     * Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
+     * decoding (if active).
+     * - encoding: unused
+     * - decoding: Set by user (either before avcodec_open2(), or in the
+     *             AVCodecContext.get_format callback)
+     */
+    int hwaccel_flags;
+
+    /**
+     * Video decoding only.  Sets the number of extra hardware frames which
+     * the decoder will allocate for use by the caller.  This must be set
+     * before avcodec_open2() is called.
+     *
+     * Some hardware decoders require all frames that they will use for
+     * output to be defined in advance before decoding starts.  For such
+     * decoders, the hardware frame pool must therefore be of a fixed size.
+     * The extra frames set here are on top of any number that the decoder
+     * needs internally in order to operate normally (for example, frames
+     * used as reference pictures).
+     */
+    int extra_hw_frames;
+
     /**
      * error
      * - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
@@ -1496,10 +1557,6 @@ typedef struct AVCodecContext {
 #define FF_IDCT_SIMPLEARMV6   17
 #define FF_IDCT_FAAN          20
 #define FF_IDCT_SIMPLENEON    22
-#if FF_API_IDCT_NONE
-// formerly used by xvmc
-#define FF_IDCT_NONE          24
-#endif
 #define FF_IDCT_SIMPLEAUTO    128
 
     /**
@@ -1516,13 +1573,6 @@ typedef struct AVCodecContext {
      */
     int bits_per_raw_sample;
 
-    /**
-     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
-     * - encoding: unused
-     * - decoding: Set by user.
-     */
-     int lowres;
-
     /**
      * thread count
      * is used to decide how many independent tasks should be passed to execute()
@@ -1580,13 +1630,6 @@ typedef struct AVCodecContext {
      */
     int (*execute2)(struct AVCodecContext *c, int (*func)(struct AVCodecContext *c2, void *arg, int jobnr, int threadnr), void *arg2, int *ret, int count);
 
-    /**
-     * noise vs. sse weight for the nsse comparison function
-     * - encoding: Set by user.
-     * - decoding: unused
-     */
-     int nsse_weight;
-
     /**
      * profile
      * - encoding: Set by user.
@@ -1744,6 +1787,16 @@ typedef struct AVCodecContext {
 #define FF_LEVEL_UNKNOWN -99
 #endif
 
+    /**
+     * Properties of the stream that gets decoded
+     * - encoding: unused
+     * - decoding: set by libavcodec
+     */
+    unsigned properties;
+#define FF_CODEC_PROPERTY_LOSSLESS        0x00000001
+#define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002
+#define FF_CODEC_PROPERTY_FILM_GRAIN      0x00000004
+
     /**
      * Skip loop filtering for selected frames.
      * - encoding: unused
@@ -1766,55 +1819,39 @@ typedef struct AVCodecContext {
     enum AVDiscard skip_frame;
 
     /**
-     * Header containing style information for text subtitles.
-     * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
-     * [Script Info] and [V4+ Styles] section, plus the [Events] line and
-     * the Format line following. It shouldn't include any Dialogue line.
-     * - encoding: Set/allocated/freed by user (before avcodec_open2())
-     * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
-     */
-    uint8_t *subtitle_header;
-    int subtitle_header_size;
-
-    /**
-     * Audio only. The number of "priming" samples (padding) inserted by the
-     * encoder at the beginning of the audio. I.e. this number of leading
-     * decoded samples must be discarded by the caller to get the original audio
-     * without leading padding.
+     * Skip processing alpha if supported by codec.
+     * Note that if the format uses pre-multiplied alpha (common with VP6,
+     * and recommended due to better video quality/compression)
+     * the image will look as if alpha-blended onto a black background.
+     * However for formats that do not use pre-multiplied alpha
+     * there might be serious artefacts (though e.g. libswscale currently
+     * assumes pre-multiplied alpha anyway).
      *
-     * - decoding: unused
-     * - encoding: Set by libavcodec. The timestamps on the output packets are
-     *             adjusted by the encoder so that they always refer to the
-     *             first sample of the data actually contained in the packet,
-     *             including any added padding.  E.g. if the timebase is
-     *             1/samplerate and the timestamp of the first input sample is
-     *             0, the timestamp of the first output packet will be
-     *             -initial_padding.
+     * - decoding: set by user
+     * - encoding: unused
      */
-    int initial_padding;
+    int skip_alpha;
 
     /**
-     * - decoding: For codecs that store a framerate value in the compressed
-     *             bitstream, the decoder may export it here. { 0, 1} when
-     *             unknown.
-     * - encoding: May be used to signal the framerate of CFR content to an
-     *             encoder.
+     * Number of macroblock rows at the top which are skipped.
+     * - encoding: unused
+     * - decoding: Set by user.
      */
-    AVRational framerate;
+    int skip_top;
 
     /**
-     * Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
-     * - encoding: unused.
-     * - decoding: Set by libavcodec before calling get_format()
+     * Number of macroblock rows at the bottom which are skipped.
+     * - encoding: unused
+     * - decoding: Set by user.
      */
-    enum AVPixelFormat sw_pix_fmt;
+    int skip_bottom;
 
     /**
-     * Timebase in which pkt_dts/pts and AVPacket.dts/pts are expressed.
-     * - encoding: unused.
-     * - decoding: set by user.
+     * low resolution decoding, 1-> 1/2 size, 2->1/4 size
+     * - encoding: unused
+     * - decoding: Set by user.
      */
-    AVRational pkt_timebase;
+     int lowres;
 
     /**
      * AVCodecDescriptor
@@ -1823,16 +1860,6 @@ typedef struct AVCodecContext {
      */
     const struct AVCodecDescriptor *codec_descriptor;
 
-    /**
-     * Current statistics for PTS correction.
-     * - decoding: maintained and used by libavcodec, not intended to be used by user apps
-     * - encoding: unused
-     */
-    int64_t pts_correction_num_faulty_pts; /// Number of incorrect PTS values so far
-    int64_t pts_correction_num_faulty_dts; /// Number of incorrect DTS values so far
-    int64_t pts_correction_last_pts;       /// PTS of the last frame
-    int64_t pts_correction_last_dts;       /// DTS of the last frame
-
     /**
      * Character encoding of the input subtitles file.
      * - decoding: set by user
@@ -1853,32 +1880,15 @@ typedef struct AVCodecContext {
 #define FF_SUB_CHARENC_MODE_IGNORE       2  ///< neither convert the subtitles, nor check them for valid UTF-8
 
     /**
-     * Skip processing alpha if supported by codec.
-     * Note that if the format uses pre-multiplied alpha (common with VP6,
-     * and recommended due to better video quality/compression)
-     * the image will look as if alpha-blended onto a black background.
-     * However for formats that do not use pre-multiplied alpha
-     * there might be serious artefacts (though e.g. libswscale currently
-     * assumes pre-multiplied alpha anyway).
-     *
-     * - decoding: set by user
-     * - encoding: unused
-     */
-    int skip_alpha;
-
-    /**
-     * Number of samples to skip after a discontinuity
-     * - decoding: unused
-     * - encoding: set by libavcodec
-     */
-    int seek_preroll;
-
-    /**
-     * custom intra quantization matrix
-     * - encoding: Set by user, can be NULL.
-     * - decoding: unused.
+     * Header containing style information for text subtitles.
+     * For SUBTITLE_ASS subtitle type, it should contain the whole ASS
+     * [Script Info] and [V4+ Styles] section, plus the [Events] line and
+     * the Format line following. It shouldn't include any Dialogue line.
+     * - encoding: Set/allocated/freed by user (before avcodec_open2())
+     * - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
      */
-    uint16_t *chroma_intra_matrix;
+    int subtitle_header_size;
+    uint8_t *subtitle_header;
 
     /**
      * dump format separator.
@@ -1896,16 +1906,6 @@ typedef struct AVCodecContext {
      */
     char *codec_whitelist;
 
-    /**
-     * Properties of the stream that gets decoded
-     * - encoding: unused
-     * - decoding: set by libavcodec
-     */
-    unsigned properties;
-#define FF_CODEC_PROPERTY_LOSSLESS        0x00000001
-#define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 0x00000002
-#define FF_CODEC_PROPERTY_FILM_GRAIN      0x00000004
-
     /**
      * Additional data associated with the entire coded stream.
      *
@@ -1916,39 +1916,14 @@ typedef struct AVCodecContext {
     int            nb_coded_side_data;
 
     /**
-     * A reference to the AVHWFramesContext describing the input (for encoding)
-     * or output (decoding) frames. The reference is set by the caller and
-     * afterwards owned (and freed) by libavcodec - it should never be read by
-     * the caller after being set.
-     *
-     * - decoding: This field should be set by the caller from the get_format()
-     *             callback. The previous reference (if any) will always be
-     *             unreffed by libavcodec before the get_format() call.
-     *
-     *             If the default get_buffer2() is used with a hwaccel pixel
-     *             format, then this AVHWFramesContext will be used for
-     *             allocating the frame buffers.
-     *
-     * - encoding: For hardware encoders configured to use a hwaccel pixel
-     *             format, this field should be set by the caller to a reference
-     *             to the AVHWFramesContext describing input frames.
-     *             AVHWFramesContext.format must be equal to
-     *             AVCodecContext.pix_fmt.
-     *
-     *             This field should be set before avcodec_open2() is called.
-     */
-    AVBufferRef *hw_frames_ctx;
-
-    /**
-     * Audio only. The amount of padding (in samples) appended by the encoder to
-     * the end of the audio. I.e. this number of decoded samples must be
-     * discarded by the caller from the end of the stream to get the original
-     * audio without any trailing padding.
+     * Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of
+     * metadata exported in frame, packet, or coded stream side data by
+     * decoders and encoders.
      *
-     * - decoding: unused
-     * - encoding: unused
+     * - decoding: set by user
+     * - encoding: set by user
      */
-    int trailing_padding;
+    int export_side_data;
 
     /**
      * The number of pixels per image to maximally accept.
@@ -1958,37 +1933,6 @@ typedef struct AVCodecContext {
      */
     int64_t max_pixels;
 
-    /**
-     * A reference to the AVHWDeviceContext describing the device which will
-     * be used by a hardware encoder/decoder.  The reference is set by the
-     * caller and afterwards owned (and freed) by libavcodec.
-     *
-     * This should be used if either the codec device does not require
-     * hardware frames or any that are used are to be allocated internally by
-     * libavcodec.  If the user wishes to supply any of the frames used as
-     * encoder input or decoder output then hw_frames_ctx should be used
-     * instead.  When hw_frames_ctx is set in get_format() for a decoder, this
-     * field will be ignored while decoding the associated stream segment, but
-     * may again be used on a following one after another get_format() call.
-     *
-     * For both encoders and decoders this field should be set before
-     * avcodec_open2() is called and must not be written to thereafter.
-     *
-     * Note that some decoders may require this field to be set initially in
-     * order to support hw_frames_ctx at all - in that case, all frames
-     * contexts used must be created on the same device.
-     */
-    AVBufferRef *hw_device_ctx;
-
-    /**
-     * Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
-     * decoding (if active).
-     * - encoding: unused
-     * - decoding: Set by user (either before avcodec_open2(), or in the
-     *             AVCodecContext.get_format callback)
-     */
-    int hwaccel_flags;
-
     /**
      * Video decoding only. Certain video codecs support cropping, meaning that
      * only a sub-rectangle of the decoded frame is intended for display.  This
@@ -2016,20 +1960,6 @@ typedef struct AVCodecContext {
      */
     int apply_cropping;
 
-    /*
-     * Video decoding only.  Sets the number of extra hardware frames which
-     * the decoder will allocate for use by the caller.  This must be set
-     * before avcodec_open2() is called.
-     *
-     * Some hardware decoders require all frames that they will use for
-     * output to be defined in advance before decoding starts.  For such
-     * decoders, the hardware frame pool must therefore be of a fixed size.
-     * The extra frames set here are on top of any number that the decoder
-     * needs internally in order to operate normally (for example, frames
-     * used as reference pictures).
-     */
-    int extra_hw_frames;
-
     /**
      * The percentage of damaged samples to discard a frame.
      *
@@ -2046,16 +1976,6 @@ typedef struct AVCodecContext {
      */
     int64_t max_samples;
 
-    /**
-     * Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of
-     * metadata exported in frame, packet, or coded stream side data by
-     * decoders and encoders.
-     *
-     * - decoding: set by user
-     * - encoding: set by user
-     */
-    int export_side_data;
-
     /**
      * This callback is called at the beginning of each packet to get a data
      * buffer for it.
@@ -2098,14 +2018,6 @@ typedef struct AVCodecContext {
      */
     int (*get_encode_buffer)(struct AVCodecContext *s, AVPacket *pkt, int flags);
 
-    /**
-     * Audio channel layout.
-     * - encoding: must be set by the caller, to one of AVCodec.ch_layouts.
-     * - decoding: may be set by the caller if known e.g. from the container.
-     *             The decoder can then override during decoding as needed.
-     */
-    AVChannelLayout ch_layout;
-
     /**
      * Frame counter, set by libavcodec.
      *
@@ -2116,6 +2028,53 @@ typedef struct AVCodecContext {
      *   an error.
      */
     int64_t frame_num;
+
+    /**
+     * Decoding only. May be set by the caller before avcodec_open2() to an
+     * av_malloc()'ed array (or via AVOptions). Owned and freed by the decoder
+     * afterwards.
+     *
+     * Side data attached to decoded frames may come from several sources:
+     * 1. coded_side_data, which the decoder will for certain types translate
+     *    from packet-type to frame-type and attach to frames;
+     * 2. side data attached to an AVPacket sent for decoding (same
+     *    considerations as above);
+     * 3. extracted from the coded bytestream.
+     * The first two cases are supplied by the caller and typically come from a
+     * container.
+     *
+     * This array configures decoder behaviour in cases when side data of the
+     * same type is present both in the coded bytestream and in the
+     * user-supplied side data (items 1. and 2. above). In all cases, at most
+     * one instance of each side data type will be attached to output frames. By
+     * default it will be the bytestream side data. Adding an
+     * AVPacketSideDataType value to this array will flip the preference for
+     * this type, thus making the decoder prefer user-supplied side data over
+     * bytestream. In case side data of the same type is present both in
+     * coded_data and attacked to a packet, the packet instance always has
+     * priority.
+     *
+     * The array may also contain a single -1, in which case the preference is
+     * switched for all side data types.
+     */
+    int        *side_data_prefer_packet;
+    /**
+     * Number of entries in side_data_prefer_packet.
+     */
+    unsigned nb_side_data_prefer_packet;
+
+    /**
+     * Array containing static side data, such as HDR10 CLL / MDCV structures.
+     * Side data entries should be allocated by usage of helpers defined in
+     * libavutil/frame.h.
+     *
+     * - encoding: may be set by user before calling avcodec_open2() for
+     *             encoder configuration. Afterwards owned and freed by the
+     *             encoder.
+     * - decoding: unused
+     */
+    AVFrameSideData  **decoded_side_data;
+    int             nb_decoded_side_data;
 } AVCodecContext;
 
 /**
@@ -2252,6 +2211,7 @@ typedef struct AVSubtitleRect {
     uint8_t *data[4];
     int linesize[4];
 
+    int flags;
     enum AVSubtitleType type;
 
     char *text;                     ///< 0 terminated plain UTF-8 text
@@ -2262,8 +2222,6 @@ typedef struct AVSubtitleRect {
      * struct.
      */
     char *ass;
-
-    int flags;
 } AVSubtitleRect;
 
 typedef struct AVSubtitle {
@@ -2411,6 +2369,7 @@ int avcodec_parameters_to_context(AVCodecContext *codec,
  */
 int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options);
 
+#if FF_API_AVCODEC_CLOSE
 /**
  * Close a given AVCodecContext and free all the data associated with it
  * (but not the AVCodecContext itself).
@@ -2419,12 +2378,14 @@ int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **op
  * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
  * codec. Subsequent calls will do nothing.
  *
- * @note Do not use this function. Use avcodec_free_context() to destroy a
+ * @deprecated Do not use this function. Use avcodec_free_context() to destroy a
  * codec context (either open or closed). Opening and closing a codec context
  * multiple times is not supported anymore -- use multiple codec contexts
  * instead.
  */
+attribute_deprecated
 int avcodec_close(AVCodecContext *avctx);
+#endif
 
 /**
  * Free all allocated data in the given subtitle struct.
@@ -2475,34 +2436,6 @@ void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height);
 void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height,
                                int linesize_align[AV_NUM_DATA_POINTERS]);
 
-#ifdef FF_API_AVCODEC_CHROMA_POS
-/**
- * Converts AVChromaLocation to swscale x/y chroma position.
- *
- * The positions represent the chroma (0,0) position in a coordinates system
- * with luma (0,0) representing the origin and luma(1,1) representing 256,256
- *
- * @param xpos  horizontal chroma sample position
- * @param ypos  vertical   chroma sample position
- * @deprecated Use av_chroma_location_enum_to_pos() instead.
- */
- attribute_deprecated
-int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos);
-
-/**
- * Converts swscale x/y chroma position to AVChromaLocation.
- *
- * The positions represent the chroma (0,0) position in a coordinates system
- * with luma (0,0) representing the origin and luma(1,1) representing 256,256
- *
- * @param xpos  horizontal chroma sample position
- * @param ypos  vertical   chroma sample position
- * @deprecated Use av_chroma_location_pos_to_enum() instead.
- */
- attribute_deprecated
-enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos);
-#endif
-
 /**
  * Decode a subtitle message.
  * Return a negative value on error, otherwise return the number of bytes used.
diff --git a/media/ffvpx/libavcodec/avcodec.symbols b/media/ffvpx/libavcodec/avcodec.symbols
index 43d24bf39bc44..c5365cb7af3cb 100644
--- a/media/ffvpx/libavcodec/avcodec.symbols
+++ b/media/ffvpx/libavcodec/avcodec.symbols
@@ -9,31 +9,13 @@ av_get_bits_per_sample
 av_get_exact_bits_per_sample
 av_get_pcm_codec
 av_get_profile_name
-av_grow_packet
-av_init_packet
-av_new_packet
 av_packet_alloc
-av_packet_copy_props
-av_packet_free_side_data
-av_packet_from_data
-av_packet_get_side_data
-av_packet_move_ref
-av_packet_new_side_data
-av_packet_pack_dictionary
-av_packet_ref
-av_packet_rescale_ts
-av_packet_shrink_side_data
-av_packet_side_data_name
-av_packet_unpack_dictionary
 av_packet_unref
 av_packet_free
+av_init_packet
 av_parser_close
 av_parser_init
 av_parser_parse2
-av_rdft_calc
-av_rdft_end
-av_rdft_init
-av_shrink_packet
 av_vorbis_parse_frame
 av_vorbis_parse_frame_flags
 av_vorbis_parse_free
@@ -43,7 +25,6 @@ av_xiphlacing
 avcodec_align_dimensions
 avcodec_align_dimensions2
 avcodec_alloc_context3
-avcodec_chroma_pos_to_enum
 avcodec_close
 avcodec_configuration
 avcodec_decode_subtitle2
@@ -54,7 +35,6 @@ avcodec_default_get_format
 avcodec_descriptor_get
 avcodec_descriptor_get_by_name
 avcodec_descriptor_next
-avcodec_enum_to_chroma_pos
 avcodec_fill_audio_frame
 avcodec_find_decoder
 avcodec_find_decoder_by_name
diff --git a/media/ffvpx/libavcodec/avcodec_internal.h b/media/ffvpx/libavcodec/avcodec_internal.h
index 9b93ff3d819ab..0a024378ae720 100644
--- a/media/ffvpx/libavcodec/avcodec_internal.h
+++ b/media/ffvpx/libavcodec/avcodec_internal.h
@@ -25,8 +25,22 @@
 #ifndef AVCODEC_AVCODEC_INTERNAL_H
 #define AVCODEC_AVCODEC_INTERNAL_H
 
+#include "libavutil/frame.h"
+
+#include "packet.h"
+
 struct AVCodecContext;
-struct AVFrame;
+
+typedef struct SideDataMap {
+    enum AVPacketSideDataType packet;
+    enum AVFrameSideDataType frame;
+} SideDataMap;
+
+/**
+ * A map between packet and frame side data types.
+ * Terminated with an entry where packet=AV_PKT_DATA_NB.
+ */
+extern const SideDataMap ff_sd_global_map[];
 
 /**
  * avcodec_receive_frame() implementation for decoders.
@@ -56,4 +70,6 @@ void ff_encode_flush_buffers(struct AVCodecContext *avctx);
 struct AVCodecInternal *ff_decode_internal_alloc(void);
 struct AVCodecInternal *ff_encode_internal_alloc(void);
 
+void ff_codec_close(struct AVCodecContext *avctx);
+
 #endif // AVCODEC_AVCODEC_INTERNAL_H
diff --git a/media/ffvpx/libavcodec/avdct.c b/media/ffvpx/libavcodec/avdct.c
index e8fa41f73be3a..f995e73eab44d 100644
--- a/media/ffvpx/libavcodec/avdct.c
+++ b/media/ffvpx/libavcodec/avdct.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "libavutil/mem.h"
 #include "avcodec.h"
 #include "idctdsp.h"
 #include "fdctdsp.h"
@@ -33,29 +34,29 @@
 #define D AV_OPT_FLAG_DECODING_PARAM
 
 static const AVOption avdct_options[] = {
-{"dct", "DCT algorithm", OFFSET(dct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E, "dct"},
-{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_AUTO }, INT_MIN, INT_MAX, V|E, "dct"},
-{"fastint", "fast integer (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FASTINT }, INT_MIN, INT_MAX, V|E, "dct"},
-{"int", "accurate integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_INT }, INT_MIN, INT_MAX, V|E, "dct"},
-{"mmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_MMX }, INT_MIN, INT_MAX, V|E, "dct"},
-{"altivec", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_ALTIVEC }, INT_MIN, INT_MAX, V|E, "dct"},
-{"faan", "floating point AAN DCT (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FAAN }, INT_MIN, INT_MAX, V|E, "dct"},
-
-{"idct", "select IDCT implementation", OFFSET(idct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E|D, "idct"},
-{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_AUTO }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"int", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_INT }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simple", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLE }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplemmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEMMX }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"arm", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ARM }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"altivec", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ALTIVEC }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearm", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARM }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearmv5te", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV5TE }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearmv6", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV6 }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simpleneon", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLENEON }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"xvid", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"xvidmmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"faani", "floating point AAN IDCT (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_FAAN }, INT_MIN, INT_MAX, V|D|E, "idct"},
-{"simpleauto", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEAUTO }, INT_MIN, INT_MAX, V|E|D, "idct"},
+{"dct", "DCT algorithm", OFFSET(dct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E, .unit = "dct"},
+{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_AUTO }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"fastint", "fast integer (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FASTINT }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"int", "accurate integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_INT }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"mmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_MMX }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"altivec", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_ALTIVEC }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"faan", "floating point AAN DCT (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FAAN }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+
+{"idct", "select IDCT implementation", OFFSET(idct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E|D, .unit = "idct"},
+{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_AUTO }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"int", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_INT }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simple", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLE }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplemmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEMMX }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"arm", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ARM }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"altivec", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ALTIVEC }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearm", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARM }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearmv5te", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV5TE }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearmv6", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV6 }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simpleneon", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLENEON }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"xvid", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"xvidmmx", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"faani", "floating point AAN IDCT (experimental / for debugging)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_FAAN }, INT_MIN, INT_MAX, V|D|E, .unit = "idct"},
+{"simpleauto", "experimental / for debugging", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEAUTO }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
 
 {"bits_per_sample", "", OFFSET(bits_per_sample), AV_OPT_TYPE_INT, {.i64 = 8 }, 0, 14, 0,},
 {NULL},
diff --git a/media/ffvpx/libavcodec/avpicture.c b/media/ffvpx/libavcodec/avpicture.c
deleted file mode 100644
index 56435f4fc945c..0000000000000
--- a/media/ffvpx/libavcodec/avpicture.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * AVPicture management routines
- * Copyright (c) 2001, 2002, 2003 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * AVPicture management routines
- */
-
-#include "avcodec.h"
-#include "internal.h"
-#include "libavutil/common.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/internal.h"
-#include "libavutil/colorspace.h"
-
-#if FF_API_AVPICTURE
-FF_DISABLE_DEPRECATION_WARNINGS
-int avpicture_fill(AVPicture *picture, const uint8_t *ptr,
-                   enum AVPixelFormat pix_fmt, int width, int height)
-{
-    return av_image_fill_arrays(picture->data, picture->linesize,
-                                ptr, pix_fmt, width, height, 1);
-}
-
-int avpicture_layout(const AVPicture* src, enum AVPixelFormat pix_fmt, int width, int height,
-                     unsigned char *dest, int dest_size)
-{
-    return av_image_copy_to_buffer(dest, dest_size,
-                                   (const uint8_t * const*)src->data, src->linesize,
-                                   pix_fmt, width, height, 1);
-}
-
-int avpicture_get_size(enum AVPixelFormat pix_fmt, int width, int height)
-{
-    return av_image_get_buffer_size(pix_fmt, width, height, 1);
-}
-
-int avpicture_alloc(AVPicture *picture,
-                    enum AVPixelFormat pix_fmt, int width, int height)
-{
-    int ret = av_image_alloc(picture->data, picture->linesize,
-                             width, height, pix_fmt, 1);
-    if (ret < 0) {
-        memset(picture, 0, sizeof(AVPicture));
-        return ret;
-    }
-
-    return 0;
-}
-
-void avpicture_free(AVPicture *picture)
-{
-    av_freep(&picture->data[0]);
-}
-
-void av_picture_copy(AVPicture *dst, const AVPicture *src,
-                     enum AVPixelFormat pix_fmt, int width, int height)
-{
-    av_image_copy(dst->data, dst->linesize, (const uint8_t **)src->data,
-                  src->linesize, pix_fmt, width, height);
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif /* FF_API_AVPICTURE */
diff --git a/media/ffvpx/libavcodec/bitstream_filters.c b/media/ffvpx/libavcodec/bitstream_filters.c
index 1e9a676a3d277..12860c332b5c8 100644
--- a/media/ffvpx/libavcodec/bitstream_filters.c
+++ b/media/ffvpx/libavcodec/bitstream_filters.c
@@ -46,7 +46,6 @@ extern const FFBitStreamFilter ff_imx_dump_header_bsf;
 extern const FFBitStreamFilter ff_media100_to_mjpegb_bsf;
 extern const FFBitStreamFilter ff_mjpeg2jpeg_bsf;
 extern const FFBitStreamFilter ff_mjpega_dump_header_bsf;
-extern const FFBitStreamFilter ff_mp3_header_decompress_bsf;
 extern const FFBitStreamFilter ff_mpeg2_metadata_bsf;
 extern const FFBitStreamFilter ff_mpeg4_unpack_bframes_bsf;
 extern const FFBitStreamFilter ff_mov2textsub_bsf;
@@ -58,6 +57,7 @@ extern const FFBitStreamFilter ff_pgs_frame_merge_bsf;
 extern const FFBitStreamFilter ff_prores_metadata_bsf;
 extern const FFBitStreamFilter ff_remove_extradata_bsf;
 extern const FFBitStreamFilter ff_setts_bsf;
+extern const FFBitStreamFilter ff_showinfo_bsf;
 extern const FFBitStreamFilter ff_text2movsub_bsf;
 extern const FFBitStreamFilter ff_trace_headers_bsf;
 extern const FFBitStreamFilter ff_truehd_core_bsf;
diff --git a/media/ffvpx/libavcodec/blockdsp.h b/media/ffvpx/libavcodec/blockdsp.h
index d853adada2169..6d751d797b2a9 100644
--- a/media/ffvpx/libavcodec/blockdsp.h
+++ b/media/ffvpx/libavcodec/blockdsp.h
@@ -41,6 +41,7 @@ void ff_blockdsp_init(BlockDSPContext *c);
 void ff_blockdsp_init_alpha(BlockDSPContext *c);
 void ff_blockdsp_init_arm(BlockDSPContext *c);
 void ff_blockdsp_init_ppc(BlockDSPContext *c);
+void ff_blockdsp_init_riscv(BlockDSPContext *c);
 void ff_blockdsp_init_x86(BlockDSPContext *c);
 void ff_blockdsp_init_mips(BlockDSPContext *c);
 
diff --git a/media/ffvpx/libavcodec/av1_frame_split_bsf.c b/media/ffvpx/libavcodec/bsf/av1_frame_split.c
similarity index 100%
rename from media/ffvpx/libavcodec/av1_frame_split_bsf.c
rename to media/ffvpx/libavcodec/bsf/av1_frame_split.c
diff --git a/media/ffvpx/libavcodec/bsf/moz.build b/media/ffvpx/libavcodec/bsf/moz.build
new file mode 100644
index 0000000000000..28e71edbc8c2f
--- /dev/null
+++ b/media/ffvpx/libavcodec/bsf/moz.build
@@ -0,0 +1,21 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+#
+if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
+    SOURCES += [
+      'av1_frame_split.c',
+      'vp9_superframe_split.c',
+    ]
+
+SOURCES += [
+    'null.c',
+]
+
+LOCAL_INCLUDES += [ "../" ]
+
+FINAL_LIBRARY = 'mozavcodec'
+
+include('/media/ffvpx/ffvpxcommon.mozbuild')
diff --git a/media/ffvpx/libavcodec/null_bsf.c b/media/ffvpx/libavcodec/bsf/null.c
similarity index 100%
rename from media/ffvpx/libavcodec/null_bsf.c
rename to media/ffvpx/libavcodec/bsf/null.c
diff --git a/media/ffvpx/libavcodec/vp9_superframe_split_bsf.c b/media/ffvpx/libavcodec/bsf/vp9_superframe_split.c
similarity index 100%
rename from media/ffvpx/libavcodec/vp9_superframe_split_bsf.c
rename to media/ffvpx/libavcodec/bsf/vp9_superframe_split.c
diff --git a/media/ffvpx/libavcodec/cbs.c b/media/ffvpx/libavcodec/cbs.c
index de7b1361aaeb9..b26e39eab4d8f 100644
--- a/media/ffvpx/libavcodec/cbs.c
+++ b/media/ffvpx/libavcodec/cbs.c
@@ -23,6 +23,7 @@
 #include "libavutil/avassert.h"
 #include "libavutil/buffer.h"
 #include "libavutil/common.h"
+#include "libavutil/mem.h"
 #include "libavutil/opt.h"
 
 #include "avcodec.h"
diff --git a/media/ffvpx/libavcodec/cbs_av1.h b/media/ffvpx/libavcodec/cbs_av1.h
index a5402f069d33d..a027013bc72c0 100644
--- a/media/ffvpx/libavcodec/cbs_av1.h
+++ b/media/ffvpx/libavcodec/cbs_av1.h
@@ -427,6 +427,8 @@ typedef struct AV1ReferenceFrameState {
     int bit_depth;      // RefBitDepth
     int order_hint;     // RefOrderHint
 
+    int saved_order_hints[AV1_TOTAL_REFS_PER_FRAME]; // SavedOrderHints[ref]
+
     int8_t  loop_filter_ref_deltas[AV1_TOTAL_REFS_PER_FRAME];
     int8_t  loop_filter_mode_deltas[2];
     uint8_t feature_enabled[AV1_MAX_SEGMENTS][AV1_SEG_LVL_MAX];
@@ -464,6 +466,9 @@ typedef struct CodedBitstreamAV1Context {
     int tile_rows;
     int tile_num;
 
+    int order_hints[AV1_TOTAL_REFS_PER_FRAME];         // OrderHints
+    int ref_frame_sign_bias[AV1_TOTAL_REFS_PER_FRAME]; // RefFrameSignBias
+
     AV1ReferenceFrameState ref[AV1_NUM_REF_FRAMES];
 
     // AVOptions
diff --git a/media/ffvpx/libavcodec/cbs_av1_syntax_template.c b/media/ffvpx/libavcodec/cbs_av1_syntax_template.c
index 3be1f2d30f969..3f4b13a177108 100644
--- a/media/ffvpx/libavcodec/cbs_av1_syntax_template.c
+++ b/media/ffvpx/libavcodec/cbs_av1_syntax_template.c
@@ -360,7 +360,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
     int i, j;
 
     for (i = 0; i < AV1_REFS_PER_FRAME; i++)
-        ref_frame_idx[i] = -1;
+        ref_frame_idx[i] = AV1_REF_FRAME_NONE;
     ref_frame_idx[AV1_REF_FRAME_LAST - AV1_REF_FRAME_LAST] = current->last_frame_idx;
     ref_frame_idx[AV1_REF_FRAME_GOLDEN - AV1_REF_FRAME_LAST] = current->golden_frame_idx;
 
@@ -378,7 +378,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
     latest_order_hint = shifted_order_hints[current->last_frame_idx];
     earliest_order_hint = shifted_order_hints[current->golden_frame_idx];
 
-    ref = -1;
+    ref = AV1_REF_FRAME_NONE;
     for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         int hint = shifted_order_hints[i];
         if (!used_frame[i] && hint >= cur_frame_hint &&
@@ -392,7 +392,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
         used_frame[ref] = 1;
     }
 
-    ref = -1;
+    ref = AV1_REF_FRAME_NONE;
     for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         int hint = shifted_order_hints[i];
         if (!used_frame[i] && hint >= cur_frame_hint &&
@@ -406,7 +406,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
         used_frame[ref] = 1;
     }
 
-    ref = -1;
+    ref = AV1_REF_FRAME_NONE;
     for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         int hint = shifted_order_hints[i];
         if (!used_frame[i] && hint >= cur_frame_hint &&
@@ -423,7 +423,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
     for (i = 0; i < AV1_REFS_PER_FRAME - 2; i++) {
         int ref_frame = ref_frame_list[i];
         if (ref_frame_idx[ref_frame - AV1_REF_FRAME_LAST] < 0 ) {
-            ref = -1;
+            ref = AV1_REF_FRAME_NONE;
             for (j = 0; j < AV1_NUM_REF_FRAMES; j++) {
                 int hint = shifted_order_hints[j];
                 if (!used_frame[j] && hint < cur_frame_hint &&
@@ -439,7 +439,7 @@ static int FUNC(set_frame_refs)(CodedBitstreamContext *ctx, RWContext *rw,
         }
     }
 
-    ref = -1;
+    ref = AV1_REF_FRAME_NONE;
     for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
         int hint = shifted_order_hints[i];
         if (ref < 0 || hint < earliest_order_hint) {
@@ -1414,6 +1414,8 @@ static int FUNC(uncompressed_header)(CodedBitstreamContext *ctx, RWContext *rw,
             priv->ref[i].valid = 0;
             priv->ref[i].order_hint = 0;
         }
+        for (i = 0; i < AV1_REFS_PER_FRAME; i++)
+            priv->order_hints[i + AV1_REF_FRAME_LAST] = 0;
     }
 
     flag(disable_cdf_update);
@@ -1568,11 +1570,20 @@ static int FUNC(uncompressed_header)(CodedBitstreamContext *ctx, RWContext *rw,
         else
             flag(use_ref_frame_mvs);
 
-        infer(allow_intrabc, 0);
-    }
+        for (i = 0; i < AV1_REFS_PER_FRAME; i++) {
+            int ref_frame = AV1_REF_FRAME_LAST + i;
+            int hint = priv->ref[current->ref_frame_idx[i]].order_hint;
+            priv->order_hints[ref_frame] = hint;
+            if (!seq->enable_order_hint) {
+                priv->ref_frame_sign_bias[ref_frame] = 0;
+            } else {
+                priv->ref_frame_sign_bias[ref_frame] =
+                    cbs_av1_get_relative_dist(seq, hint,
+                                              current->order_hint) > 0;
+            }
+        }
 
-    if (!frame_is_intra) {
-        // Derive reference frame sign biases.
+        infer(allow_intrabc, 0);
     }
 
     if (seq->reduced_still_picture_header || current->disable_cdf_update)
@@ -1674,6 +1685,12 @@ static int FUNC(uncompressed_header)(CodedBitstreamContext *ctx, RWContext *rw,
                 .bit_depth      = priv->bit_depth,
                 .order_hint     = priv->order_hint,
             };
+
+            for (int j = 0; j < AV1_REFS_PER_FRAME; j++) {
+                priv->ref[i].saved_order_hints[j + AV1_REF_FRAME_LAST] =
+                    priv->order_hints[j + AV1_REF_FRAME_LAST];
+            }
+
             memcpy(priv->ref[i].loop_filter_ref_deltas, current->loop_filter_ref_deltas,
                    sizeof(current->loop_filter_ref_deltas));
             memcpy(priv->ref[i].loop_filter_mode_deltas, current->loop_filter_mode_deltas,
diff --git a/media/ffvpx/libavcodec/codec.h b/media/ffvpx/libavcodec/codec.h
index 8034f1a53c98d..6f9b42760d782 100644
--- a/media/ffvpx/libavcodec/codec.h
+++ b/media/ffvpx/libavcodec/codec.h
@@ -209,13 +209,6 @@ typedef struct AVCodec {
     const enum AVPixelFormat *pix_fmts;     ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
     const int *supported_samplerates;       ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
     const enum AVSampleFormat *sample_fmts; ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * @deprecated use ch_layouts instead
-     */
-    attribute_deprecated
-    const uint64_t *channel_layouts;         ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
-#endif
     const AVClass *priv_class;              ///< AVClass for the private context
     const AVProfile *profiles;              ///< array of recognized profiles, or NULL if unknown, array is terminated by {AV_PROFILE_UNKNOWN}
 
diff --git a/media/ffvpx/libavcodec/codec_desc.c b/media/ffvpx/libavcodec/codec_desc.c
index 033344304caa6..7dba61dc8b4e0 100644
--- a/media/ffvpx/libavcodec/codec_desc.c
+++ b/media/ffvpx/libavcodec/codec_desc.c
@@ -1470,15 +1470,6 @@ static const AVCodecDescriptor codec_descriptors[] = {
         .long_name = NULL_IF_CONFIG_SMALL("Avid Meridien Uncompressed"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
-#if FF_API_AYUV_CODECID
-    {
-        .id        = AV_CODEC_ID_AYUV,
-        .type      = AVMEDIA_TYPE_VIDEO,
-        .name      = "ayuv",
-        .long_name = NULL_IF_CONFIG_SMALL("Uncompressed packed MS 4:4:4:4"),
-        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
-    },
-#endif
     {
         .id        = AV_CODEC_ID_TARGA_Y216,
         .type      = AVMEDIA_TYPE_VIDEO,
@@ -3434,6 +3425,13 @@ static const AVCodecDescriptor codec_descriptors[] = {
         .long_name = NULL_IF_CONFIG_SMALL("QOA (Quite OK Audio)"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
     },
+    {
+        .id        = AV_CODEC_ID_LC3,
+        .type      = AVMEDIA_TYPE_AUDIO,
+        .name      = "lc3",
+        .long_name = NULL_IF_CONFIG_SMALL("LC3 (Low Complexity Communication Codec)"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
 
     /* subtitle codecs */
     {
diff --git a/media/ffvpx/libavcodec/codec_id.h b/media/ffvpx/libavcodec/codec_id.h
index d96e49430e546..0ab1e34a6179f 100644
--- a/media/ffvpx/libavcodec/codec_id.h
+++ b/media/ffvpx/libavcodec/codec_id.h
@@ -253,9 +253,6 @@ enum AVCodecID {
     AV_CODEC_ID_AVRP,
     AV_CODEC_ID_012V,
     AV_CODEC_ID_AVUI,
-#if FF_API_AYUV_CODECID
-    AV_CODEC_ID_AYUV,
-#endif
     AV_CODEC_ID_TARGA_Y216,
     AV_CODEC_ID_V308,
     AV_CODEC_ID_V408,
@@ -546,6 +543,7 @@ enum AVCodecID {
     AV_CODEC_ID_AC4,
     AV_CODEC_ID_OSQ,
     AV_CODEC_ID_QOA,
+    AV_CODEC_ID_LC3,
 
     /* subtitle codecs */
     AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
diff --git a/media/ffvpx/libavcodec/codec_internal.h b/media/ffvpx/libavcodec/codec_internal.h
index 130a7dc3cd778..d6757e2deff01 100644
--- a/media/ffvpx/libavcodec/codec_internal.h
+++ b/media/ffvpx/libavcodec/codec_internal.h
@@ -284,25 +284,6 @@ typedef struct FFCodec {
         .update_thread_context_for_user = NULL
 #endif
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-#define CODEC_OLD_CHANNEL_LAYOUTS(...) CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(((const uint64_t[]) { __VA_ARGS__, 0 }))
-#if defined(__clang__)
-#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) \
-        FF_DISABLE_DEPRECATION_WARNINGS \
-        .p.channel_layouts = (array), \
-        FF_ENABLE_DEPRECATION_WARNINGS
-#else
-#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array) .p.channel_layouts = (array),
-#endif
-#else
-/* This is only provided to allow to test disabling FF_API_OLD_CHANNEL_LAYOUT
- * without removing all the FF_API_OLD_CHANNEL_LAYOUT codeblocks.
- * It is of course still expected to be removed when FF_API_OLD_CHANNEL_LAYOUT
- * will be finally removed (along with all usages of these macros). */
-#define CODEC_OLD_CHANNEL_LAYOUTS(...)
-#define CODEC_OLD_CHANNEL_LAYOUTS_ARRAY(array)
-#endif
-
 #define FF_CODEC_DECODE_CB(func)                          \
     .cb_type           = FF_CODEC_CB_TYPE_DECODE,         \
     .cb.decode         = (func)
diff --git a/media/ffvpx/libavcodec/codec_par.c b/media/ffvpx/libavcodec/codec_par.c
index abaac63841a16..212cb97d774b2 100644
--- a/media/ffvpx/libavcodec/codec_par.c
+++ b/media/ffvpx/libavcodec/codec_par.c
@@ -168,32 +168,9 @@ int avcodec_parameters_from_context(AVCodecParameters *par,
         break;
     case AVMEDIA_TYPE_AUDIO:
         par->format           = codec->sample_fmt;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        // if the old/new fields are set inconsistently, prefer the old ones
-        if ((codec->channels && codec->channels != codec->ch_layout.nb_channels) ||
-            (codec->channel_layout && (codec->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
-                                       codec->ch_layout.u.mask != codec->channel_layout))) {
-            if (codec->channel_layout)
-                av_channel_layout_from_mask(&par->ch_layout, codec->channel_layout);
-            else {
-                par->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-                par->ch_layout.nb_channels = codec->channels;
-            }
-FF_ENABLE_DEPRECATION_WARNINGS
-        } else {
-#endif
         ret = av_channel_layout_copy(&par->ch_layout, &codec->ch_layout);
         if (ret < 0)
             return ret;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        }
-        par->channel_layout  = par->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
-                               par->ch_layout.u.mask : 0;
-        par->channels        = par->ch_layout.nb_channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         par->sample_rate      = codec->sample_rate;
         par->block_align      = codec->block_align;
         par->frame_size       = codec->frame_size;
@@ -255,32 +232,9 @@ int avcodec_parameters_to_context(AVCodecContext *codec,
         break;
     case AVMEDIA_TYPE_AUDIO:
         codec->sample_fmt       = par->format;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        // if the old/new fields are set inconsistently, prefer the old ones
-        if ((par->channels && par->channels != par->ch_layout.nb_channels) ||
-            (par->channel_layout && (par->ch_layout.order != AV_CHANNEL_ORDER_NATIVE ||
-                                     par->ch_layout.u.mask != par->channel_layout))) {
-            if (par->channel_layout)
-                av_channel_layout_from_mask(&codec->ch_layout, par->channel_layout);
-            else {
-                codec->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-                codec->ch_layout.nb_channels = par->channels;
-            }
-FF_ENABLE_DEPRECATION_WARNINGS
-        } else {
-#endif
         ret = av_channel_layout_copy(&codec->ch_layout, &par->ch_layout);
         if (ret < 0)
             return ret;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        }
-        codec->channel_layout = codec->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
-                                codec->ch_layout.u.mask : 0;
-        codec->channels       = codec->ch_layout.nb_channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         codec->sample_rate      = par->sample_rate;
         codec->block_align      = par->block_align;
         codec->frame_size       = par->frame_size;
diff --git a/media/ffvpx/libavcodec/codec_par.h b/media/ffvpx/libavcodec/codec_par.h
index f42dd3b1d5e28..f4b9bb5c06d25 100644
--- a/media/ffvpx/libavcodec/codec_par.h
+++ b/media/ffvpx/libavcodec/codec_par.h
@@ -72,6 +72,19 @@ typedef struct AVCodecParameters {
      */
     int      extradata_size;
 
+    /**
+     * Additional data associated with the entire stream.
+     *
+     * Should be allocated with av_packet_side_data_new() or
+     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
+     */
+    AVPacketSideData *coded_side_data;
+
+    /**
+     * Amount of entries in @ref coded_side_data.
+     */
+    int nb_coded_side_data;
+
     /**
      * - video: the pixel format, the value corresponds to enum AVPixelFormat.
      * - audio: the sample format, the value corresponds to enum AVSampleFormat.
@@ -130,6 +143,18 @@ typedef struct AVCodecParameters {
      */
     AVRational sample_aspect_ratio;
 
+    /**
+     * Video only. Number of frames per second, for streams with constant frame
+     * durations. Should be set to { 0, 1 } when some frames have differing
+     * durations or if the value is not known.
+     *
+     * @note This field correponds to values that are stored in codec-level
+     * headers and is typically overridden by container/transport-layer
+     * timestamps, when available. It should thus be used only as a last resort,
+     * when no higher-level timing information is available.
+     */
+    AVRational framerate;
+
     /**
      * Video only. The order of the fields in interlaced video.
      */
@@ -149,22 +174,10 @@ typedef struct AVCodecParameters {
      */
     int video_delay;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * Audio only. The channel layout bitmask. May be 0 if the channel layout is
-     * unknown or unspecified, otherwise the number of bits set must be equal to
-     * the channels field.
-     * @deprecated use ch_layout
-     */
-    attribute_deprecated
-    uint64_t channel_layout;
     /**
-     * Audio only. The number of audio channels.
-     * @deprecated use ch_layout.nb_channels
+     * Audio only. The channel layout and number of channels.
      */
-    attribute_deprecated
-    int      channels;
-#endif
+    AVChannelLayout ch_layout;
     /**
      * Audio only. The number of audio samples per second.
      */
@@ -199,36 +212,6 @@ typedef struct AVCodecParameters {
      * Audio only. Number of samples to skip after a discontinuity.
      */
     int seek_preroll;
-
-    /**
-     * Audio only. The channel layout and number of channels.
-     */
-    AVChannelLayout ch_layout;
-
-    /**
-     * Video only. Number of frames per second, for streams with constant frame
-     * durations. Should be set to { 0, 1 } when some frames have differing
-     * durations or if the value is not known.
-     *
-     * @note This field correponds to values that are stored in codec-level
-     * headers and is typically overridden by container/transport-layer
-     * timestamps, when available. It should thus be used only as a last resort,
-     * when no higher-level timing information is available.
-     */
-    AVRational framerate;
-
-    /**
-     * Additional data associated with the entire stream.
-     *
-     * Should be allocated with av_packet_side_data_new() or
-     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
-     */
-    AVPacketSideData *coded_side_data;
-
-    /**
-     * Amount of entries in @ref coded_side_data.
-     */
-    int nb_coded_side_data;
 } AVCodecParameters;
 
 /**
diff --git a/media/ffvpx/libavcodec/decode.c b/media/ffvpx/libavcodec/decode.c
index 2cfb3fcf97b0b..255347766ad3c 100644
--- a/media/ffvpx/libavcodec/decode.c
+++ b/media/ffvpx/libavcodec/decode.c
@@ -35,6 +35,8 @@
 #include "libavutil/hwcontext.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/internal.h"
+#include "libavutil/mastering_display_metadata.h"
+#include "libavutil/mem.h"
 
 #include "avcodec.h"
 #include "avcodec_internal.h"
@@ -60,6 +62,17 @@ typedef struct DecodeContext {
      * The caller has submitted a NULL packet on input.
      */
     int draining_started;
+
+    int64_t pts_correction_num_faulty_pts; /// Number of incorrect PTS values so far
+    int64_t pts_correction_num_faulty_dts; /// Number of incorrect DTS values so far
+    int64_t pts_correction_last_pts;       /// PTS of the last frame
+    int64_t pts_correction_last_dts;       /// DTS of the last frame
+
+    /**
+     * Bitmask indicating for which side data types we prefer user-supplied
+     * (global or attached to packets) side data over bytestream.
+     */
+    uint64_t side_data_pref_mask;
 } DecodeContext;
 
 static DecodeContext *decode_ctx(AVCodecInternal *avci)
@@ -92,39 +105,6 @@ static int apply_param_change(AVCodecContext *avctx, const AVPacket *avpkt)
     flags = bytestream_get_le32(&data);
     size -= 4;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {
-        if (size < 4)
-            goto fail;
-        val = bytestream_get_le32(&data);
-        if (val <= 0 || val > INT_MAX) {
-            av_log(avctx, AV_LOG_ERROR, "Invalid channel count");
-            ret = AVERROR_INVALIDDATA;
-            goto fail2;
-        }
-        av_channel_layout_uninit(&avctx->ch_layout);
-        avctx->ch_layout.nb_channels = val;
-        avctx->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;
-        size -= 4;
-    }
-    if (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {
-        if (size < 8)
-            goto fail;
-        av_channel_layout_uninit(&avctx->ch_layout);
-        ret = av_channel_layout_from_mask(&avctx->ch_layout, bytestream_get_le64(&data));
-        if (ret < 0)
-            goto fail2;
-        size -= 8;
-    }
-    if (flags & (AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT |
-                 AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)) {
-        avctx->channels = avctx->ch_layout.nb_channels;
-        avctx->channel_layout = (avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE) ?
-                                avctx->ch_layout.u.mask : 0;
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     if (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {
         if (size < 4)
             goto fail;
@@ -273,24 +253,24 @@ int ff_decode_get_packet(AVCodecContext *avctx, AVPacket *pkt)
  * @param dts the dts field of the decoded AVPacket
  * @return one of the input values, may be AV_NOPTS_VALUE
  */
-static int64_t guess_correct_pts(AVCodecContext *ctx,
+static int64_t guess_correct_pts(DecodeContext *dc,
                                  int64_t reordered_pts, int64_t dts)
 {
     int64_t pts = AV_NOPTS_VALUE;
 
     if (dts != AV_NOPTS_VALUE) {
-        ctx->pts_correction_num_faulty_dts += dts <= ctx->pts_correction_last_dts;
-        ctx->pts_correction_last_dts = dts;
+        dc->pts_correction_num_faulty_dts += dts <= dc->pts_correction_last_dts;
+        dc->pts_correction_last_dts = dts;
     } else if (reordered_pts != AV_NOPTS_VALUE)
-        ctx->pts_correction_last_dts = reordered_pts;
+        dc->pts_correction_last_dts = reordered_pts;
 
     if (reordered_pts != AV_NOPTS_VALUE) {
-        ctx->pts_correction_num_faulty_pts += reordered_pts <= ctx->pts_correction_last_pts;
-        ctx->pts_correction_last_pts = reordered_pts;
+        dc->pts_correction_num_faulty_pts += reordered_pts <= dc->pts_correction_last_pts;
+        dc->pts_correction_last_pts = reordered_pts;
     } else if(dts != AV_NOPTS_VALUE)
-        ctx->pts_correction_last_pts = dts;
+        dc->pts_correction_last_pts = dts;
 
-    if ((ctx->pts_correction_num_faulty_pts<=ctx->pts_correction_num_faulty_dts || dts == AV_NOPTS_VALUE)
+    if ((dc->pts_correction_num_faulty_pts<=dc->pts_correction_num_faulty_dts || dts == AV_NOPTS_VALUE)
        && reordered_pts != AV_NOPTS_VALUE)
         pts = reordered_pts;
     else
@@ -582,15 +562,6 @@ static int fill_frame_props(const AVCodecContext *avctx, AVFrame *frame)
             if (ret < 0)
                 return ret;
         }
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        if (!frame->channel_layout)
-            frame->channel_layout = avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
-                                    avctx->ch_layout.u.mask : 0;
-        if (!frame->channels)
-            frame->channels = avctx->ch_layout.nb_channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         if (!frame->sample_rate)
             frame->sample_rate = avctx->sample_rate;
     }
@@ -617,6 +588,7 @@ static int decode_simple_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
 {
     AVCodecInternal *avci = avctx->internal;
+    DecodeContext     *dc = decode_ctx(avci);
     const FFCodec *const codec = ffcodec(avctx->codec);
     int ret, ok;
 
@@ -672,16 +644,10 @@ FF_DISABLE_DEPRECATION_WARNINGS
         frame->top_field_first =  !!(frame->flags & AV_FRAME_FLAG_TOP_FIELD_FIRST);
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
-        frame->best_effort_timestamp = guess_correct_pts(avctx,
+        frame->best_effort_timestamp = guess_correct_pts(dc,
                                                          frame->pts,
                                                          frame->pkt_dts);
 
-#if FF_API_PKT_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-        frame->pkt_duration = frame->duration;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
         /* the only case where decode data is not set should be decoders
          * that do not call ff_get_buffer() */
         av_assert0((frame->private_ref && frame->private_ref->size == sizeof(FrameDecodeData)) ||
@@ -820,11 +786,6 @@ int ff_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     }
 
     avctx->frame_num++;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->frame_number = avctx->frame_num;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
 #if FF_API_DROPCHANGED
     if (avctx->flags & AV_CODEC_FLAG_DROPCHANGED) {
@@ -977,8 +938,8 @@ int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
     }
     if (!avctx->codec)
         return AVERROR(EINVAL);
-    if (avctx->codec->type != AVMEDIA_TYPE_SUBTITLE) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid media type for subtitles\n");
+    if (ffcodec(avctx->codec)->cb_type != FF_CODEC_CB_TYPE_DECODE_SUB) {
+        av_log(avctx, AV_LOG_ERROR, "Codec not subtitle decoder\n");
         return AVERROR(EINVAL);
     }
 
@@ -1032,11 +993,6 @@ int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
 
         if (*got_sub_ptr)
             avctx->frame_num++;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-        avctx->frame_number = avctx->frame_num;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     }
 
     return ret;
@@ -1371,8 +1327,8 @@ int ff_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt)
             goto try_again;
         }
         if (hw_config->hwaccel) {
-            av_log(avctx, AV_LOG_DEBUG, "Format %s requires hwaccel "
-                   "initialisation.\n", desc->name);
+            av_log(avctx, AV_LOG_DEBUG, "Format %s requires hwaccel %s "
+                   "initialisation.\n", desc->name, hw_config->hwaccel->p.name);
             err = hwaccel_init(avctx, hw_config->hwaccel);
             if (err < 0)
                 goto try_again;
@@ -1421,21 +1377,6 @@ static int add_metadata_from_side_data(const AVPacket *avpkt, AVFrame *frame)
     return av_packet_unpack_dictionary(side_metadata, size, frame_md);
 }
 
-static const struct {
-    enum AVPacketSideDataType packet;
-    enum AVFrameSideDataType frame;
-} sd_global_map[] = {
-    { AV_PKT_DATA_REPLAYGAIN ,                AV_FRAME_DATA_REPLAYGAIN },
-    { AV_PKT_DATA_DISPLAYMATRIX,              AV_FRAME_DATA_DISPLAYMATRIX },
-    { AV_PKT_DATA_SPHERICAL,                  AV_FRAME_DATA_SPHERICAL },
-    { AV_PKT_DATA_STEREO3D,                   AV_FRAME_DATA_STEREO3D },
-    { AV_PKT_DATA_AUDIO_SERVICE_TYPE,         AV_FRAME_DATA_AUDIO_SERVICE_TYPE },
-    { AV_PKT_DATA_MASTERING_DISPLAY_METADATA, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA },
-    { AV_PKT_DATA_CONTENT_LIGHT_LEVEL,        AV_FRAME_DATA_CONTENT_LIGHT_LEVEL },
-    { AV_PKT_DATA_ICC_PROFILE,                AV_FRAME_DATA_ICC_PROFILE },
-    { AV_PKT_DATA_DYNAMIC_HDR10_PLUS,         AV_FRAME_DATA_DYNAMIC_HDR_PLUS },
-};
-
 int ff_decode_frame_props_from_pkt(const AVCodecContext *avctx,
                                    AVFrame *frame, const AVPacket *pkt)
 {
@@ -1445,6 +1386,7 @@ int ff_decode_frame_props_from_pkt(const AVCodecContext *avctx,
     } sd[] = {
         { AV_PKT_DATA_A53_CC,                     AV_FRAME_DATA_A53_CC },
         { AV_PKT_DATA_AFD,                        AV_FRAME_DATA_AFD },
+        { AV_PKT_DATA_DYNAMIC_HDR10_PLUS,         AV_FRAME_DATA_DYNAMIC_HDR_PLUS },
         { AV_PKT_DATA_S12M_TIMECODE,              AV_FRAME_DATA_S12M_TIMECODE },
         { AV_PKT_DATA_SKIP_SAMPLES,               AV_FRAME_DATA_SKIP_SAMPLES },
     };
@@ -1458,13 +1400,13 @@ FF_DISABLE_DEPRECATION_WARNINGS
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
 
-    for (int i = 0; i < FF_ARRAY_ELEMS(sd_global_map); i++) {
+    for (int i = 0; ff_sd_global_map[i].packet < AV_PKT_DATA_NB; i++) {
         size_t size;
-        const uint8_t *packet_sd = av_packet_get_side_data(pkt, sd_global_map[i].packet, &size);
+        const uint8_t *packet_sd = av_packet_get_side_data(pkt, ff_sd_global_map[i].packet, &size);
         if (packet_sd) {
             AVFrameSideData *frame_sd;
 
-            frame_sd = av_frame_new_side_data(frame, sd_global_map[i].frame, size);
+            frame_sd = av_frame_new_side_data(frame, ff_sd_global_map[i].frame, size);
             if (!frame_sd)
                 return AVERROR(ENOMEM);
             memcpy(frame_sd->data, packet_sd, size);
@@ -1505,12 +1447,12 @@ int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame)
 {
     int ret;
 
-    for (int i = 0; i < FF_ARRAY_ELEMS(sd_global_map); i++) {
+    for (int i = 0; ff_sd_global_map[i].packet < AV_PKT_DATA_NB; i++) {
         const AVPacketSideData *packet_sd = ff_get_coded_side_data(avctx,
-                                                                   sd_global_map[i].packet);
+                                                                   ff_sd_global_map[i].packet);
         if (packet_sd) {
             AVFrameSideData *frame_sd = av_frame_new_side_data(frame,
-                                                               sd_global_map[i].frame,
+                                                               ff_sd_global_map[i].frame,
                                                                packet_sd->size);
             if (!frame_sd)
                 return AVERROR(ENOMEM);
@@ -1531,11 +1473,6 @@ FF_DISABLE_DEPRECATION_WARNINGS
 FF_ENABLE_DEPRECATION_WARNINGS
 #endif
     }
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    frame->reordered_opaque = avctx->reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     ret = fill_frame_props(avctx, frame);
     if (ret < 0)
@@ -1642,15 +1579,6 @@ int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags)
             goto fail;
         }
     } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        /* compat layer for old-style get_buffer() implementations */
-        avctx->channels = avctx->ch_layout.nb_channels;
-        avctx->channel_layout = (avctx->ch_layout.order == AV_CHANNEL_ORDER_NATIVE) ?
-                                avctx->ch_layout.u.mask : 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
         if (frame->nb_samples * (int64_t)avctx->ch_layout.nb_channels > avctx->max_samples) {
             av_log(avctx, AV_LOG_ERROR, "samples per frame %d, exceeds max_samples %"PRId64"\n", frame->nb_samples, avctx->max_samples);
             ret = AVERROR(EINVAL);
@@ -1743,6 +1671,7 @@ int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame, int flags)
 int ff_decode_preinit(AVCodecContext *avctx)
 {
     AVCodecInternal *avci = avctx->internal;
+    DecodeContext     *dc = decode_ctx(avci);
     int ret = 0;
 
     /* if the decoder init function was already called previously,
@@ -1790,10 +1719,10 @@ int ff_decode_preinit(AVCodecContext *avctx)
         }
     }
 
-    avctx->pts_correction_num_faulty_pts =
-    avctx->pts_correction_num_faulty_dts = 0;
-    avctx->pts_correction_last_pts =
-    avctx->pts_correction_last_dts = INT64_MIN;
+    dc->pts_correction_num_faulty_pts =
+    dc->pts_correction_num_faulty_dts = 0;
+    dc->pts_correction_last_pts =
+    dc->pts_correction_last_dts = INT64_MIN;
 
     if (   !CONFIG_GRAY && avctx->flags & AV_CODEC_FLAG_GRAY
         && avctx->codec_descriptor->type == AVMEDIA_TYPE_VIDEO)
@@ -1803,6 +1732,35 @@ int ff_decode_preinit(AVCodecContext *avctx)
         avctx->export_side_data |= AV_CODEC_EXPORT_DATA_MVS;
     }
 
+    if (avctx->nb_side_data_prefer_packet == 1 &&
+        avctx->side_data_prefer_packet[0] == -1)
+        dc->side_data_pref_mask = ~0ULL;
+    else {
+        for (unsigned i = 0; i < avctx->nb_side_data_prefer_packet; i++) {
+            int val = avctx->side_data_prefer_packet[i];
+
+            if (val < 0 || val >= AV_PKT_DATA_NB) {
+                av_log(avctx, AV_LOG_ERROR, "Invalid side data type: %d\n", val);
+                return AVERROR(EINVAL);
+            }
+
+            for (unsigned j = 0; ff_sd_global_map[j].packet < AV_PKT_DATA_NB; j++) {
+                if (ff_sd_global_map[j].packet == val) {
+                    val = ff_sd_global_map[j].frame;
+
+                    // this code will need to be changed when we have more than
+                    // 64 frame side data types
+                    if (val >= 64) {
+                        av_log(avctx, AV_LOG_ERROR, "Side data type too big\n");
+                        return AVERROR_BUG;
+                    }
+
+                    dc->side_data_pref_mask |= 1ULL << val;
+                }
+            }
+        }
+    }
+
     avci->in_pkt         = av_packet_alloc();
     avci->last_pkt_props = av_packet_alloc();
     if (!avci->in_pkt || !avci->last_pkt_props)
@@ -1820,6 +1778,96 @@ int ff_decode_preinit(AVCodecContext *avctx)
     return 0;
 }
 
+/**
+ * Check side data preference and clear existing side data from frame
+ * if needed.
+ *
+ * @retval 0 side data of this type can be added to frame
+ * @retval 1 side data of this type should not be added to frame
+ */
+static int side_data_pref(const AVCodecContext *avctx, AVFrame *frame,
+                          enum AVFrameSideDataType type)
+{
+    DecodeContext *dc = decode_ctx(avctx->internal);
+
+    // Note: could be skipped for `type` without corresponding packet sd
+    if (av_frame_get_side_data(frame, type)) {
+        if (dc->side_data_pref_mask & (1ULL << type))
+            return 1;
+        av_frame_remove_side_data(frame, type);
+    }
+
+    return 0;
+}
+
+
+int ff_frame_new_side_data(const AVCodecContext *avctx, AVFrame *frame,
+                           enum AVFrameSideDataType type, size_t size,
+                           AVFrameSideData **psd)
+{
+    AVFrameSideData *sd;
+
+    if (side_data_pref(avctx, frame, type)) {
+        if (psd)
+            *psd = NULL;
+        return 0;
+    }
+
+    sd = av_frame_new_side_data(frame, type, size);
+    if (psd)
+        *psd = sd;
+
+    return sd ? 0 : AVERROR(ENOMEM);
+}
+
+int ff_frame_new_side_data_from_buf(const AVCodecContext *avctx,
+                                    AVFrame *frame, enum AVFrameSideDataType type,
+                                    AVBufferRef **buf, AVFrameSideData **psd)
+{
+    AVFrameSideData *sd = NULL;
+    int ret = 0;
+
+    if (side_data_pref(avctx, frame, type))
+        goto finish;
+
+    sd = av_frame_new_side_data_from_buf(frame, type, *buf);
+    if (sd)
+        *buf = NULL;
+    else
+        ret = AVERROR(ENOMEM);
+
+finish:
+    av_buffer_unref(buf);
+    if (psd)
+        *psd = sd;
+
+    return ret;
+}
+
+int ff_decode_mastering_display_new(const AVCodecContext *avctx, AVFrame *frame,
+                                    AVMasteringDisplayMetadata **mdm)
+{
+    if (side_data_pref(avctx, frame, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA)) {
+        *mdm = NULL;
+        return 0;
+    }
+
+    *mdm = av_mastering_display_metadata_create_side_data(frame);
+    return *mdm ? 0 : AVERROR(ENOMEM);
+}
+
+int ff_decode_content_light_new(const AVCodecContext *avctx, AVFrame *frame,
+                                AVContentLightMetadata **clm)
+{
+    if (side_data_pref(avctx, frame, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL)) {
+        *clm = NULL;
+        return 0;
+    }
+
+    *clm = av_content_light_metadata_create_side_data(frame);
+    return *clm ? 0 : AVERROR(ENOMEM);
+}
+
 int ff_copy_palette(void *dst, const AVPacket *src, void *logctx)
 {
     size_t size;
@@ -1872,8 +1920,8 @@ void ff_decode_flush_buffers(AVCodecContext *avctx)
     av_packet_unref(avci->last_pkt_props);
     av_packet_unref(avci->in_pkt);
 
-    avctx->pts_correction_last_pts =
-    avctx->pts_correction_last_dts = INT64_MIN;
+    dc->pts_correction_last_pts =
+    dc->pts_correction_last_dts = INT64_MIN;
 
     av_bsf_flush(avci->bsf);
 
diff --git a/media/ffvpx/libavcodec/decode.h b/media/ffvpx/libavcodec/decode.h
index daf1a67444720..4ffbd9db8ebc9 100644
--- a/media/ffvpx/libavcodec/decode.h
+++ b/media/ffvpx/libavcodec/decode.h
@@ -155,4 +155,45 @@ int ff_hwaccel_frame_priv_alloc(AVCodecContext *avctx, void **hwaccel_picture_pr
 const AVPacketSideData *ff_get_coded_side_data(const AVCodecContext *avctx,
                                                enum AVPacketSideDataType type);
 
+/**
+ * Wrapper around av_frame_new_side_data, which rejects side data overridden by
+ * the demuxer. Returns 0 on success, and a negative error code otherwise.
+ * If successful and sd is not NULL, *sd may either contain a pointer to the new
+ * side data, or NULL in case the side data was already present.
+ */
+int ff_frame_new_side_data(const AVCodecContext *avctx, AVFrame *frame,
+                           enum AVFrameSideDataType type, size_t size,
+                           AVFrameSideData **sd);
+
+/**
+ * Similar to `ff_frame_new_side_data`, but using an existing buffer ref.
+ *
+ * *buf is ALWAYS consumed by this function and NULL written in its place, even
+ * on failure.
+ */
+int ff_frame_new_side_data_from_buf(const AVCodecContext *avctx,
+                                    AVFrame *frame, enum AVFrameSideDataType type,
+                                    AVBufferRef **buf, AVFrameSideData **sd);
+
+struct AVMasteringDisplayMetadata;
+struct AVContentLightMetadata;
+
+/**
+ * Wrapper around av_mastering_display_metadata_create_side_data(), which
+ * rejects side data overridden by the demuxer. Returns 0 on success, and a
+ * negative error code otherwise. If successful, *mdm may either be a pointer to
+ * the new side data, or NULL in case the side data was already present.
+ */
+int ff_decode_mastering_display_new(const AVCodecContext *avctx, AVFrame *frame,
+                                    struct AVMasteringDisplayMetadata **mdm);
+
+/**
+ * Wrapper around av_content_light_metadata_create_side_data(), which
+ * rejects side data overridden by the demuxer. Returns 0 on success, and a
+ * negative error code otherwise. If successful, *clm may either be a pointer to
+ * the new side data, or NULL in case the side data was already present.
+ */
+int ff_decode_content_light_new(const AVCodecContext *avctx, AVFrame *frame,
+                                struct AVContentLightMetadata **clm);
+
 #endif /* AVCODEC_DECODE_H */
diff --git a/media/ffvpx/libavcodec/dovi_rpu.h b/media/ffvpx/libavcodec/dovi_rpu.h
new file mode 100644
index 0000000000000..a09e76ea323bf
--- /dev/null
+++ b/media/ffvpx/libavcodec/dovi_rpu.h
@@ -0,0 +1,29 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:set ts=2 sw=2 sts=2 et cindent: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* Stubs for dovi_rpu.{c,h} */
+
+typedef struct AVCtx AVContext;
+
+typedef struct DOVICtx {
+  int dv_profile;
+  AVContext* logctx;
+  int operating_point;
+} DOVIContext;
+
+typedef struct AVDOVICConfRecord {
+} AVDOVIDecoderConfigurationRecord;
+
+inline void ff_dovi_ctx_unref(DOVIContext* ctx) {}
+inline void ff_dovi_update_cfg(DOVIContext* ctx,
+                               AVDOVIDecoderConfigurationRecord* record) {}
+inline int ff_dovi_rpu_parse(DOVIContext* ctx, uint8_t* buf, size_t len,
+                             int err_recognition) {
+  return 0;
+}
+inline int ff_dovi_attach_side_data(DOVIContext* ctx, AVFrame* frame) {
+  return 0;
+}
diff --git a/media/ffvpx/libavcodec/encode.c b/media/ffvpx/libavcodec/encode.c
index a436be2657971..34658d13d0cec 100644
--- a/media/ffvpx/libavcodec/encode.c
+++ b/media/ffvpx/libavcodec/encode.c
@@ -25,6 +25,7 @@
 #include "libavutil/frame.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/internal.h"
+#include "libavutil/mem.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/samplefmt.h"
 
@@ -198,11 +199,6 @@ int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size,
 
     ret = ffcodec(avctx->codec)->cb.encode_sub(avctx, buf, buf_size, sub);
     avctx->frame_num++;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->frame_number = avctx->frame_num;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     return ret;
 }
 
@@ -239,12 +235,6 @@ FF_ENABLE_DEPRECATION_WARNINGS
 int ff_encode_reordered_opaque(AVCodecContext *avctx,
                                AVPacket *pkt, const AVFrame *frame)
 {
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->reordered_opaque = frame->reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     if (avctx->flags & AV_CODEC_FLAG_COPY_OPAQUE) {
         int ret = av_buffer_replace(&pkt->opaque_ref, frame->opaque_ref);
         if (ret < 0)
@@ -544,11 +534,6 @@ int attribute_align_arg avcodec_send_frame(AVCodecContext *avctx, const AVFrame
     }
 
     avctx->frame_num++;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->frame_number = avctx->frame_num;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     return 0;
 }
@@ -736,6 +721,8 @@ static int encode_preinit_audio(AVCodecContext *avctx)
         }
     }
 
+    if (!avctx->bits_per_raw_sample)
+        avctx->bits_per_raw_sample = av_get_exact_bits_per_sample(avctx->codec_id);
     if (!avctx->bits_per_raw_sample)
         avctx->bits_per_raw_sample = 8 * av_get_bytes_per_sample(avctx->sample_fmt);
 
@@ -796,6 +783,29 @@ int ff_encode_preinit(AVCodecContext *avctx)
             return AVERROR(ENOMEM);
     }
 
+    for (int i = 0; ff_sd_global_map[i].packet < AV_PKT_DATA_NB; i++) {
+        const enum AVPacketSideDataType type_packet = ff_sd_global_map[i].packet;
+        const enum AVFrameSideDataType  type_frame  = ff_sd_global_map[i].frame;
+        const AVFrameSideData *sd_frame;
+        AVPacketSideData      *sd_packet;
+
+        sd_frame = av_frame_side_data_get(avctx->decoded_side_data,
+                                          avctx->nb_decoded_side_data,
+                                          type_frame);
+        if (!sd_frame ||
+            av_packet_side_data_get(avctx->coded_side_data, avctx->nb_coded_side_data,
+                                    type_packet))
+
+            continue;
+
+        sd_packet = av_packet_side_data_new(&avctx->coded_side_data, &avctx->nb_coded_side_data,
+                                            type_packet, sd_frame->size, 0);
+        if (!sd_packet)
+            return AVERROR(ENOMEM);
+
+        memcpy(sd_packet->data, sd_frame->data, sd_frame->size);
+    }
+
     if (CONFIG_FRAME_THREAD_ENCODER) {
         ret = ff_frame_thread_encoder_init(avctx);
         if (ret < 0)
diff --git a/media/ffvpx/libavcodec/encode.h b/media/ffvpx/libavcodec/encode.h
index e019cd7702e1f..85331e04b7dea 100644
--- a/media/ffvpx/libavcodec/encode.h
+++ b/media/ffvpx/libavcodec/encode.h
@@ -26,6 +26,12 @@
 #include "avcodec.h"
 #include "packet.h"
 
+/**
+ * Used by some encoders as upper bound for the length of headers.
+ * TODO: Use proper codec-specific upper bounds.
+ */
+#define FF_INPUT_BUFFER_MIN_SIZE 16384
+
 /**
  * Called by encoders to get the next frame for encoding.
  *
diff --git a/media/ffvpx/libavcodec/flacdec.c b/media/ffvpx/libavcodec/flacdec.c
index ed2de14d0a98b..91bbdc657d4d1 100644
--- a/media/ffvpx/libavcodec/flacdec.c
+++ b/media/ffvpx/libavcodec/flacdec.c
@@ -35,14 +35,13 @@
 
 #include "libavutil/avassert.h"
 #include "libavutil/crc.h"
+#include "libavutil/mem.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "get_bits.h"
-#include "bytestream.h"
 #include "golomb.h"
 #include "flac.h"
-#include "flacdata.h"
 #include "flacdsp.h"
 #include "flac_parse.h"
 #include "thread.h"
diff --git a/media/ffvpx/libavcodec/get_bits.h b/media/ffvpx/libavcodec/get_bits.h
index 9e19d2a4398f8..fe2f6378b4556 100644
--- a/media/ffvpx/libavcodec/get_bits.h
+++ b/media/ffvpx/libavcodec/get_bits.h
@@ -94,7 +94,6 @@ typedef BitstreamContext GetBitContext;
 #define align_get_bits      bits_align
 #define get_vlc2            bits_read_vlc
 #define get_vlc_multi       bits_read_vlc_multi
-#define get_leb             bits_read_leb
 
 #define init_get_bits8_le(s, buffer, byte_size) bits_init8_le((BitstreamContextLE*)s, buffer, byte_size)
 #define get_bits_le(s, n)                       bits_read_le((BitstreamContextLE*)s, n)
@@ -668,7 +667,8 @@ static av_always_inline int get_vlc2(GetBitContext *s, const VLCElem *table,
 static inline int get_vlc_multi(GetBitContext *s, uint8_t *dst,
                                 const VLC_MULTI_ELEM *const Jtable,
                                 const VLCElem *const table,
-                                const int bits, const int max_depth)
+                                const int bits, const int max_depth,
+                                const int symbols_size)
 {
     dst[0] = get_vlc2(s, table, bits, max_depth);
     return 1;
@@ -711,29 +711,6 @@ static inline int skip_1stop_8data_bits(GetBitContext *gb)
     return 0;
 }
 
-/**
- * Read a unsigned integer coded as a variable number of up to eight
- * little-endian bytes, where the MSB in a byte signals another byte
- * must be read.
- * All coded bits are read, but values > UINT_MAX are truncated.
- */
-static inline unsigned get_leb(GetBitContext *s) {
-    int more, i = 0;
-    unsigned leb = 0;
-
-    do {
-        int byte = get_bits(s, 8);
-        unsigned bits = byte & 0x7f;
-        more = byte & 0x80;
-        if (i <= 4)
-            leb |= bits << (i * 7);
-        if (++i == 8)
-            break;
-    } while (more);
-
-    return leb;
-}
-
 #endif // CACHED_BITSTREAM_READER
 
 #endif /* AVCODEC_GET_BITS_H */
diff --git a/media/ffvpx/libavcodec/get_buffer.c b/media/ffvpx/libavcodec/get_buffer.c
index 647f8a3df7e5d..9b35fde7c684b 100644
--- a/media/ffvpx/libavcodec/get_buffer.c
+++ b/media/ffvpx/libavcodec/get_buffer.c
@@ -70,12 +70,6 @@ static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
     if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
         int planar = av_sample_fmt_is_planar(frame->format);
         ch     = frame->ch_layout.nb_channels;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        if (!ch)
-            ch = frame->channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         planes = planar ? ch : 1;
     }
 
@@ -263,6 +257,22 @@ int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags
 
     if (avctx->hw_frames_ctx) {
         ret = av_hwframe_get_buffer(avctx->hw_frames_ctx, frame, 0);
+        if (ret == AVERROR(ENOMEM)) {
+            AVHWFramesContext *frames_ctx =
+                (AVHWFramesContext*)avctx->hw_frames_ctx->data;
+            if (frames_ctx->initial_pool_size > 0 &&
+                !avctx->internal->warned_on_failed_allocation_from_fixed_pool) {
+                av_log(avctx, AV_LOG_WARNING, "Failed to allocate a %s/%s "
+                       "frame from a fixed pool of hardware frames.\n",
+                       av_get_pix_fmt_name(frames_ctx->format),
+                       av_get_pix_fmt_name(frames_ctx->sw_format));
+                av_log(avctx, AV_LOG_WARNING, "Consider setting "
+                       "extra_hw_frames to a larger value "
+                       "(currently set to %d, giving a pool size of %d).\n",
+                       avctx->extra_hw_frames, frames_ctx->initial_pool_size);
+                avctx->internal->warned_on_failed_allocation_from_fixed_pool = 1;
+            }
+        }
         frame->width  = avctx->coded_width;
         frame->height = avctx->coded_height;
         return ret;
diff --git a/media/ffvpx/libavcodec/hwaccel.h b/media/ffvpx/libavcodec/hwaccel.h
deleted file mode 100644
index 3aaa92571c414..0000000000000
--- a/media/ffvpx/libavcodec/hwaccel.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_HWACCEL_H
-#define AVCODEC_HWACCEL_H
-
-#include "avcodec.h"
-#include "hwaccels.h"
-
-
-#define HWACCEL_CAP_ASYNC_SAFE      (1 << 0)
-
-
-typedef struct AVCodecHWConfigInternal {
-    /**
-     * This is the structure which will be returned to the user by
-     * avcodec_get_hw_config().
-     */
-    AVCodecHWConfig public;
-    /**
-     * If this configuration uses a hwaccel, a pointer to it.
-     * If not, NULL.
-     */
-    const AVHWAccel *hwaccel;
-} AVCodecHWConfigInternal;
-
-
-// These macros are used to simplify AVCodecHWConfigInternal definitions.
-
-#define HW_CONFIG_HWACCEL(device, frames, ad_hoc, format, device_type_, name) \
-    &(const AVCodecHWConfigInternal) { \
-        .public          = { \
-            .pix_fmt     = AV_PIX_FMT_ ## format, \
-            .methods     = (device ? AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX : 0) | \
-                           (frames ? AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX : 0) | \
-                           (ad_hoc ? AV_CODEC_HW_CONFIG_METHOD_AD_HOC        : 0),  \
-            .device_type = AV_HWDEVICE_TYPE_ ## device_type_, \
-        }, \
-        .hwaccel         = &name, \
-    }
-
-#define HW_CONFIG_INTERNAL(format) \
-    &(const AVCodecHWConfigInternal) { \
-        .public          = { \
-            .pix_fmt     = AV_PIX_FMT_ ## format, \
-            .methods     = AV_CODEC_HW_CONFIG_METHOD_INTERNAL, \
-            .device_type = AV_HWDEVICE_TYPE_NONE, \
-        }, \
-        .hwaccel         = NULL, \
-    }
-
-#define HWACCEL_DXVA2(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 1, DXVA2_VLD,    DXVA2,        ff_ ## codec ## _dxva2_hwaccel)
-#define HWACCEL_D3D11VA2(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 0, D3D11,        D3D11VA,      ff_ ## codec ## _d3d11va2_hwaccel)
-#define HWACCEL_NVDEC(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 0, CUDA,         CUDA,         ff_ ## codec ## _nvdec_hwaccel)
-#define HWACCEL_VAAPI(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 1, VAAPI,        VAAPI,        ff_ ## codec ## _vaapi_hwaccel)
-#define HWACCEL_VDPAU(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 1, VDPAU,        VDPAU,        ff_ ## codec ## _vdpau_hwaccel)
-#define HWACCEL_VIDEOTOOLBOX(codec) \
-    HW_CONFIG_HWACCEL(1, 1, 1, VIDEOTOOLBOX, VIDEOTOOLBOX, ff_ ## codec ## _videotoolbox_hwaccel)
-#define HWACCEL_D3D11VA(codec) \
-    HW_CONFIG_HWACCEL(0, 0, 1, D3D11VA_VLD,  NONE,         ff_ ## codec ## _d3d11va_hwaccel)
-#define HWACCEL_XVMC(codec) \
-    HW_CONFIG_HWACCEL(0, 0, 1, XVMC,         NONE,         ff_ ## codec ## _xvmc_hwaccel)
-
-#endif /* AVCODEC_HWACCEL_H */
diff --git a/media/ffvpx/libavcodec/hwaccel_internal.h b/media/ffvpx/libavcodec/hwaccel_internal.h
index 057b07323d503..b0cc22bb68991 100644
--- a/media/ffvpx/libavcodec/hwaccel_internal.h
+++ b/media/ffvpx/libavcodec/hwaccel_internal.h
@@ -128,7 +128,7 @@ typedef struct FFHWAccel {
     /**
      * Uninitialize the hwaccel private data.
      *
-     * This will be called from get_format() or avcodec_close(), after hwaccel
+     * This will be called from get_format() or ff_codec_close(), after hwaccel
      * and hwaccel_context are already uninitialized.
      */
     int (*uninit)(AVCodecContext *avctx);
diff --git a/media/ffvpx/libavcodec/idctdsp.c b/media/ffvpx/libavcodec/idctdsp.c
index 7216afb094fdb..de879f7302077 100644
--- a/media/ffvpx/libavcodec/idctdsp.c
+++ b/media/ffvpx/libavcodec/idctdsp.c
@@ -70,7 +70,7 @@ av_cold void ff_init_scantable_permutation(uint8_t *idct_permutation,
     }
 }
 
-void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
+void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *restrict pixels,
                              ptrdiff_t line_size)
 {
     int i;
@@ -91,7 +91,7 @@ void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
     }
 }
 
-static void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,
+static void put_pixels_clamped4_c(const int16_t *block, uint8_t *restrict pixels,
                                  int line_size)
 {
     int i;
@@ -108,7 +108,7 @@ static void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pix
     }
 }
 
-static void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,
+static void put_pixels_clamped2_c(const int16_t *block, uint8_t *restrict pixels,
                                  int line_size)
 {
     int i;
@@ -124,7 +124,7 @@ static void put_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pix
 }
 
 static void put_signed_pixels_clamped_c(const int16_t *block,
-                                        uint8_t *av_restrict pixels,
+                                        uint8_t *restrict pixels,
                                         ptrdiff_t line_size)
 {
     int i, j;
@@ -144,7 +144,7 @@ static void put_signed_pixels_clamped_c(const int16_t *block,
     }
 }
 
-void ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
+void ff_add_pixels_clamped_c(const int16_t *block, uint8_t *restrict pixels,
                              ptrdiff_t line_size)
 {
     int i;
@@ -164,7 +164,7 @@ void ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
     }
 }
 
-static void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,
+static void add_pixels_clamped4_c(const int16_t *block, uint8_t *restrict pixels,
                           int line_size)
 {
     int i;
@@ -180,7 +180,7 @@ static void add_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pix
     }
 }
 
-static void add_pixels_clamped2_c(const int16_t *block, uint8_t *av_restrict pixels,
+static void add_pixels_clamped2_c(const int16_t *block, uint8_t *restrict pixels,
                           int line_size)
 {
     int i;
diff --git a/media/ffvpx/libavcodec/idctdsp.h b/media/ffvpx/libavcodec/idctdsp.h
index c840a5186f64f..c08242881c7b1 100644
--- a/media/ffvpx/libavcodec/idctdsp.h
+++ b/media/ffvpx/libavcodec/idctdsp.h
@@ -22,8 +22,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "config.h"
-
 struct AVCodecContext;
 
 enum idct_permutation_type {
@@ -45,13 +43,13 @@ int ff_init_scantable_permutation_x86(uint8_t *idct_permutation,
 typedef struct IDCTDSPContext {
     /* pixel ops : interface with DCT */
     void (*put_pixels_clamped)(const int16_t *block /* align 16 */,
-                               uint8_t *av_restrict pixels /* align 8 */,
+                               uint8_t *restrict pixels /* align 8 */,
                                ptrdiff_t line_size);
     void (*put_signed_pixels_clamped)(const int16_t *block /* align 16 */,
-                                      uint8_t *av_restrict pixels /* align 8 */,
+                                      uint8_t *restrict pixels /* align 8 */,
                                       ptrdiff_t line_size);
     void (*add_pixels_clamped)(const int16_t *block /* align 16 */,
-                               uint8_t *av_restrict pixels /* align 8 */,
+                               uint8_t *restrict pixels /* align 8 */,
                                ptrdiff_t line_size);
 
     void (*idct)(int16_t *block /* align 16 */);
@@ -91,9 +89,9 @@ typedef struct IDCTDSPContext {
     int mpeg4_studio_profile;
 } IDCTDSPContext;
 
-void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
+void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *restrict pixels,
                              ptrdiff_t line_size);
-void ff_add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,
+void ff_add_pixels_clamped_c(const int16_t *block, uint8_t *restrict pixels,
                              ptrdiff_t line_size);
 
 void ff_idctdsp_init(IDCTDSPContext *c, struct AVCodecContext *avctx);
diff --git a/media/ffvpx/libavcodec/internal.h b/media/ffvpx/libavcodec/internal.h
index eb9e0d707ceb6..64fe0122c8762 100644
--- a/media/ffvpx/libavcodec/internal.h
+++ b/media/ffvpx/libavcodec/internal.h
@@ -26,10 +26,7 @@
 
 #include <stdint.h>
 
-#include "libavutil/buffer.h"
 #include "libavutil/channel_layout.h"
-#include "libavutil/mathematics.h"
-#include "libavutil/pixfmt.h"
 #include "avcodec.h"
 #include "config.h"
 
@@ -147,6 +144,12 @@ typedef struct AVCodecInternal {
 #if CONFIG_LCMS2
     FFIccContext icc; /* used to read and write embedded ICC profiles */
 #endif
+
+    /**
+     * Set when the user has been warned about a failed allocation from
+     * a fixed frame pool.
+     */
+    int warned_on_failed_allocation_from_fixed_pool;
 } AVCodecInternal;
 
 /**
@@ -157,25 +160,6 @@ int ff_match_2uint16(const uint16_t (*tab)[2], int size, int a, int b);
 
 unsigned int ff_toupper4(unsigned int x);
 
-/**
- * 2^(x) for integer x
- * @return correctly rounded float
- */
-static av_always_inline float ff_exp2fi(int x) {
-    /* Normal range */
-    if (-126 <= x && x <= 128)
-        return av_int2float((x+127) << 23);
-    /* Too large */
-    else if (x > 128)
-        return INFINITY;
-    /* Subnormal numbers */
-    else if (x > -150)
-        return av_int2float(1 << (x+149));
-    /* Negligibly small */
-    else
-        return 0;
-}
-
 int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx);
 
 int avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec);
diff --git a/media/ffvpx/libavcodec/fdctdsp_init.c b/media/ffvpx/libavcodec/itut35.h
similarity index 50%
rename from media/ffvpx/libavcodec/fdctdsp_init.c
rename to media/ffvpx/libavcodec/itut35.h
index 0cb5fd625b3da..ffa7024981279 100644
--- a/media/ffvpx/libavcodec/fdctdsp_init.c
+++ b/media/ffvpx/libavcodec/itut35.h
@@ -16,29 +16,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "libavutil/attributes.h"
-#include "libavutil/cpu.h"
-#include "libavutil/x86/cpu.h"
-#include "libavcodec/avcodec.h"
-#include "libavcodec/fdctdsp.h"
-#include "fdct.h"
+#ifndef AVCODEC_ITUT35_H
+#define AVCODEC_ITUT35_H
 
-av_cold void ff_fdctdsp_init_x86(FDCTDSPContext *c, AVCodecContext *avctx,
-                                 unsigned high_bit_depth)
-{
-    int cpu_flags = av_get_cpu_flags();
-    const int dct_algo = avctx->dct_algo;
+#define ITU_T_T35_COUNTRY_CODE_CN 0x26
+#define ITU_T_T35_COUNTRY_CODE_US 0xB5
 
-    if (!high_bit_depth) {
-        if ((dct_algo == FF_DCT_AUTO || dct_algo == FF_DCT_MMX)) {
-            if (INLINE_MMX(cpu_flags))
-                c->fdct = ff_fdct_mmx;
+#define ITU_T_T35_PROVIDER_CODE_ATSC  0x31
+#define ITU_T_T35_PROVIDER_CODE_CUVA  0x04
+#define ITU_T_T35_PROVIDER_CODE_DOLBY 0x3B
+#define ITU_T_T35_PROVIDER_CODE_SMTPE 0x3C
 
-            if (INLINE_MMXEXT(cpu_flags))
-                c->fdct = ff_fdct_mmxext;
-
-            if (INLINE_SSE2(cpu_flags))
-                c->fdct = ff_fdct_sse2;
-        }
-    }
-}
+#endif /* AVCODEC_ITUT35_H */
diff --git a/media/ffvpx/libavcodec/leb.h b/media/ffvpx/libavcodec/leb.h
new file mode 100644
index 0000000000000..5159c434b1e4c
--- /dev/null
+++ b/media/ffvpx/libavcodec/leb.h
@@ -0,0 +1,70 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * leb128 handling implementations
+ */
+
+#ifndef AVCODEC_LEB_H
+#define AVCODEC_LEB_H
+
+#include "get_bits.h"
+
+/**
+ * Read a unsigned integer coded as a variable number of up to eight
+ * little-endian bytes, where the MSB in a byte signals another byte
+ * must be read.
+ * All coded bits are read, but values > UINT_MAX are truncated.
+ */
+static inline unsigned get_leb(GetBitContext *s) {
+    int more, i = 0;
+    unsigned leb = 0;
+
+    do {
+        int byte = get_bits(s, 8);
+        unsigned bits = byte & 0x7f;
+        more = byte & 0x80;
+        if (i <= 4)
+            leb |= bits << (i * 7);
+        if (++i == 8)
+            break;
+    } while (more);
+
+    return leb;
+}
+
+/**
+ * Read a unsigned integer coded as a variable number of up to eight
+ * little-endian bytes, where the MSB in a byte signals another byte
+ * must be read.
+ */
+static inline int64_t get_leb128(GetBitContext *gb) {
+    int64_t ret = 0;
+
+    for (int i = 0; i < 8; i++) {
+        int byte = get_bits(gb, 8);
+        ret |= (int64_t)(byte & 0x7f) << (i * 7);
+        if (!(byte & 0x80))
+            break;
+    }
+
+    return ret;
+}
+
+#endif /* AVCODEC_LEB_H */
diff --git a/media/ffvpx/libavcodec/libaomenc.c b/media/ffvpx/libavcodec/libaomenc.c
index aa800834fe76b..d660afab4ecc2 100644
--- a/media/ffvpx/libavcodec/libaomenc.c
+++ b/media/ffvpx/libavcodec/libaomenc.c
@@ -35,6 +35,7 @@
 #include "libavutil/cpu.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/mathematics.h"
+#include "libavutil/mem.h"
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
@@ -1467,13 +1468,13 @@ static const AVOption options[] = {
                          "alternate reference frame selection",    OFFSET(lag_in_frames),   AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE},
     { "arnr-max-frames", "altref noise reduction max frame count", OFFSET(arnr_max_frames), AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE},
     { "arnr-strength",   "altref noise reduction filter strength", OFFSET(arnr_strength),   AV_OPT_TYPE_INT, {.i64 = -1},      -1,      6,       VE},
-    { "aq-mode",         "adaptive quantization mode",             OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1},      -1,      4, VE, "aq_mode"},
-    { "none",            "Aq not used",         0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, "aq_mode"},
-    { "variance",        "Variance based Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, "aq_mode"},
-    { "complexity",      "Complexity based Aq", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, "aq_mode"},
-    { "cyclic",          "Cyclic Refresh Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, "aq_mode"},
-    { "error-resilience", "Error resilience configuration", OFFSET(error_resilient), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, VE, "er"},
-    { "default",         "Improve resiliency against losses of whole frames", 0, AV_OPT_TYPE_CONST, {.i64 = AOM_ERROR_RESILIENT_DEFAULT}, 0, 0, VE, "er"},
+    { "aq-mode",         "adaptive quantization mode",             OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1},      -1,      4, VE, .unit = "aq_mode"},
+    { "none",            "Aq not used",         0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, .unit = "aq_mode"},
+    { "variance",        "Variance based Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, .unit = "aq_mode"},
+    { "complexity",      "Complexity based Aq", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, .unit = "aq_mode"},
+    { "cyclic",          "Cyclic Refresh Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, .unit = "aq_mode"},
+    { "error-resilience", "Error resilience configuration", OFFSET(error_resilient), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, VE, .unit = "er"},
+    { "default",         "Improve resiliency against losses of whole frames", 0, AV_OPT_TYPE_CONST, {.i64 = AOM_ERROR_RESILIENT_DEFAULT}, 0, 0, VE, .unit = "er"},
     { "crf",              "Select the quality for constant quality mode", offsetof(AOMContext, crf), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 63, VE },
     { "static-thresh",    "A change threshold on blocks below which they will be skipped by the encoder", OFFSET(static_thresh), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
     { "drop-threshold",   "Frame drop threshold", offsetof(AOMContext, drop_threshold), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, VE },
@@ -1492,13 +1493,13 @@ static const AVOption options[] = {
     { "enable-global-motion",  "Enable global motion",             OFFSET(enable_global_motion), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE},
     { "enable-intrabc",  "Enable intra block copy prediction mode", OFFSET(enable_intrabc), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE},
     { "enable-restoration", "Enable Loop Restoration filtering", OFFSET(enable_restoration), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE},
-    { "usage",           "Quality and compression efficiency vs speed trade-off", OFFSET(usage), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, VE, "usage"},
-    { "good",            "Good quality",      0, AV_OPT_TYPE_CONST, {.i64 = 0 /* AOM_USAGE_GOOD_QUALITY */}, 0, 0, VE, "usage"},
-    { "realtime",        "Realtime encoding", 0, AV_OPT_TYPE_CONST, {.i64 = 1 /* AOM_USAGE_REALTIME */},     0, 0, VE, "usage"},
-    { "allintra",        "All Intra encoding", 0, AV_OPT_TYPE_CONST, {.i64 = 2 /* AOM_USAGE_ALL_INTRA */},    0, 0, VE, "usage"},
-    { "tune",            "The metric that the encoder tunes for. Automatically chosen by the encoder by default", OFFSET(tune), AV_OPT_TYPE_INT, {.i64 = -1}, -1, AOM_TUNE_SSIM, VE, "tune"},
-    { "psnr",            NULL,         0, AV_OPT_TYPE_CONST, {.i64 = AOM_TUNE_PSNR}, 0, 0, VE, "tune"},
-    { "ssim",            NULL,         0, AV_OPT_TYPE_CONST, {.i64 = AOM_TUNE_SSIM}, 0, 0, VE, "tune"},
+    { "usage",           "Quality and compression efficiency vs speed trade-off", OFFSET(usage), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, VE, .unit = "usage"},
+    { "good",            "Good quality",      0, AV_OPT_TYPE_CONST, {.i64 = 0 /* AOM_USAGE_GOOD_QUALITY */}, 0, 0, VE, .unit = "usage"},
+    { "realtime",        "Realtime encoding", 0, AV_OPT_TYPE_CONST, {.i64 = 1 /* AOM_USAGE_REALTIME */},     0, 0, VE, .unit = "usage"},
+    { "allintra",        "All Intra encoding", 0, AV_OPT_TYPE_CONST, {.i64 = 2 /* AOM_USAGE_ALL_INTRA */},    0, 0, VE, .unit = "usage"},
+    { "tune",            "The metric that the encoder tunes for. Automatically chosen by the encoder by default", OFFSET(tune), AV_OPT_TYPE_INT, {.i64 = -1}, -1, AOM_TUNE_SSIM, VE, .unit = "tune"},
+    { "psnr",            NULL,         0, AV_OPT_TYPE_CONST, {.i64 = AOM_TUNE_PSNR}, 0, 0, VE, .unit = "tune"},
+    { "ssim",            NULL,         0, AV_OPT_TYPE_CONST, {.i64 = AOM_TUNE_SSIM}, 0, 0, VE, .unit = "tune"},
     FF_AV1_PROFILE_OPTS
     { "still-picture", "Encode in single frame mode (typically used for still AVIF images).", OFFSET(still_picture), AV_OPT_TYPE_BOOL, {.i64 = 0}, -1, 1, VE },
     { "enable-rect-partitions", "Enable rectangular partitions", OFFSET(enable_rect_partitions), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, VE},
diff --git a/media/ffvpx/libavcodec/libdav1d.c b/media/ffvpx/libavcodec/libdav1d.c
index 11cdbca274853..f022a4ad05c28 100644
--- a/media/ffvpx/libavcodec/libdav1d.c
+++ b/media/ffvpx/libavcodec/libdav1d.c
@@ -35,7 +35,9 @@
 #include "bytestream.h"
 #include "codec_internal.h"
 #include "decode.h"
+#include "dovi_rpu.h"
 #include "internal.h"
+#include "itut35.h"
 
 #define FF_DAV1D_VERSION_AT_LEAST(x,y) \
     (DAV1D_API_VERSION_MAJOR > (x) || DAV1D_API_VERSION_MAJOR == (x) && DAV1D_API_VERSION_MINOR >= (y))
@@ -44,6 +46,7 @@ typedef struct Libdav1dContext {
     AVClass *class;
     Dav1dContext *c;
     AVBufferPool *pool;
+    DOVIContext dovi;
     int pool_size;
 
     Dav1dData data;
@@ -213,9 +216,10 @@ static av_cold int libdav1d_init(AVCodecContext *c)
 #else
     int threads = (c->thread_count ? c->thread_count : av_cpu_count()) * 3 / 2;
 #endif
+    const AVPacketSideData *sd;
     int res;
 
-    av_log(c, AV_LOG_INFO, "libdav1d %s\n", dav1d_version());
+    av_log(c, AV_LOG_VERBOSE, "libdav1d %s\n", dav1d_version());
 
     dav1d_default_settings(&s);
     s.logger.cookie = c;
@@ -285,6 +289,11 @@ static av_cold int libdav1d_init(AVCodecContext *c)
     c->delay = res > 1 ? res : 0;
 #endif
 
+    dav1d->dovi.logctx = c;
+    dav1d->dovi.dv_profile = 10; // default for AV1
+    sd = ff_get_coded_side_data(c, AV_PKT_DATA_DOVI_CONF);
+    if (sd && sd->size > 0)
+        ff_dovi_update_cfg(&dav1d->dovi, (AVDOVIDecoderConfigurationRecord *) sd->data);
     return 0;
 }
 
@@ -296,13 +305,6 @@ static void libdav1d_flush(AVCodecContext *c)
     dav1d_flush(dav1d->c);
 }
 
-typedef struct OpaqueData {
-    void    *pkt_orig_opaque;
-#if FF_API_REORDERED_OPAQUE
-    int64_t  reordered_opaque;
-#endif
-} OpaqueData;
-
 static void libdav1d_data_free(const uint8_t *data, void *opaque) {
     AVBufferRef *buf = opaque;
 
@@ -312,7 +314,6 @@ static void libdav1d_data_free(const uint8_t *data, void *opaque) {
 static void libdav1d_user_data_free(const uint8_t *data, void *opaque) {
     AVPacket *pkt = opaque;
     av_assert0(data == opaque);
-    av_free(pkt->opaque);
     av_packet_free(&pkt);
 }
 
@@ -335,8 +336,6 @@ static int libdav1d_receive_frame_internal(AVCodecContext *c, Dav1dPicture *p)
         }
 
         if (pkt->size) {
-            OpaqueData *od = NULL;
-
             res = dav1d_data_wrap(data, pkt->data, pkt->size,
                                   libdav1d_data_free, pkt->buf);
             if (res < 0) {
@@ -346,30 +345,9 @@ static int libdav1d_receive_frame_internal(AVCodecContext *c, Dav1dPicture *p)
 
             pkt->buf = NULL;
 
-FF_DISABLE_DEPRECATION_WARNINGS
-            if (
-#if FF_API_REORDERED_OPAQUE
-                c->reordered_opaque != AV_NOPTS_VALUE ||
-#endif
-                (pkt->opaque && (c->flags & AV_CODEC_FLAG_COPY_OPAQUE))) {
-                od = av_mallocz(sizeof(*od));
-                if (!od) {
-                    av_packet_free(&pkt);
-                    dav1d_data_unref(data);
-                    return AVERROR(ENOMEM);
-                }
-                od->pkt_orig_opaque  = pkt->opaque;
-#if FF_API_REORDERED_OPAQUE
-                od->reordered_opaque = c->reordered_opaque;
-#endif
-FF_ENABLE_DEPRECATION_WARNINGS
-            }
-            pkt->opaque = od;
-
             res = dav1d_data_wrap_user_data(data, (const uint8_t *)pkt,
                                             libdav1d_user_data_free, pkt);
             if (res < 0) {
-                av_free(pkt->opaque);
                 av_packet_free(&pkt);
                 dav1d_data_unref(data);
                 return res;
@@ -408,7 +386,6 @@ static int libdav1d_receive_frame(AVCodecContext *c, AVFrame *frame)
     Libdav1dContext *dav1d = c->priv_data;
     Dav1dPicture pic = { 0 }, *p = &pic;
     AVPacket *pkt;
-    OpaqueData *od = NULL;
 #if FF_DAV1D_VERSION_AT_LEAST(5,1)
     enum Dav1dEventFlags event_flags = 0;
 #endif
@@ -463,24 +440,9 @@ static int libdav1d_receive_frame(AVCodecContext *c, AVFrame *frame)
     ff_set_sar(c, frame->sample_aspect_ratio);
 
     pkt = (AVPacket *)p->m.user_data.data;
-    od  = pkt->opaque;
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (od && od->reordered_opaque != AV_NOPTS_VALUE)
-        frame->reordered_opaque = od->reordered_opaque;
-    else
-        frame->reordered_opaque = AV_NOPTS_VALUE;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
-    // restore the original user opaque value for
-    // ff_decode_frame_props_from_pkt()
-    pkt->opaque = od ? od->pkt_orig_opaque : NULL;
-    av_freep(&od);
 
     // match timestamps and packet size
     res = ff_decode_frame_props_from_pkt(c, frame, pkt);
-    pkt->opaque = NULL;
     if (res < 0)
         goto fail;
 
@@ -507,33 +469,38 @@ FF_ENABLE_DEPRECATION_WARNINGS
     }
 
     if (p->mastering_display) {
-        AVMasteringDisplayMetadata *mastering = av_mastering_display_metadata_create_side_data(frame);
-        if (!mastering) {
-            res = AVERROR(ENOMEM);
+        AVMasteringDisplayMetadata *mastering;
+
+        res = ff_decode_mastering_display_new(c, frame, &mastering);
+        if (res < 0)
             goto fail;
-        }
 
-        for (int i = 0; i < 3; i++) {
-            mastering->display_primaries[i][0] = av_make_q(p->mastering_display->primaries[i][0], 1 << 16);
-            mastering->display_primaries[i][1] = av_make_q(p->mastering_display->primaries[i][1], 1 << 16);
-        }
-        mastering->white_point[0] = av_make_q(p->mastering_display->white_point[0], 1 << 16);
-        mastering->white_point[1] = av_make_q(p->mastering_display->white_point[1], 1 << 16);
+        if (mastering) {
+            for (int i = 0; i < 3; i++) {
+                mastering->display_primaries[i][0] = av_make_q(p->mastering_display->primaries[i][0], 1 << 16);
+                mastering->display_primaries[i][1] = av_make_q(p->mastering_display->primaries[i][1], 1 << 16);
+            }
+            mastering->white_point[0] = av_make_q(p->mastering_display->white_point[0], 1 << 16);
+            mastering->white_point[1] = av_make_q(p->mastering_display->white_point[1], 1 << 16);
 
-        mastering->max_luminance = av_make_q(p->mastering_display->max_luminance, 1 << 8);
-        mastering->min_luminance = av_make_q(p->mastering_display->min_luminance, 1 << 14);
+            mastering->max_luminance = av_make_q(p->mastering_display->max_luminance, 1 << 8);
+            mastering->min_luminance = av_make_q(p->mastering_display->min_luminance, 1 << 14);
 
-        mastering->has_primaries = 1;
-        mastering->has_luminance = 1;
+            mastering->has_primaries = 1;
+            mastering->has_luminance = 1;
+        }
     }
     if (p->content_light) {
-        AVContentLightMetadata *light = av_content_light_metadata_create_side_data(frame);
-        if (!light) {
-            res = AVERROR(ENOMEM);
+        AVContentLightMetadata *light;
+
+        res = ff_decode_content_light_new(c, frame, &light);
+        if (res < 0)
             goto fail;
+
+        if (light) {
+            light->MaxCLL = p->content_light->max_content_light_level;
+            light->MaxFALL = p->content_light->max_frame_average_light_level;
         }
-        light->MaxCLL = p->content_light->max_content_light_level;
-        light->MaxFALL = p->content_light->max_frame_average_light_level;
     }
     if (p->itut_t35) {
 #if FF_DAV1D_VERSION_AT_LEAST(6,9)
@@ -549,7 +516,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         provider_code = bytestream2_get_be16(&gb);
         switch (provider_code) {
-        case 0x31: { // atsc_provider_code
+        case ITU_T_T35_PROVIDER_CODE_ATSC: {
             uint32_t user_identifier = bytestream2_get_be32(&gb);
             switch (user_identifier) {
             case MKBETAG('G', 'A', '9', '4'): { // closed captions
@@ -561,8 +528,9 @@ FF_ENABLE_DEPRECATION_WARNINGS
                 if (!res)
                     break;
 
-                if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_A53_CC, buf))
-                    av_buffer_unref(&buf);
+                res = ff_frame_new_side_data_from_buf(c, frame, AV_FRAME_DATA_A53_CC, &buf, NULL);
+                if (res < 0)
+                    goto fail;
 
                 c->properties |= FF_CODEC_PROPERTY_CLOSED_CAPTIONS;
                 break;
@@ -572,12 +540,12 @@ FF_ENABLE_DEPRECATION_WARNINGS
             }
             break;
         }
-        case 0x3C: { // smpte_provider_code
+        case ITU_T_T35_PROVIDER_CODE_SMTPE: {
             AVDynamicHDRPlus *hdrplus;
             int provider_oriented_code = bytestream2_get_be16(&gb);
             int application_identifier = bytestream2_get_byte(&gb);
 
-            if (itut_t35->country_code != 0xB5 ||
+            if (itut_t35->country_code != ITU_T_T35_COUNTRY_CODE_US ||
                 provider_oriented_code != 1 || application_identifier != 4)
                 break;
 
@@ -593,6 +561,24 @@ FF_ENABLE_DEPRECATION_WARNINGS
                 goto fail;
             break;
         }
+        case ITU_T_T35_PROVIDER_CODE_DOLBY: {
+            int provider_oriented_code = bytestream2_get_be32(&gb);
+            if (itut_t35->country_code != ITU_T_T35_COUNTRY_CODE_US ||
+                provider_oriented_code != 0x800)
+                break;
+
+            res = ff_dovi_rpu_parse(&dav1d->dovi, gb.buffer, gb.buffer_end - gb.buffer,
+                                    c->err_recognition);
+            if (res < 0) {
+                av_log(c, AV_LOG_WARNING, "Error parsing DOVI OBU.\n");
+                break; // ignore
+            }
+
+            res = ff_dovi_attach_side_data(&dav1d->dovi, frame);
+            if (res < 0)
+                goto fail;
+            break;
+        }
         default: // ignore unsupported provider codes
             break;
         }
@@ -603,6 +589,8 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (p->frame_hdr->film_grain.present && (!dav1d->apply_grain ||
         (c->export_side_data & AV_CODEC_EXPORT_DATA_FILM_GRAIN))) {
         AVFilmGrainParams *fgp = av_film_grain_params_create_side_data(frame);
+        const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(frame->format);
+        av_assert0(pixdesc);
         if (!fgp) {
             res = AVERROR(ENOMEM);
             goto fail;
@@ -610,6 +598,14 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         fgp->type = AV_FILM_GRAIN_PARAMS_AV1;
         fgp->seed = p->frame_hdr->film_grain.data.seed;
+        fgp->width = frame->width;
+        fgp->height = frame->height;
+        fgp->color_range = frame->color_range;
+        fgp->color_primaries = frame->color_primaries;
+        fgp->color_trc = frame->color_trc;
+        fgp->color_space = frame->colorspace;
+        fgp->subsampling_x = pixdesc->log2_chroma_w;
+        fgp->subsampling_y = pixdesc->log2_chroma_h;
         fgp->codec.aom.num_y_points = p->frame_hdr->film_grain.data.num_y_points;
         fgp->codec.aom.chroma_scaling_from_luma = p->frame_hdr->film_grain.data.chroma_scaling_from_luma;
         fgp->codec.aom.scaling_shift = p->frame_hdr->film_grain.data.scaling_shift;
@@ -652,6 +648,7 @@ static av_cold int libdav1d_close(AVCodecContext *c)
     Libdav1dContext *dav1d = c->priv_data;
 
     av_buffer_pool_uninit(&dav1d->pool);
+    ff_dovi_ctx_unref(&dav1d->dovi);
     dav1d_data_unref(&dav1d->data);
     dav1d_close(&dav1d->c);
 
diff --git a/media/ffvpx/libavcodec/libopusenc.c b/media/ffvpx/libavcodec/libopusenc.c
index 68667e33503e5..d1095d3177606 100644
--- a/media/ffvpx/libavcodec/libopusenc.c
+++ b/media/ffvpx/libavcodec/libopusenc.c
@@ -23,6 +23,7 @@
 #include <opus_multistream.h>
 
 #include "libavutil/channel_layout.h"
+#include "libavutil/mem.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
 #include "bytestream.h"
@@ -552,18 +553,18 @@ static av_cold int libopus_encode_close(AVCodecContext *avctx)
 #define OFFSET(x) offsetof(LibopusEncContext, opts.x)
 #define FLAGS AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption libopus_options[] = {
-    { "application",    "Intended application type",           OFFSET(application),    AV_OPT_TYPE_INT,   { .i64 = OPUS_APPLICATION_AUDIO }, OPUS_APPLICATION_VOIP, OPUS_APPLICATION_RESTRICTED_LOWDELAY, FLAGS, "application" },
-        { "voip",           "Favor improved speech intelligibility",   0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_VOIP },                0, 0, FLAGS, "application" },
-        { "audio",          "Favor faithfulness to the input",         0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_AUDIO },               0, 0, FLAGS, "application" },
-        { "lowdelay",       "Restrict to only the lowest delay modes", 0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_RESTRICTED_LOWDELAY }, 0, 0, FLAGS, "application" },
+    { "application",    "Intended application type",           OFFSET(application),    AV_OPT_TYPE_INT,   { .i64 = OPUS_APPLICATION_AUDIO }, OPUS_APPLICATION_VOIP, OPUS_APPLICATION_RESTRICTED_LOWDELAY, FLAGS, .unit = "application" },
+        { "voip",           "Favor improved speech intelligibility",   0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_VOIP },                0, 0, FLAGS, .unit = "application" },
+        { "audio",          "Favor faithfulness to the input",         0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_AUDIO },               0, 0, FLAGS, .unit = "application" },
+        { "lowdelay",       "Restrict to only the lowest delay modes, disable voice-optimized modes", 0, AV_OPT_TYPE_CONST, { .i64 = OPUS_APPLICATION_RESTRICTED_LOWDELAY }, 0, 0, FLAGS, .unit = "application" },
     { "frame_duration", "Duration of a frame in milliseconds", OFFSET(frame_duration), AV_OPT_TYPE_FLOAT, { .dbl = 20.0 }, 2.5, 120.0, FLAGS },
     { "packet_loss",    "Expected packet loss percentage",     OFFSET(packet_loss),    AV_OPT_TYPE_INT,   { .i64 = 0 },    0,   100,  FLAGS },
     { "fec",             "Enable inband FEC. Expected packet loss must be non-zero",     OFFSET(fec),    AV_OPT_TYPE_BOOL,   { .i64 = 0 }, 0, 1, FLAGS },
-    { "vbr",            "Variable bit rate mode",              OFFSET(vbr),            AV_OPT_TYPE_INT,   { .i64 = 1 },    0,   2,    FLAGS, "vbr" },
-        { "off",            "Use constant bit rate", 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, "vbr" },
-        { "on",             "Use variable bit rate", 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, "vbr" },
-        { "constrained",    "Use constrained VBR",   0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, "vbr" },
-    { "mapping_family", "Channel Mapping Family",              OFFSET(mapping_family), AV_OPT_TYPE_INT,   { .i64 = -1 },   -1,  255,  FLAGS, "mapping_family" },
+    { "vbr",            "Variable bit rate mode",              OFFSET(vbr),            AV_OPT_TYPE_INT,   { .i64 = 1 },    0,   2,    FLAGS, .unit = "vbr" },
+        { "off",            "Use constant bit rate", 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, FLAGS, .unit = "vbr" },
+        { "on",             "Use variable bit rate", 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, FLAGS, .unit = "vbr" },
+        { "constrained",    "Use constrained VBR",   0, AV_OPT_TYPE_CONST, { .i64 = 2 }, 0, 0, FLAGS, .unit = "vbr" },
+    { "mapping_family", "Channel Mapping Family",              OFFSET(mapping_family), AV_OPT_TYPE_INT,   { .i64 = -1 },   -1,  255,  FLAGS, .unit = "mapping_family" },
     { "dtx", "Enable DTX", OFFSET(dtx), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
 #ifdef OPUS_SET_PHASE_INVERSION_DISABLED_REQUEST
     { "apply_phase_inv", "Apply intensity stereo phase inversion", OFFSET(apply_phase_inv), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, FLAGS },
diff --git a/media/ffvpx/libavcodec/libvorbisenc.c b/media/ffvpx/libavcodec/libvorbisenc.c
index 6331cf0d79532..e4f8cb67ef6e3 100644
--- a/media/ffvpx/libavcodec/libvorbisenc.c
+++ b/media/ffvpx/libavcodec/libvorbisenc.c
@@ -23,6 +23,7 @@
 #include "libavutil/avassert.h"
 #include "libavutil/channel_layout.h"
 #include "libavutil/fifo.h"
+#include "libavutil/mem.h"
 #include "libavutil/opt.h"
 #include "avcodec.h"
 #include "audio_frame_queue.h"
diff --git a/media/ffvpx/libavcodec/libvpxenc.c b/media/ffvpx/libavcodec/libvpxenc.c
index 80988a2608fe3..bcbdc4981e599 100644
--- a/media/ffvpx/libavcodec/libvpxenc.c
+++ b/media/ffvpx/libavcodec/libvpxenc.c
@@ -33,8 +33,8 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "encode.h"
-#include "internal.h"
 #include "libavutil/avassert.h"
+#include "libavutil/mem.h"
 #include "libvpx.h"
 #include "packet_internal.h"
 #include "profiles.h"
@@ -49,6 +49,9 @@
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
 
+#define IS_VP9(avctx) (CONFIG_LIBVPX_VP9_ENCODER && avctx->codec_id == AV_CODEC_ID_VP9)
+#define IS_VP8(avctx) (CONFIG_LIBVPX_VP8_ENCODER && avctx->codec_id == AV_CODEC_ID_VP8)
+
 /**
  * Portion of struct vpx_codec_cx_pkt from vpx_encoder.h.
  * One encoded frame returned from the library.
@@ -68,9 +71,6 @@ typedef struct FrameData {
     int64_t pts;
     int64_t duration;
 
-#if FF_API_REORDERED_OPAQUE
-    int64_t      reordered_opaque;
-#endif
     void        *frame_opaque;
     AVBufferRef *frame_opaque_ref;
 
@@ -121,6 +121,9 @@ typedef struct VPxEncoderContext {
     int *ts_layer_flags;
     int current_temporal_idx;
 
+    // VP8-only
+    int screen_content_mode;
+
     // VP9-only
     int lossless;
     int tile_columns;
@@ -164,6 +167,7 @@ static const char *const ctlidstr[] = {
     [VP8E_SET_MAX_INTRA_BITRATE_PCT] = "VP8E_SET_MAX_INTRA_BITRATE_PCT",
     [VP8E_SET_SHARPNESS]               = "VP8E_SET_SHARPNESS",
     [VP8E_SET_TEMPORAL_LAYER_ID]       = "VP8E_SET_TEMPORAL_LAYER_ID",
+    [VP8E_SET_SCREEN_CONTENT_MODE]     = "VP8E_SET_SCREEN_CONTENT_MODE",
 #if CONFIG_LIBVPX_VP9_ENCODER
     [VP9E_SET_LOSSLESS]                = "VP9E_SET_LOSSLESS",
     [VP9E_SET_TILE_COLUMNS]            = "VP9E_SET_TILE_COLUMNS",
@@ -356,21 +360,20 @@ static int frame_data_submit(AVCodecContext *avctx, AVFifo *fifo,
     const struct vpx_codec_enc_cfg *enccfg = ctx->encoder.config.enc;
 
     FrameData fd = { .pts = frame->pts };
-
-    AVFrameSideData *av_uninit(sd);
     int ret;
 
-#if CONFIG_LIBVPX_VP9_ENCODER
-    // Keep HDR10+ if it has bit depth higher than 8 and
-    // it has PQ trc (SMPTE2084).
-    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_DYNAMIC_HDR_PLUS);
-    if (avctx->codec_id == AV_CODEC_ID_VP9 && sd &&
+    if (IS_VP9(avctx) &&
+        // Keep HDR10+ if it has bit depth higher than 8 and
+        // it has PQ trc (SMPTE2084).
         enccfg->g_bit_depth > 8 && avctx->color_trc == AVCOL_TRC_SMPTE2084) {
-        fd.hdr10_plus = av_buffer_ref(sd->buf);
-        if (!fd.hdr10_plus)
-            return AVERROR(ENOMEM);
+        const AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_DYNAMIC_HDR_PLUS);
+
+        if (sd) {
+            fd.hdr10_plus = av_buffer_ref(sd->buf);
+            if (!fd.hdr10_plus)
+                return AVERROR(ENOMEM);
+        }
     }
-#endif
 
     fd.duration     = frame->duration;
     fd.frame_opaque = frame->opaque;
@@ -379,11 +382,6 @@ static int frame_data_submit(AVCodecContext *avctx, AVFifo *fifo,
         if (ret < 0)
             goto fail;
     }
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    fd.reordered_opaque = frame->reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     ret = av_fifo_write(fifo, &fd, 1);
     if (ret < 0)
@@ -410,12 +408,6 @@ static int frame_data_apply(AVCodecContext *avctx, AVFifo *fifo, AVPacket *pkt)
         goto skip;
     }
 
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    avctx->reordered_opaque = fd.reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     pkt->duration = fd.duration;
     if (avctx->flags & AV_CODEC_FLAG_COPY_OPAQUE) {
         pkt->opaque         = fd.frame_opaque;
@@ -794,7 +786,7 @@ static int set_pix_fmt(AVCodecContext *avctx, vpx_codec_caps_t codec_caps,
                        struct vpx_codec_enc_cfg *enccfg, vpx_codec_flags_t *flags,
                        vpx_img_fmt_t *img_fmt)
 {
-    VPxContext av_unused *ctx = avctx->priv_data;
+    VPxContext *ctx = avctx->priv_data;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
     enccfg->g_bit_depth = enccfg->g_input_bit_depth = desc->comp[0].depth;
     switch (avctx->pix_fmt) {
@@ -1262,6 +1254,14 @@ static av_cold int vpx_init(AVCodecContext *avctx,
 #endif
     }
 #endif
+    if (avctx->codec_id == AV_CODEC_ID_VP8 && ctx->screen_content_mode >= 0) {
+        if (ctx->screen_content_mode == 2 && ctx->is_alpha) {
+            av_log(avctx, AV_LOG_ERROR,
+                   "Transparency encoding with screen mode with aggressive rate control not supported\n");
+            return AVERROR(EINVAL);
+        }
+        codecctl_int(avctx, VP8E_SET_SCREEN_CONTENT_MODE, ctx->screen_content_mode);
+    }
 
     av_log(avctx, AV_LOG_DEBUG, "Using deadline: %d\n", ctx->deadline);
 
@@ -1902,24 +1902,24 @@ FF_ENABLE_DEPRECATION_WARNINGS
                          "alternate reference frame selection",    OFFSET(lag_in_frames),   AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE}, \
     { "arnr-maxframes",  "altref noise reduction max frame count", OFFSET(arnr_max_frames), AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE}, \
     { "arnr-strength",   "altref noise reduction filter strength", OFFSET(arnr_strength),   AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE}, \
-    { "arnr-type",       "altref noise reduction filter type",     OFFSET(arnr_type),       AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE, "arnr_type"}, \
-    { "backward",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, "arnr_type" }, \
-    { "forward",         NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, "arnr_type" }, \
-    { "centered",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, "arnr_type" }, \
-    { "tune",            "Tune the encoding to a specific scenario", OFFSET(tune),          AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE, "tune"}, \
-    { "psnr",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VP8_TUNE_PSNR}, 0, 0, VE, "tune"}, \
-    { "ssim",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VP8_TUNE_SSIM}, 0, 0, VE, "tune"}, \
-    { "deadline",        "Time to spend encoding, in microseconds.", OFFSET(deadline),      AV_OPT_TYPE_INT, {.i64 = VPX_DL_GOOD_QUALITY}, INT_MIN, INT_MAX, VE, "quality"}, \
-    { "best",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_BEST_QUALITY}, 0, 0, VE, "quality"}, \
-    { "good",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_GOOD_QUALITY}, 0, 0, VE, "quality"}, \
-    { "realtime",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_REALTIME},     0, 0, VE, "quality"}, \
-    { "error-resilient", "Error resilience configuration", OFFSET(error_resilient), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, VE, "er"}, \
+    { "arnr-type",       "altref noise reduction filter type",     OFFSET(arnr_type),       AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE, .unit = "arnr_type"}, \
+    { "backward",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, .unit = "arnr_type" }, \
+    { "forward",         NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, .unit = "arnr_type" }, \
+    { "centered",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, .unit = "arnr_type" }, \
+    { "tune",            "Tune the encoding to a specific scenario", OFFSET(tune),          AV_OPT_TYPE_INT, {.i64 = -1},      -1,      INT_MAX, VE, .unit = "tune"}, \
+    { "psnr",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VP8_TUNE_PSNR}, 0, 0, VE, .unit = "tune"}, \
+    { "ssim",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VP8_TUNE_SSIM}, 0, 0, VE, .unit = "tune"}, \
+    { "deadline",        "Time to spend encoding, in microseconds.", OFFSET(deadline),      AV_OPT_TYPE_INT, {.i64 = VPX_DL_GOOD_QUALITY}, INT_MIN, INT_MAX, VE, .unit = "quality"}, \
+    { "best",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_BEST_QUALITY}, 0, 0, VE, .unit = "quality"}, \
+    { "good",            NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_GOOD_QUALITY}, 0, 0, VE, .unit = "quality"}, \
+    { "realtime",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = VPX_DL_REALTIME},     0, 0, VE, .unit = "quality"}, \
+    { "error-resilient", "Error resilience configuration", OFFSET(error_resilient), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, VE, .unit = "er"}, \
     { "max-intra-rate",  "Maximum I-frame bitrate (pct) 0=unlimited",  OFFSET(max_intra_rate),  AV_OPT_TYPE_INT,  {.i64 = -1}, -1,      INT_MAX, VE}, \
-    { "default",         "Improve resiliency against losses of whole frames", 0, AV_OPT_TYPE_CONST, {.i64 = VPX_ERROR_RESILIENT_DEFAULT}, 0, 0, VE, "er"}, \
+    { "default",         "Improve resiliency against losses of whole frames", 0, AV_OPT_TYPE_CONST, {.i64 = VPX_ERROR_RESILIENT_DEFAULT}, 0, 0, VE, .unit = "er"}, \
     { "partitions",      "The frame partitions are independently decodable " \
                          "by the bool decoder, meaning that partitions can be decoded even " \
                          "though earlier partitions have been lost. Note that intra prediction" \
-                         " is still done over the partition boundary.",       0, AV_OPT_TYPE_CONST, {.i64 = VPX_ERROR_RESILIENT_PARTITIONS}, 0, 0, VE, "er"}, \
+                         " is still done over the partition boundary.",       0, AV_OPT_TYPE_CONST, {.i64 = VPX_ERROR_RESILIENT_PARTITIONS}, 0, 0, VE, .unit = "er"}, \
     { "crf",              "Select the quality for constant quality mode", offsetof(VPxContext, crf), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 63, VE }, \
     { "static-thresh",    "A change threshold on blocks below which they will be skipped by the encoder", OFFSET(static_thresh), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE }, \
     { "drop-threshold",   "Frame drop threshold", offsetof(VPxContext, drop_threshold), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX, VE }, \
@@ -1930,10 +1930,10 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
 #define LEGACY_OPTIONS \
     {"speed", "", offsetof(VPxContext, cpu_used), AV_OPT_TYPE_INT, {.i64 = 1}, -16, 16, VE}, \
-    {"quality", "", offsetof(VPxContext, deadline), AV_OPT_TYPE_INT, {.i64 = VPX_DL_GOOD_QUALITY}, INT_MIN, INT_MAX, VE, "quality"}, \
-    {"vp8flags", "", offsetof(VPxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, UINT_MAX, VE, "flags"}, \
-    {"error_resilient", "enable error resilience", 0, AV_OPT_TYPE_CONST, {.i64 = VP8F_ERROR_RESILIENT}, INT_MIN, INT_MAX, VE, "flags"}, \
-    {"altref", "enable use of alternate reference frames (VP8/2-pass only)", 0, AV_OPT_TYPE_CONST, {.i64 = VP8F_AUTO_ALT_REF}, INT_MIN, INT_MAX, VE, "flags"}, \
+    {"quality", "", offsetof(VPxContext, deadline), AV_OPT_TYPE_INT, {.i64 = VPX_DL_GOOD_QUALITY}, INT_MIN, INT_MAX, VE, .unit = "quality"}, \
+    {"vp8flags", "", offsetof(VPxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, UINT_MAX, VE, .unit = "flags"}, \
+    {"error_resilient", "enable error resilience", 0, AV_OPT_TYPE_CONST, {.i64 = VP8F_ERROR_RESILIENT}, INT_MIN, INT_MAX, VE, .unit = "flags"}, \
+    {"altref", "enable use of alternate reference frames (VP8/2-pass only)", 0, AV_OPT_TYPE_CONST, {.i64 = VP8F_AUTO_ALT_REF}, INT_MIN, INT_MAX, VE, .unit = "flags"}, \
     {"arnr_max_frames", "altref noise reduction max frame count", offsetof(VPxContext, arnr_max_frames), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 15, VE}, \
     {"arnr_strength", "altref noise reduction filter strength", offsetof(VPxContext, arnr_strength), AV_OPT_TYPE_INT, {.i64 = 3}, 0, 6, VE}, \
     {"arnr_type", "altref noise reduction filter type", offsetof(VPxContext, arnr_type), AV_OPT_TYPE_INT, {.i64 = 3}, 1, 3, VE}, \
@@ -1946,6 +1946,7 @@ static const AVOption vp8_options[] = {
     { "auto-alt-ref",    "Enable use of alternate reference "
                          "frames (2-pass only)",                        OFFSET(auto_alt_ref),    AV_OPT_TYPE_INT, {.i64 = -1}, -1,  2, VE},
     { "cpu-used",        "Quality/Speed ratio modifier",                OFFSET(cpu_used),        AV_OPT_TYPE_INT, {.i64 = 1}, -16, 16, VE},
+    { "screen-content-mode",     "Encoder screen content mode",         OFFSET(screen_content_mode), AV_OPT_TYPE_INT, {.i64 = -1}, -1,  2, VE},
     LEGACY_OPTIONS
     { NULL }
 };
@@ -1962,16 +1963,16 @@ static const AVOption vp9_options[] = {
     { "tile-rows",       "Number of tile rows to use, log2",            OFFSET(tile_rows),       AV_OPT_TYPE_INT, {.i64 = -1}, -1, 2, VE},
     { "frame-parallel",  "Enable frame parallel decodability features", OFFSET(frame_parallel),  AV_OPT_TYPE_BOOL,{.i64 = -1}, -1, 1, VE},
 #if VPX_ENCODER_ABI_VERSION >= 12
-    { "aq-mode",         "adaptive quantization mode",                  OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1}, -1, 4, VE, "aq_mode"},
+    { "aq-mode",         "adaptive quantization mode",                  OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1}, -1, 4, VE, .unit = "aq_mode"},
 #else
-    { "aq-mode",         "adaptive quantization mode",                  OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1}, -1, 3, VE, "aq_mode"},
+    { "aq-mode",         "adaptive quantization mode",                  OFFSET(aq_mode),         AV_OPT_TYPE_INT, {.i64 = -1}, -1, 3, VE, .unit = "aq_mode"},
 #endif
-    { "none",            "Aq not used",         0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, "aq_mode" },
-    { "variance",        "Variance based Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, "aq_mode" },
-    { "complexity",      "Complexity based Aq", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, "aq_mode" },
-    { "cyclic",          "Cyclic Refresh Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, "aq_mode" },
+    { "none",            "Aq not used",         0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, .unit = "aq_mode" },
+    { "variance",        "Variance based Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, .unit = "aq_mode" },
+    { "complexity",      "Complexity based Aq", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, .unit = "aq_mode" },
+    { "cyclic",          "Cyclic Refresh Aq",   0, AV_OPT_TYPE_CONST, {.i64 = 3}, 0, 0, VE, .unit = "aq_mode" },
 #if VPX_ENCODER_ABI_VERSION >= 12
-    { "equator360",      "360 video Aq",        0, AV_OPT_TYPE_CONST, {.i64 = 4}, 0, 0, VE, "aq_mode" },
+    { "equator360",      "360 video Aq",        0, AV_OPT_TYPE_CONST, {.i64 = 4}, 0, 0, VE, .unit = "aq_mode" },
     {"level", "Specify level", OFFSET(level), AV_OPT_TYPE_FLOAT, {.dbl=-1}, -1, 6.2, VE},
 #endif
 #ifdef VPX_CTRL_VP9E_SET_ROW_MT
@@ -1979,14 +1980,14 @@ static const AVOption vp9_options[] = {
 #endif
 #ifdef VPX_CTRL_VP9E_SET_TUNE_CONTENT
 #if VPX_ENCODER_ABI_VERSION >= 14
-    { "tune-content",    "Tune content type", OFFSET(tune_content), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 2, VE, "tune_content" },
+    { "tune-content",    "Tune content type", OFFSET(tune_content), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 2, VE, .unit = "tune_content" },
 #else
-    { "tune-content",    "Tune content type", OFFSET(tune_content), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 1, VE, "tune_content" },
+    { "tune-content",    "Tune content type", OFFSET(tune_content), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 1, VE, .unit = "tune_content" },
 #endif
-    { "default",         "Regular video content",                  0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, "tune_content" },
-    { "screen",          "Screen capture content",                 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, "tune_content" },
+    { "default",         "Regular video content",                  0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VE, .unit = "tune_content" },
+    { "screen",          "Screen capture content",                 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VE, .unit = "tune_content" },
 #if VPX_ENCODER_ABI_VERSION >= 14
-    { "film",            "Film content; improves grain retention", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, "tune_content" },
+    { "film",            "Film content; improves grain retention", 0, AV_OPT_TYPE_CONST, {.i64 = 2}, 0, 0, VE, .unit = "tune_content" },
 #endif
 #endif
 #if VPX_ENCODER_ABI_VERSION >= 14
diff --git a/media/ffvpx/libavcodec/me_cmp.h b/media/ffvpx/libavcodec/me_cmp.h
index aefd32a7dc9d6..fee0ecb28e7ce 100644
--- a/media/ffvpx/libavcodec/me_cmp.h
+++ b/media/ffvpx/libavcodec/me_cmp.h
@@ -86,6 +86,7 @@ void ff_me_cmp_init_aarch64(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_alpha(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_arm(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_ppc(MECmpContext *c, AVCodecContext *avctx);
+void ff_me_cmp_init_riscv(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_x86(MECmpContext *c, AVCodecContext *avctx);
 void ff_me_cmp_init_mips(MECmpContext *c, AVCodecContext *avctx);
 
diff --git a/media/ffvpx/libavcodec/moz.build b/media/ffvpx/libavcodec/moz.build
index 886fa7a2cb74a..6f09049a6068d 100644
--- a/media/ffvpx/libavcodec/moz.build
+++ b/media/ffvpx/libavcodec/moz.build
@@ -15,6 +15,8 @@ if CONFIG['FFVPX_ASFLAGS']:
 if CONFIG['TARGET_CPU'] == 'aarch64':
     DIRS += ['aarch64']
 
+DIRS += ['bsf']
+
 LOCAL_INCLUDES += ['/modules/fdlibm/inexact-math-override']
 
 SharedLibrary('mozavcodec')
@@ -23,8 +25,6 @@ SOURCES += [
     'audio_frame_queue.c',
     'avcodec.c',
     'avdct.c',
-    'avfft.c',
-    'avpacket.c',
     'bitstream.c',
     'bitstream_filters.c',
     'bsf.c',
@@ -62,8 +62,8 @@ SOURCES += [
     'mpegaudiodsp_fixed.c',
     'mpegaudiodsp_float.c',
     'mpegaudiotabs.c',
-    'null_bsf.c',
     'options.c',
+    'packet.c',
     'parser.c',
     'parsers.c',
     'pcm.c',
@@ -85,10 +85,8 @@ SOURCES += [
 if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
     SOURCES += [
         'atsc_a53.c',
-        'av1_frame_split_bsf.c',
         'av1_parse.c',
         'av1dec.c',
-        'avpicture.c',
         'cbs.c',
         'cbs_av1.c',
         'golomb.c',
@@ -109,7 +107,6 @@ if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
         'vp8dsp.c',
         'vp9.c',
         'vp9_parser.c',
-        'vp9_superframe_split_bsf.c',
         'vp9block.c',
         'vp9data.c',
         'vp9dsp.c',
@@ -143,6 +140,11 @@ LOCAL_INCLUDES += [
     '/media/libvorbis',
 ]
 
+c11_flags = ["-std=gnu11"]
+if CONFIG["CC_TYPE"] == "clang-cl":
+    c11_flags.insert(0, "-Xclang")
+CFLAGS += c11_flags
+
 if not CONFIG["MOZ_SYSTEM_LIBVPX"]:
   LOCAL_INCLUDES += ['/media/libvpx']
 else:
diff --git a/media/ffvpx/libavcodec/mpegaudiodata.h b/media/ffvpx/libavcodec/mpegaudiodata.h
index fbad67a0b37c1..720c4bee6453c 100644
--- a/media/ffvpx/libavcodec/mpegaudiodata.h
+++ b/media/ffvpx/libavcodec/mpegaudiodata.h
@@ -31,11 +31,13 @@
 
 #include "config.h"
 
+#include "libavutil/attributes_internal.h"
 #include "vlc.h"
 
 #define MODE_EXT_MS_STEREO 2
 #define MODE_EXT_I_STEREO  1
 
+FF_VISIBILITY_PUSH_HIDDEN
 extern const uint16_t ff_mpa_bitrate_tab[2][3][15];
 extern const uint16_t ff_mpa_freq_tab[3];
 extern const int ff_mpa_sblimit_table[5];
@@ -78,5 +80,6 @@ extern const uint8_t ff_mpa_pretab[2][22];
 /* Initialize tables shared between the fixed and
  * floating point MPEG audio decoders. */
 void ff_mpegaudiodec_common_init_static(void);
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_MPEGAUDIODATA_H */
diff --git a/media/ffvpx/libavcodec/mpegaudiodec_template.c b/media/ffvpx/libavcodec/mpegaudiodec_template.c
index c227604107906..c73b1e0054d1a 100644
--- a/media/ffvpx/libavcodec/mpegaudiodec_template.c
+++ b/media/ffvpx/libavcodec/mpegaudiodec_template.c
@@ -32,6 +32,7 @@
 #include "libavutil/crc.h"
 #include "libavutil/float_dsp.h"
 #include "libavutil/libm.h"
+#include "libavutil/mem.h"
 #include "libavutil/mem_internal.h"
 #include "libavutil/thread.h"
 
@@ -92,7 +93,7 @@ typedef struct MPADecodeContext {
     int err_recognition;
     AVCodecContext* avctx;
     MPADSPContext mpadsp;
-    void (*butterflies_float)(float *av_restrict v1, float *av_restrict v2, int len);
+    void (*butterflies_float)(float *restrict v1, float *restrict v2, int len);
     AVFrame *frame;
     uint32_t crc;
 } MPADecodeContext;
diff --git a/media/ffvpx/libavcodec/mpegaudiodectab.h b/media/ffvpx/libavcodec/mpegaudiodectab.h
deleted file mode 100644
index accd12b8e2d8b..0000000000000
--- a/media/ffvpx/libavcodec/mpegaudiodectab.h
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * MPEG Audio decoder
- * copyright (c) 2002 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file
- * mpeg audio layer decoder tables.
- */
-
-#ifndef AVCODEC_MPEGAUDIODECTAB_H
-#define AVCODEC_MPEGAUDIODECTAB_H
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include "mpegaudio.h"
-
-/*******************************************************/
-/* layer 3 tables */
-
-/* layer 3 huffman tables */
-typedef struct HuffTable {
-    int xsize;
-    const uint8_t *bits;
-    const uint16_t *codes;
-} HuffTable;
-
-/* layer3 scale factor size */
-static const uint8_t slen_table[2][16] = {
-    { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 },
-    { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 },
-};
-
-/* number of lsf scale factors for a given size */
-static const uint8_t lsf_nsf_table[6][3][4] = {
-    { {  6,  5,  5, 5 }, {  9,  9,  9, 9 }, {  6,  9,  9, 9 } },
-    { {  6,  5,  7, 3 }, {  9,  9, 12, 6 }, {  6,  9, 12, 6 } },
-    { { 11, 10,  0, 0 }, { 18, 18,  0, 0 }, { 15, 18,  0, 0 } },
-    { {  7,  7,  7, 0 }, { 12, 12, 12, 0 }, {  6, 15, 12, 0 } },
-    { {  6,  6,  6, 3 }, { 12,  9,  9, 6 }, {  6, 12,  9, 6 } },
-    { {  8,  8,  5, 0 }, { 15, 12,  9, 0 }, {  6, 18,  9, 0 } },
-};
-
-/* mpegaudio layer 3 huffman tables */
-
-static const uint16_t mpa_huffcodes_1[4] = {
- 0x0001, 0x0001, 0x0001, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_1[4] = {
-  1,  3,  2,  3,
-};
-
-static const uint16_t mpa_huffcodes_2[9] = {
- 0x0001, 0x0002, 0x0001, 0x0003, 0x0001, 0x0001, 0x0003, 0x0002,
- 0x0000,
-};
-
-static const uint8_t mpa_huffbits_2[9] = {
-  1,  3,  6,  3,  3,  5,  5,  5,
-  6,
-};
-
-static const uint16_t mpa_huffcodes_3[9] = {
- 0x0003, 0x0002, 0x0001, 0x0001, 0x0001, 0x0001, 0x0003, 0x0002,
- 0x0000,
-};
-
-static const uint8_t mpa_huffbits_3[9] = {
-  2,  2,  6,  3,  2,  5,  5,  5,
-  6,
-};
-
-static const uint16_t mpa_huffcodes_5[16] = {
- 0x0001, 0x0002, 0x0006, 0x0005, 0x0003, 0x0001, 0x0004, 0x0004,
- 0x0007, 0x0005, 0x0007, 0x0001, 0x0006, 0x0001, 0x0001, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_5[16] = {
-  1,  3,  6,  7,  3,  3,  6,  7,
-  6,  6,  7,  8,  7,  6,  7,  8,
-};
-
-static const uint16_t mpa_huffcodes_6[16] = {
- 0x0007, 0x0003, 0x0005, 0x0001, 0x0006, 0x0002, 0x0003, 0x0002,
- 0x0005, 0x0004, 0x0004, 0x0001, 0x0003, 0x0003, 0x0002, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_6[16] = {
-  3,  3,  5,  7,  3,  2,  4,  5,
-  4,  4,  5,  6,  6,  5,  6,  7,
-};
-
-static const uint16_t mpa_huffcodes_7[36] = {
- 0x0001, 0x0002, 0x000a, 0x0013, 0x0010, 0x000a, 0x0003, 0x0003,
- 0x0007, 0x000a, 0x0005, 0x0003, 0x000b, 0x0004, 0x000d, 0x0011,
- 0x0008, 0x0004, 0x000c, 0x000b, 0x0012, 0x000f, 0x000b, 0x0002,
- 0x0007, 0x0006, 0x0009, 0x000e, 0x0003, 0x0001, 0x0006, 0x0004,
- 0x0005, 0x0003, 0x0002, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_7[36] = {
-  1,  3,  6,  8,  8,  9,  3,  4,
-  6,  7,  7,  8,  6,  5,  7,  8,
-  8,  9,  7,  7,  8,  9,  9,  9,
-  7,  7,  8,  9,  9, 10,  8,  8,
-  9, 10, 10, 10,
-};
-
-static const uint16_t mpa_huffcodes_8[36] = {
- 0x0003, 0x0004, 0x0006, 0x0012, 0x000c, 0x0005, 0x0005, 0x0001,
- 0x0002, 0x0010, 0x0009, 0x0003, 0x0007, 0x0003, 0x0005, 0x000e,
- 0x0007, 0x0003, 0x0013, 0x0011, 0x000f, 0x000d, 0x000a, 0x0004,
- 0x000d, 0x0005, 0x0008, 0x000b, 0x0005, 0x0001, 0x000c, 0x0004,
- 0x0004, 0x0001, 0x0001, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_8[36] = {
-  2,  3,  6,  8,  8,  9,  3,  2,
-  4,  8,  8,  8,  6,  4,  6,  8,
-  8,  9,  8,  8,  8,  9,  9, 10,
-  8,  7,  8,  9, 10, 10,  9,  8,
-  9,  9, 11, 11,
-};
-
-static const uint16_t mpa_huffcodes_9[36] = {
- 0x0007, 0x0005, 0x0009, 0x000e, 0x000f, 0x0007, 0x0006, 0x0004,
- 0x0005, 0x0005, 0x0006, 0x0007, 0x0007, 0x0006, 0x0008, 0x0008,
- 0x0008, 0x0005, 0x000f, 0x0006, 0x0009, 0x000a, 0x0005, 0x0001,
- 0x000b, 0x0007, 0x0009, 0x0006, 0x0004, 0x0001, 0x000e, 0x0004,
- 0x0006, 0x0002, 0x0006, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_9[36] = {
-  3,  3,  5,  6,  8,  9,  3,  3,
-  4,  5,  6,  8,  4,  4,  5,  6,
-  7,  8,  6,  5,  6,  7,  7,  8,
-  7,  6,  7,  7,  8,  9,  8,  7,
-  8,  8,  9,  9,
-};
-
-static const uint16_t mpa_huffcodes_10[64] = {
- 0x0001, 0x0002, 0x000a, 0x0017, 0x0023, 0x001e, 0x000c, 0x0011,
- 0x0003, 0x0003, 0x0008, 0x000c, 0x0012, 0x0015, 0x000c, 0x0007,
- 0x000b, 0x0009, 0x000f, 0x0015, 0x0020, 0x0028, 0x0013, 0x0006,
- 0x000e, 0x000d, 0x0016, 0x0022, 0x002e, 0x0017, 0x0012, 0x0007,
- 0x0014, 0x0013, 0x0021, 0x002f, 0x001b, 0x0016, 0x0009, 0x0003,
- 0x001f, 0x0016, 0x0029, 0x001a, 0x0015, 0x0014, 0x0005, 0x0003,
- 0x000e, 0x000d, 0x000a, 0x000b, 0x0010, 0x0006, 0x0005, 0x0001,
- 0x0009, 0x0008, 0x0007, 0x0008, 0x0004, 0x0004, 0x0002, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_10[64] = {
-  1,  3,  6,  8,  9,  9,  9, 10,
-  3,  4,  6,  7,  8,  9,  8,  8,
-  6,  6,  7,  8,  9, 10,  9,  9,
-  7,  7,  8,  9, 10, 10,  9, 10,
-  8,  8,  9, 10, 10, 10, 10, 10,
-  9,  9, 10, 10, 11, 11, 10, 11,
-  8,  8,  9, 10, 10, 10, 11, 11,
-  9,  8,  9, 10, 10, 11, 11, 11,
-};
-
-static const uint16_t mpa_huffcodes_11[64] = {
- 0x0003, 0x0004, 0x000a, 0x0018, 0x0022, 0x0021, 0x0015, 0x000f,
- 0x0005, 0x0003, 0x0004, 0x000a, 0x0020, 0x0011, 0x000b, 0x000a,
- 0x000b, 0x0007, 0x000d, 0x0012, 0x001e, 0x001f, 0x0014, 0x0005,
- 0x0019, 0x000b, 0x0013, 0x003b, 0x001b, 0x0012, 0x000c, 0x0005,
- 0x0023, 0x0021, 0x001f, 0x003a, 0x001e, 0x0010, 0x0007, 0x0005,
- 0x001c, 0x001a, 0x0020, 0x0013, 0x0011, 0x000f, 0x0008, 0x000e,
- 0x000e, 0x000c, 0x0009, 0x000d, 0x000e, 0x0009, 0x0004, 0x0001,
- 0x000b, 0x0004, 0x0006, 0x0006, 0x0006, 0x0003, 0x0002, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_11[64] = {
-  2,  3,  5,  7,  8,  9,  8,  9,
-  3,  3,  4,  6,  8,  8,  7,  8,
-  5,  5,  6,  7,  8,  9,  8,  8,
-  7,  6,  7,  9,  8, 10,  8,  9,
-  8,  8,  8,  9,  9, 10,  9, 10,
-  8,  8,  9, 10, 10, 11, 10, 11,
-  8,  7,  7,  8,  9, 10, 10, 10,
-  8,  7,  8,  9, 10, 10, 10, 10,
-};
-
-static const uint16_t mpa_huffcodes_12[64] = {
- 0x0009, 0x0006, 0x0010, 0x0021, 0x0029, 0x0027, 0x0026, 0x001a,
- 0x0007, 0x0005, 0x0006, 0x0009, 0x0017, 0x0010, 0x001a, 0x000b,
- 0x0011, 0x0007, 0x000b, 0x000e, 0x0015, 0x001e, 0x000a, 0x0007,
- 0x0011, 0x000a, 0x000f, 0x000c, 0x0012, 0x001c, 0x000e, 0x0005,
- 0x0020, 0x000d, 0x0016, 0x0013, 0x0012, 0x0010, 0x0009, 0x0005,
- 0x0028, 0x0011, 0x001f, 0x001d, 0x0011, 0x000d, 0x0004, 0x0002,
- 0x001b, 0x000c, 0x000b, 0x000f, 0x000a, 0x0007, 0x0004, 0x0001,
- 0x001b, 0x000c, 0x0008, 0x000c, 0x0006, 0x0003, 0x0001, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_12[64] = {
-  4,  3,  5,  7,  8,  9,  9,  9,
-  3,  3,  4,  5,  7,  7,  8,  8,
-  5,  4,  5,  6,  7,  8,  7,  8,
-  6,  5,  6,  6,  7,  8,  8,  8,
-  7,  6,  7,  7,  8,  8,  8,  9,
-  8,  7,  8,  8,  8,  9,  8,  9,
-  8,  7,  7,  8,  8,  9,  9, 10,
-  9,  8,  8,  9,  9,  9,  9, 10,
-};
-
-static const uint16_t mpa_huffcodes_13[256] = {
- 0x0001, 0x0005, 0x000e, 0x0015, 0x0022, 0x0033, 0x002e, 0x0047,
- 0x002a, 0x0034, 0x0044, 0x0034, 0x0043, 0x002c, 0x002b, 0x0013,
- 0x0003, 0x0004, 0x000c, 0x0013, 0x001f, 0x001a, 0x002c, 0x0021,
- 0x001f, 0x0018, 0x0020, 0x0018, 0x001f, 0x0023, 0x0016, 0x000e,
- 0x000f, 0x000d, 0x0017, 0x0024, 0x003b, 0x0031, 0x004d, 0x0041,
- 0x001d, 0x0028, 0x001e, 0x0028, 0x001b, 0x0021, 0x002a, 0x0010,
- 0x0016, 0x0014, 0x0025, 0x003d, 0x0038, 0x004f, 0x0049, 0x0040,
- 0x002b, 0x004c, 0x0038, 0x0025, 0x001a, 0x001f, 0x0019, 0x000e,
- 0x0023, 0x0010, 0x003c, 0x0039, 0x0061, 0x004b, 0x0072, 0x005b,
- 0x0036, 0x0049, 0x0037, 0x0029, 0x0030, 0x0035, 0x0017, 0x0018,
- 0x003a, 0x001b, 0x0032, 0x0060, 0x004c, 0x0046, 0x005d, 0x0054,
- 0x004d, 0x003a, 0x004f, 0x001d, 0x004a, 0x0031, 0x0029, 0x0011,
- 0x002f, 0x002d, 0x004e, 0x004a, 0x0073, 0x005e, 0x005a, 0x004f,
- 0x0045, 0x0053, 0x0047, 0x0032, 0x003b, 0x0026, 0x0024, 0x000f,
- 0x0048, 0x0022, 0x0038, 0x005f, 0x005c, 0x0055, 0x005b, 0x005a,
- 0x0056, 0x0049, 0x004d, 0x0041, 0x0033, 0x002c, 0x002b, 0x002a,
- 0x002b, 0x0014, 0x001e, 0x002c, 0x0037, 0x004e, 0x0048, 0x0057,
- 0x004e, 0x003d, 0x002e, 0x0036, 0x0025, 0x001e, 0x0014, 0x0010,
- 0x0035, 0x0019, 0x0029, 0x0025, 0x002c, 0x003b, 0x0036, 0x0051,
- 0x0042, 0x004c, 0x0039, 0x0036, 0x0025, 0x0012, 0x0027, 0x000b,
- 0x0023, 0x0021, 0x001f, 0x0039, 0x002a, 0x0052, 0x0048, 0x0050,
- 0x002f, 0x003a, 0x0037, 0x0015, 0x0016, 0x001a, 0x0026, 0x0016,
- 0x0035, 0x0019, 0x0017, 0x0026, 0x0046, 0x003c, 0x0033, 0x0024,
- 0x0037, 0x001a, 0x0022, 0x0017, 0x001b, 0x000e, 0x0009, 0x0007,
- 0x0022, 0x0020, 0x001c, 0x0027, 0x0031, 0x004b, 0x001e, 0x0034,
- 0x0030, 0x0028, 0x0034, 0x001c, 0x0012, 0x0011, 0x0009, 0x0005,
- 0x002d, 0x0015, 0x0022, 0x0040, 0x0038, 0x0032, 0x0031, 0x002d,
- 0x001f, 0x0013, 0x000c, 0x000f, 0x000a, 0x0007, 0x0006, 0x0003,
- 0x0030, 0x0017, 0x0014, 0x0027, 0x0024, 0x0023, 0x0035, 0x0015,
- 0x0010, 0x0017, 0x000d, 0x000a, 0x0006, 0x0001, 0x0004, 0x0002,
- 0x0010, 0x000f, 0x0011, 0x001b, 0x0019, 0x0014, 0x001d, 0x000b,
- 0x0011, 0x000c, 0x0010, 0x0008, 0x0001, 0x0001, 0x0000, 0x0001,
-};
-
-static const uint8_t mpa_huffbits_13[256] = {
-  1,  4,  6,  7,  8,  9,  9, 10,
-  9, 10, 11, 11, 12, 12, 13, 13,
-  3,  4,  6,  7,  8,  8,  9,  9,
-  9,  9, 10, 10, 11, 12, 12, 12,
-  6,  6,  7,  8,  9,  9, 10, 10,
-  9, 10, 10, 11, 11, 12, 13, 13,
-  7,  7,  8,  9,  9, 10, 10, 10,
- 10, 11, 11, 11, 11, 12, 13, 13,
-  8,  7,  9,  9, 10, 10, 11, 11,
- 10, 11, 11, 12, 12, 13, 13, 14,
-  9,  8,  9, 10, 10, 10, 11, 11,
- 11, 11, 12, 11, 13, 13, 14, 14,
-  9,  9, 10, 10, 11, 11, 11, 11,
- 11, 12, 12, 12, 13, 13, 14, 14,
- 10,  9, 10, 11, 11, 11, 12, 12,
- 12, 12, 13, 13, 13, 14, 16, 16,
-  9,  8,  9, 10, 10, 11, 11, 12,
- 12, 12, 12, 13, 13, 14, 15, 15,
- 10,  9, 10, 10, 11, 11, 11, 13,
- 12, 13, 13, 14, 14, 14, 16, 15,
- 10, 10, 10, 11, 11, 12, 12, 13,
- 12, 13, 14, 13, 14, 15, 16, 17,
- 11, 10, 10, 11, 12, 12, 12, 12,
- 13, 13, 13, 14, 15, 15, 15, 16,
- 11, 11, 11, 12, 12, 13, 12, 13,
- 14, 14, 15, 15, 15, 16, 16, 16,
- 12, 11, 12, 13, 13, 13, 14, 14,
- 14, 14, 14, 15, 16, 15, 16, 16,
- 13, 12, 12, 13, 13, 13, 15, 14,
- 14, 17, 15, 15, 15, 17, 16, 16,
- 12, 12, 13, 14, 14, 14, 15, 14,
- 15, 15, 16, 16, 19, 18, 19, 16,
-};
-
-static const uint16_t mpa_huffcodes_15[256] = {
- 0x0007, 0x000c, 0x0012, 0x0035, 0x002f, 0x004c, 0x007c, 0x006c,
- 0x0059, 0x007b, 0x006c, 0x0077, 0x006b, 0x0051, 0x007a, 0x003f,
- 0x000d, 0x0005, 0x0010, 0x001b, 0x002e, 0x0024, 0x003d, 0x0033,
- 0x002a, 0x0046, 0x0034, 0x0053, 0x0041, 0x0029, 0x003b, 0x0024,
- 0x0013, 0x0011, 0x000f, 0x0018, 0x0029, 0x0022, 0x003b, 0x0030,
- 0x0028, 0x0040, 0x0032, 0x004e, 0x003e, 0x0050, 0x0038, 0x0021,
- 0x001d, 0x001c, 0x0019, 0x002b, 0x0027, 0x003f, 0x0037, 0x005d,
- 0x004c, 0x003b, 0x005d, 0x0048, 0x0036, 0x004b, 0x0032, 0x001d,
- 0x0034, 0x0016, 0x002a, 0x0028, 0x0043, 0x0039, 0x005f, 0x004f,
- 0x0048, 0x0039, 0x0059, 0x0045, 0x0031, 0x0042, 0x002e, 0x001b,
- 0x004d, 0x0025, 0x0023, 0x0042, 0x003a, 0x0034, 0x005b, 0x004a,
- 0x003e, 0x0030, 0x004f, 0x003f, 0x005a, 0x003e, 0x0028, 0x0026,
- 0x007d, 0x0020, 0x003c, 0x0038, 0x0032, 0x005c, 0x004e, 0x0041,
- 0x0037, 0x0057, 0x0047, 0x0033, 0x0049, 0x0033, 0x0046, 0x001e,
- 0x006d, 0x0035, 0x0031, 0x005e, 0x0058, 0x004b, 0x0042, 0x007a,
- 0x005b, 0x0049, 0x0038, 0x002a, 0x0040, 0x002c, 0x0015, 0x0019,
- 0x005a, 0x002b, 0x0029, 0x004d, 0x0049, 0x003f, 0x0038, 0x005c,
- 0x004d, 0x0042, 0x002f, 0x0043, 0x0030, 0x0035, 0x0024, 0x0014,
- 0x0047, 0x0022, 0x0043, 0x003c, 0x003a, 0x0031, 0x0058, 0x004c,
- 0x0043, 0x006a, 0x0047, 0x0036, 0x0026, 0x0027, 0x0017, 0x000f,
- 0x006d, 0x0035, 0x0033, 0x002f, 0x005a, 0x0052, 0x003a, 0x0039,
- 0x0030, 0x0048, 0x0039, 0x0029, 0x0017, 0x001b, 0x003e, 0x0009,
- 0x0056, 0x002a, 0x0028, 0x0025, 0x0046, 0x0040, 0x0034, 0x002b,
- 0x0046, 0x0037, 0x002a, 0x0019, 0x001d, 0x0012, 0x000b, 0x000b,
- 0x0076, 0x0044, 0x001e, 0x0037, 0x0032, 0x002e, 0x004a, 0x0041,
- 0x0031, 0x0027, 0x0018, 0x0010, 0x0016, 0x000d, 0x000e, 0x0007,
- 0x005b, 0x002c, 0x0027, 0x0026, 0x0022, 0x003f, 0x0034, 0x002d,
- 0x001f, 0x0034, 0x001c, 0x0013, 0x000e, 0x0008, 0x0009, 0x0003,
- 0x007b, 0x003c, 0x003a, 0x0035, 0x002f, 0x002b, 0x0020, 0x0016,
- 0x0025, 0x0018, 0x0011, 0x000c, 0x000f, 0x000a, 0x0002, 0x0001,
- 0x0047, 0x0025, 0x0022, 0x001e, 0x001c, 0x0014, 0x0011, 0x001a,
- 0x0015, 0x0010, 0x000a, 0x0006, 0x0008, 0x0006, 0x0002, 0x0000,
-};
-
-static const uint8_t mpa_huffbits_15[256] = {
-  3,  4,  5,  7,  7,  8,  9,  9,
-  9, 10, 10, 11, 11, 11, 12, 13,
-  4,  3,  5,  6,  7,  7,  8,  8,
-  8,  9,  9, 10, 10, 10, 11, 11,
-  5,  5,  5,  6,  7,  7,  8,  8,
-  8,  9,  9, 10, 10, 11, 11, 11,
-  6,  6,  6,  7,  7,  8,  8,  9,
-  9,  9, 10, 10, 10, 11, 11, 11,
-  7,  6,  7,  7,  8,  8,  9,  9,
-  9,  9, 10, 10, 10, 11, 11, 11,
-  8,  7,  7,  8,  8,  8,  9,  9,
-  9,  9, 10, 10, 11, 11, 11, 12,
-  9,  7,  8,  8,  8,  9,  9,  9,
-  9, 10, 10, 10, 11, 11, 12, 12,
-  9,  8,  8,  9,  9,  9,  9, 10,
- 10, 10, 10, 10, 11, 11, 11, 12,
-  9,  8,  8,  9,  9,  9,  9, 10,
- 10, 10, 10, 11, 11, 12, 12, 12,
-  9,  8,  9,  9,  9,  9, 10, 10,
- 10, 11, 11, 11, 11, 12, 12, 12,
- 10,  9,  9,  9, 10, 10, 10, 10,
- 10, 11, 11, 11, 11, 12, 13, 12,
- 10,  9,  9,  9, 10, 10, 10, 10,
- 11, 11, 11, 11, 12, 12, 12, 13,
- 11, 10,  9, 10, 10, 10, 11, 11,
- 11, 11, 11, 11, 12, 12, 13, 13,
- 11, 10, 10, 10, 10, 11, 11, 11,
- 11, 12, 12, 12, 12, 12, 13, 13,
- 12, 11, 11, 11, 11, 11, 11, 11,
- 12, 12, 12, 12, 13, 13, 12, 13,
- 12, 11, 11, 11, 11, 11, 11, 12,
- 12, 12, 12, 12, 13, 13, 13, 13,
-};
-
-static const uint16_t mpa_huffcodes_16[256] = {
- 0x0001, 0x0005, 0x000e, 0x002c, 0x004a, 0x003f, 0x006e, 0x005d,
- 0x00ac, 0x0095, 0x008a, 0x00f2, 0x00e1, 0x00c3, 0x0178, 0x0011,
- 0x0003, 0x0004, 0x000c, 0x0014, 0x0023, 0x003e, 0x0035, 0x002f,
- 0x0053, 0x004b, 0x0044, 0x0077, 0x00c9, 0x006b, 0x00cf, 0x0009,
- 0x000f, 0x000d, 0x0017, 0x0026, 0x0043, 0x003a, 0x0067, 0x005a,
- 0x00a1, 0x0048, 0x007f, 0x0075, 0x006e, 0x00d1, 0x00ce, 0x0010,
- 0x002d, 0x0015, 0x0027, 0x0045, 0x0040, 0x0072, 0x0063, 0x0057,
- 0x009e, 0x008c, 0x00fc, 0x00d4, 0x00c7, 0x0183, 0x016d, 0x001a,
- 0x004b, 0x0024, 0x0044, 0x0041, 0x0073, 0x0065, 0x00b3, 0x00a4,
- 0x009b, 0x0108, 0x00f6, 0x00e2, 0x018b, 0x017e, 0x016a, 0x0009,
- 0x0042, 0x001e, 0x003b, 0x0038, 0x0066, 0x00b9, 0x00ad, 0x0109,
- 0x008e, 0x00fd, 0x00e8, 0x0190, 0x0184, 0x017a, 0x01bd, 0x0010,
- 0x006f, 0x0036, 0x0034, 0x0064, 0x00b8, 0x00b2, 0x00a0, 0x0085,
- 0x0101, 0x00f4, 0x00e4, 0x00d9, 0x0181, 0x016e, 0x02cb, 0x000a,
- 0x0062, 0x0030, 0x005b, 0x0058, 0x00a5, 0x009d, 0x0094, 0x0105,
- 0x00f8, 0x0197, 0x018d, 0x0174, 0x017c, 0x0379, 0x0374, 0x0008,
- 0x0055, 0x0054, 0x0051, 0x009f, 0x009c, 0x008f, 0x0104, 0x00f9,
- 0x01ab, 0x0191, 0x0188, 0x017f, 0x02d7, 0x02c9, 0x02c4, 0x0007,
- 0x009a, 0x004c, 0x0049, 0x008d, 0x0083, 0x0100, 0x00f5, 0x01aa,
- 0x0196, 0x018a, 0x0180, 0x02df, 0x0167, 0x02c6, 0x0160, 0x000b,
- 0x008b, 0x0081, 0x0043, 0x007d, 0x00f7, 0x00e9, 0x00e5, 0x00db,
- 0x0189, 0x02e7, 0x02e1, 0x02d0, 0x0375, 0x0372, 0x01b7, 0x0004,
- 0x00f3, 0x0078, 0x0076, 0x0073, 0x00e3, 0x00df, 0x018c, 0x02ea,
- 0x02e6, 0x02e0, 0x02d1, 0x02c8, 0x02c2, 0x00df, 0x01b4, 0x0006,
- 0x00ca, 0x00e0, 0x00de, 0x00da, 0x00d8, 0x0185, 0x0182, 0x017d,
- 0x016c, 0x0378, 0x01bb, 0x02c3, 0x01b8, 0x01b5, 0x06c0, 0x0004,
- 0x02eb, 0x00d3, 0x00d2, 0x00d0, 0x0172, 0x017b, 0x02de, 0x02d3,
- 0x02ca, 0x06c7, 0x0373, 0x036d, 0x036c, 0x0d83, 0x0361, 0x0002,
- 0x0179, 0x0171, 0x0066, 0x00bb, 0x02d6, 0x02d2, 0x0166, 0x02c7,
- 0x02c5, 0x0362, 0x06c6, 0x0367, 0x0d82, 0x0366, 0x01b2, 0x0000,
- 0x000c, 0x000a, 0x0007, 0x000b, 0x000a, 0x0011, 0x000b, 0x0009,
- 0x000d, 0x000c, 0x000a, 0x0007, 0x0005, 0x0003, 0x0001, 0x0003,
-};
-
-static const uint8_t mpa_huffbits_16[256] = {
-  1,  4,  6,  8,  9,  9, 10, 10,
- 11, 11, 11, 12, 12, 12, 13,  9,
-  3,  4,  6,  7,  8,  9,  9,  9,
- 10, 10, 10, 11, 12, 11, 12,  8,
-  6,  6,  7,  8,  9,  9, 10, 10,
- 11, 10, 11, 11, 11, 12, 12,  9,
-  8,  7,  8,  9,  9, 10, 10, 10,
- 11, 11, 12, 12, 12, 13, 13, 10,
-  9,  8,  9,  9, 10, 10, 11, 11,
- 11, 12, 12, 12, 13, 13, 13,  9,
-  9,  8,  9,  9, 10, 11, 11, 12,
- 11, 12, 12, 13, 13, 13, 14, 10,
- 10,  9,  9, 10, 11, 11, 11, 11,
- 12, 12, 12, 12, 13, 13, 14, 10,
- 10,  9, 10, 10, 11, 11, 11, 12,
- 12, 13, 13, 13, 13, 15, 15, 10,
- 10, 10, 10, 11, 11, 11, 12, 12,
- 13, 13, 13, 13, 14, 14, 14, 10,
- 11, 10, 10, 11, 11, 12, 12, 13,
- 13, 13, 13, 14, 13, 14, 13, 11,
- 11, 11, 10, 11, 12, 12, 12, 12,
- 13, 14, 14, 14, 15, 15, 14, 10,
- 12, 11, 11, 11, 12, 12, 13, 14,
- 14, 14, 14, 14, 14, 13, 14, 11,
- 12, 12, 12, 12, 12, 13, 13, 13,
- 13, 15, 14, 14, 14, 14, 16, 11,
- 14, 12, 12, 12, 13, 13, 14, 14,
- 14, 16, 15, 15, 15, 17, 15, 11,
- 13, 13, 11, 12, 14, 14, 13, 14,
- 14, 15, 16, 15, 17, 15, 14, 11,
-  9,  8,  8,  9,  9, 10, 10, 10,
- 11, 11, 11, 11, 11, 11, 11,  8,
-};
-
-static const uint16_t mpa_huffcodes_24[256] = {
- 0x000f, 0x000d, 0x002e, 0x0050, 0x0092, 0x0106, 0x00f8, 0x01b2,
- 0x01aa, 0x029d, 0x028d, 0x0289, 0x026d, 0x0205, 0x0408, 0x0058,
- 0x000e, 0x000c, 0x0015, 0x0026, 0x0047, 0x0082, 0x007a, 0x00d8,
- 0x00d1, 0x00c6, 0x0147, 0x0159, 0x013f, 0x0129, 0x0117, 0x002a,
- 0x002f, 0x0016, 0x0029, 0x004a, 0x0044, 0x0080, 0x0078, 0x00dd,
- 0x00cf, 0x00c2, 0x00b6, 0x0154, 0x013b, 0x0127, 0x021d, 0x0012,
- 0x0051, 0x0027, 0x004b, 0x0046, 0x0086, 0x007d, 0x0074, 0x00dc,
- 0x00cc, 0x00be, 0x00b2, 0x0145, 0x0137, 0x0125, 0x010f, 0x0010,
- 0x0093, 0x0048, 0x0045, 0x0087, 0x007f, 0x0076, 0x0070, 0x00d2,
- 0x00c8, 0x00bc, 0x0160, 0x0143, 0x0132, 0x011d, 0x021c, 0x000e,
- 0x0107, 0x0042, 0x0081, 0x007e, 0x0077, 0x0072, 0x00d6, 0x00ca,
- 0x00c0, 0x00b4, 0x0155, 0x013d, 0x012d, 0x0119, 0x0106, 0x000c,
- 0x00f9, 0x007b, 0x0079, 0x0075, 0x0071, 0x00d7, 0x00ce, 0x00c3,
- 0x00b9, 0x015b, 0x014a, 0x0134, 0x0123, 0x0110, 0x0208, 0x000a,
- 0x01b3, 0x0073, 0x006f, 0x006d, 0x00d3, 0x00cb, 0x00c4, 0x00bb,
- 0x0161, 0x014c, 0x0139, 0x012a, 0x011b, 0x0213, 0x017d, 0x0011,
- 0x01ab, 0x00d4, 0x00d0, 0x00cd, 0x00c9, 0x00c1, 0x00ba, 0x00b1,
- 0x00a9, 0x0140, 0x012f, 0x011e, 0x010c, 0x0202, 0x0179, 0x0010,
- 0x014f, 0x00c7, 0x00c5, 0x00bf, 0x00bd, 0x00b5, 0x00ae, 0x014d,
- 0x0141, 0x0131, 0x0121, 0x0113, 0x0209, 0x017b, 0x0173, 0x000b,
- 0x029c, 0x00b8, 0x00b7, 0x00b3, 0x00af, 0x0158, 0x014b, 0x013a,
- 0x0130, 0x0122, 0x0115, 0x0212, 0x017f, 0x0175, 0x016e, 0x000a,
- 0x028c, 0x015a, 0x00ab, 0x00a8, 0x00a4, 0x013e, 0x0135, 0x012b,
- 0x011f, 0x0114, 0x0107, 0x0201, 0x0177, 0x0170, 0x016a, 0x0006,
- 0x0288, 0x0142, 0x013c, 0x0138, 0x0133, 0x012e, 0x0124, 0x011c,
- 0x010d, 0x0105, 0x0200, 0x0178, 0x0172, 0x016c, 0x0167, 0x0004,
- 0x026c, 0x012c, 0x0128, 0x0126, 0x0120, 0x011a, 0x0111, 0x010a,
- 0x0203, 0x017c, 0x0176, 0x0171, 0x016d, 0x0169, 0x0165, 0x0002,
- 0x0409, 0x0118, 0x0116, 0x0112, 0x010b, 0x0108, 0x0103, 0x017e,
- 0x017a, 0x0174, 0x016f, 0x016b, 0x0168, 0x0166, 0x0164, 0x0000,
- 0x002b, 0x0014, 0x0013, 0x0011, 0x000f, 0x000d, 0x000b, 0x0009,
- 0x0007, 0x0006, 0x0004, 0x0007, 0x0005, 0x0003, 0x0001, 0x0003,
-};
-
-static const uint8_t mpa_huffbits_24[256] = {
-  4,  4,  6,  7,  8,  9,  9, 10,
- 10, 11, 11, 11, 11, 11, 12,  9,
-  4,  4,  5,  6,  7,  8,  8,  9,
-  9,  9, 10, 10, 10, 10, 10,  8,
-  6,  5,  6,  7,  7,  8,  8,  9,
-  9,  9,  9, 10, 10, 10, 11,  7,
-  7,  6,  7,  7,  8,  8,  8,  9,
-  9,  9,  9, 10, 10, 10, 10,  7,
-  8,  7,  7,  8,  8,  8,  8,  9,
-  9,  9, 10, 10, 10, 10, 11,  7,
-  9,  7,  8,  8,  8,  8,  9,  9,
-  9,  9, 10, 10, 10, 10, 10,  7,
-  9,  8,  8,  8,  8,  9,  9,  9,
-  9, 10, 10, 10, 10, 10, 11,  7,
- 10,  8,  8,  8,  9,  9,  9,  9,
- 10, 10, 10, 10, 10, 11, 11,  8,
- 10,  9,  9,  9,  9,  9,  9,  9,
-  9, 10, 10, 10, 10, 11, 11,  8,
- 10,  9,  9,  9,  9,  9,  9, 10,
- 10, 10, 10, 10, 11, 11, 11,  8,
- 11,  9,  9,  9,  9, 10, 10, 10,
- 10, 10, 10, 11, 11, 11, 11,  8,
- 11, 10,  9,  9,  9, 10, 10, 10,
- 10, 10, 10, 11, 11, 11, 11,  8,
- 11, 10, 10, 10, 10, 10, 10, 10,
- 10, 10, 11, 11, 11, 11, 11,  8,
- 11, 10, 10, 10, 10, 10, 10, 10,
- 11, 11, 11, 11, 11, 11, 11,  8,
- 12, 10, 10, 10, 10, 10, 10, 11,
- 11, 11, 11, 11, 11, 11, 11,  8,
-  8,  7,  7,  7,  7,  7,  7,  7,
-  7,  7,  7,  8,  8,  8,  8,  4,
-};
-
-static const HuffTable mpa_huff_tables[16] = {
-{ 1, NULL, NULL },
-{ 2, mpa_huffbits_1, mpa_huffcodes_1 },
-{ 3, mpa_huffbits_2, mpa_huffcodes_2 },
-{ 3, mpa_huffbits_3, mpa_huffcodes_3 },
-{ 4, mpa_huffbits_5, mpa_huffcodes_5 },
-{ 4, mpa_huffbits_6, mpa_huffcodes_6 },
-{ 6, mpa_huffbits_7, mpa_huffcodes_7 },
-{ 6, mpa_huffbits_8, mpa_huffcodes_8 },
-{ 6, mpa_huffbits_9, mpa_huffcodes_9 },
-{ 8, mpa_huffbits_10, mpa_huffcodes_10 },
-{ 8, mpa_huffbits_11, mpa_huffcodes_11 },
-{ 8, mpa_huffbits_12, mpa_huffcodes_12 },
-{ 16, mpa_huffbits_13, mpa_huffcodes_13 },
-{ 16, mpa_huffbits_15, mpa_huffcodes_15 },
-{ 16, mpa_huffbits_16, mpa_huffcodes_16 },
-{ 16, mpa_huffbits_24, mpa_huffcodes_24 },
-};
-
-static const uint8_t mpa_huff_data[32][2] = {
-{ 0, 0 },
-{ 1, 0 },
-{ 2, 0 },
-{ 3, 0 },
-{ 0, 0 },
-{ 4, 0 },
-{ 5, 0 },
-{ 6, 0 },
-{ 7, 0 },
-{ 8, 0 },
-{ 9, 0 },
-{ 10, 0 },
-{ 11, 0 },
-{ 12, 0 },
-{ 0, 0 },
-{ 13, 0 },
-{ 14, 1 },
-{ 14, 2 },
-{ 14, 3 },
-{ 14, 4 },
-{ 14, 6 },
-{ 14, 8 },
-{ 14, 10 },
-{ 14, 13 },
-{ 15, 4 },
-{ 15, 5 },
-{ 15, 6 },
-{ 15, 7 },
-{ 15, 8 },
-{ 15, 9 },
-{ 15, 11 },
-{ 15, 13 },
-};
-
-
-/* huffman tables for quadrules */
-static const uint8_t mpa_quad_codes[2][16] = {
-    {  1,  5,  4,  5,  6,  5,  4,  4, 7,  3,  6,  0,  7,  2,  3,  1, },
-    { 15, 14, 13, 12, 11, 10,  9,  8, 7,  6,  5,  4,  3,  2,  1,  0, },
-};
-
-static const uint8_t mpa_quad_bits[2][16] = {
-    { 1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6, },
-    { 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, },
-};
-
-/* band size tables */
-static const uint8_t band_size_long[9][22] = {
-{ 4, 4, 4, 4, 4, 4, 6, 6, 8, 8, 10,
-  12, 16, 20, 24, 28, 34, 42, 50, 54, 76, 158, }, /* 44100 */
-{ 4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 10,
-  12, 16, 18, 22, 28, 34, 40, 46, 54, 54, 192, }, /* 48000 */
-{ 4, 4, 4, 4, 4, 4, 6, 6, 8, 10, 12,
-  16, 20, 24, 30, 38, 46, 56, 68, 84, 102, 26, }, /* 32000 */
-{ 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 22050 */
-{ 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  18, 22, 26, 32, 38, 46, 52, 64, 70, 76, 36, }, /* 24000 */
-{ 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 16000 */
-{ 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 11025 */
-{ 6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16,
-  20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54, }, /* 12000 */
-{ 12, 12, 12, 12, 12, 12, 16, 20, 24, 28, 32,
-  40, 48, 56, 64, 76, 90, 2, 2, 2, 2, 2, }, /* 8000 */
-};
-
-static const uint8_t band_size_short[9][13] = {
-{ 4, 4, 4, 4, 6, 8, 10, 12, 14, 18, 22, 30, 56, }, /* 44100 */
-{ 4, 4, 4, 4, 6, 6, 10, 12, 14, 16, 20, 26, 66, }, /* 48000 */
-{ 4, 4, 4, 4, 6, 8, 12, 16, 20, 26, 34, 42, 12, }, /* 32000 */
-{ 4, 4, 4, 6, 6, 8, 10, 14, 18, 26, 32, 42, 18, }, /* 22050 */
-{ 4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 32, 44, 12, }, /* 24000 */
-{ 4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18, }, /* 16000 */
-{ 4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18, }, /* 11025 */
-{ 4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18, }, /* 12000 */
-{ 8, 8, 8, 12, 16, 20, 24, 28, 36, 2, 2, 2, 26, }, /* 8000 */
-};
-
-static const uint8_t mpa_pretab[2][22] = {
-    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
-    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0 },
-};
-
-/* table for alias reduction (XXX: store it as integer !) */
-static const float ci_table[8] = {
-    -0.6, -0.535, -0.33, -0.185, -0.095, -0.041, -0.0142, -0.0037,
-};
-
-#endif /* AVCODEC_MPEGAUDIODECTAB_H */
diff --git a/media/ffvpx/libavcodec/mpegaudiodsp.h b/media/ffvpx/libavcodec/mpegaudiodsp.h
index 7bc635191abce..5e47a263bb04b 100644
--- a/media/ffvpx/libavcodec/mpegaudiodsp.h
+++ b/media/ffvpx/libavcodec/mpegaudiodsp.h
@@ -22,6 +22,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
 #include "libavutil/macros.h"
 
 typedef struct MPADSPContext {
@@ -40,6 +41,7 @@ typedef struct MPADSPContext {
                                  int count, int switch_point, int block_type);
 } MPADSPContext;
 
+FF_VISIBILITY_PUSH_HIDDEN
 void ff_mpadsp_init(MPADSPContext *s);
 
 extern int32_t ff_mpa_synth_window_fixed[];
@@ -88,5 +90,6 @@ void ff_imdct36_blocks_fixed(int *out, int *buf, int *in,
 
 extern int ff_mdct_win_fixed[8][MDCT_BUF_SIZE];
 extern float ff_mdct_win_float[8][MDCT_BUF_SIZE];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_MPEGAUDIODSP_H */
diff --git a/media/ffvpx/libavcodec/mpegvideodsp.h b/media/ffvpx/libavcodec/mpegvideodsp.h
deleted file mode 100644
index 293e2548d34c7..0000000000000
--- a/media/ffvpx/libavcodec/mpegvideodsp.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_MPEGVIDEODSP_H
-#define AVCODEC_MPEGVIDEODSP_H
-
-#include <stdint.h>
-
-void ff_gmc_c(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy,
-              int dxx, int dxy, int dyx, int dyy, int shift, int r,
-              int width, int height);
-
-typedef struct MpegVideoDSPContext {
-    /**
-     * translational global motion compensation.
-     */
-    void (*gmc1)(uint8_t *dst /* align 8 */, uint8_t *src /* align 1 */,
-                 int srcStride, int h, int x16, int y16, int rounder);
-    /**
-     * global motion compensation.
-     */
-    void (*gmc)(uint8_t *dst /* align 8 */, uint8_t *src /* align 1 */,
-                int stride, int h, int ox, int oy,
-                int dxx, int dxy, int dyx, int dyy,
-                int shift, int r, int width, int height);
-} MpegVideoDSPContext;
-
-void ff_mpegvideodsp_init(MpegVideoDSPContext *c);
-void ff_mpegvideodsp_init_ppc(MpegVideoDSPContext *c);
-void ff_mpegvideodsp_init_x86(MpegVideoDSPContext *c);
-
-#endif /* AVCODEC_MPEGVIDEODSP_H */
diff --git a/media/ffvpx/libavcodec/options.c b/media/ffvpx/libavcodec/options.c
index a9b35ee1c3450..0c3b40a186865 100644
--- a/media/ffvpx/libavcodec/options.c
+++ b/media/ffvpx/libavcodec/options.c
@@ -27,6 +27,7 @@
 #include "config_components.h"
 
 #include "avcodec.h"
+#include "avcodec_internal.h"
 #include "codec_internal.h"
 #include "libavutil/avassert.h"
 #include "libavutil/internal.h"
@@ -124,11 +125,6 @@ static int init_context_defaults(AVCodecContext *s, const AVCodec *codec)
     s->sw_pix_fmt          = AV_PIX_FMT_NONE;
     s->sample_fmt          = AV_SAMPLE_FMT_NONE;
 
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    s->reordered_opaque    = AV_NOPTS_VALUE;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     if(codec && codec2->priv_data_size){
         s->priv_data = av_mallocz(codec2->priv_data_size);
         if (!s->priv_data)
@@ -172,14 +168,17 @@ void avcodec_free_context(AVCodecContext **pavctx)
     if (!avctx)
         return;
 
-    avcodec_close(avctx);
+    ff_codec_close(avctx);
 
     av_freep(&avctx->extradata);
     av_freep(&avctx->subtitle_header);
     av_freep(&avctx->intra_matrix);
+    av_freep(&avctx->chroma_intra_matrix);
     av_freep(&avctx->inter_matrix);
     av_freep(&avctx->rc_override);
     av_channel_layout_uninit(&avctx->ch_layout);
+    av_frame_side_data_free(
+        &avctx->decoded_side_data, &avctx->nb_decoded_side_data);
 
     av_freep(pavctx);
 }
@@ -197,7 +196,7 @@ static const AVOption subtitle_rect_options[]={
 {"w", "", SROFFSET(w), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
 {"h", "", SROFFSET(h), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
 {"type", "", SROFFSET(type), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, 0},
-{"flags", "", SROFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, 1, 0, "flags"},
+{"flags", "", SROFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, 1, 0, .unit = "flags"},
 {"forced", "", SROFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, 0, 1, 0},
 {NULL},
 };
diff --git a/media/ffvpx/libavcodec/options_table.h b/media/ffvpx/libavcodec/options_table.h
index ee243d9894c3f..7a70fa7b6c029 100644
--- a/media/ffvpx/libavcodec/options_table.h
+++ b/media/ffvpx/libavcodec/options_table.h
@@ -42,6 +42,8 @@
 #define D AV_OPT_FLAG_DECODING_PARAM
 #define CC AV_OPT_FLAG_CHILD_CONSTS
 
+#define AR AV_OPT_TYPE_FLAG_ARRAY
+
 #define AV_CODEC_DEFAULT_BITRATE 200*1000
 
 static const AVOption avcodec_options[] = {
@@ -51,52 +53,49 @@ static const AVOption avcodec_options[] = {
        "ratecontrol is willing to deviate from the target average bitrate value. This is not related "
        "to minimum/maximum bitrate. Lowering tolerance too much has an adverse effect on quality.",
        OFFSET(bit_rate_tolerance), AV_OPT_TYPE_INT, {.i64 = AV_CODEC_DEFAULT_BITRATE*20 }, 0, INT_MAX, A|V|E},
-{"flags", NULL, OFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT }, 0, UINT_MAX, V|A|S|E|D, "flags"},
-{"unaligned", "allow decoders to produce unaligned output", 0, AV_OPT_TYPE_CONST, { .i64 = AV_CODEC_FLAG_UNALIGNED }, INT_MIN, INT_MAX, V | D, "flags" },
-{"mv4", "use four motion vectors per macroblock (MPEG-4)", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_4MV }, INT_MIN, INT_MAX, V|E, "flags"},
-{"qpel", "use 1/4-pel motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QPEL }, INT_MIN, INT_MAX, V|E, "flags"},
-{"loop", "use loop filter", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOOP_FILTER }, INT_MIN, INT_MAX, V|E, "flags"},
-{"qscale", "use fixed qscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QSCALE }, INT_MIN, INT_MAX, 0, "flags"},
+{"flags", NULL, OFFSET(flags), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT }, 0, UINT_MAX, V|A|S|E|D, .unit = "flags"},
+{"unaligned", "allow decoders to produce unaligned output", 0, AV_OPT_TYPE_CONST, { .i64 = AV_CODEC_FLAG_UNALIGNED }, INT_MIN, INT_MAX, V | D, .unit = "flags" },
+{"mv4", "use four motion vectors per macroblock (MPEG-4)", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_4MV }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"qpel", "use 1/4-pel motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QPEL }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"loop", "use loop filter", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOOP_FILTER }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"qscale", "use fixed qscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QSCALE }, INT_MIN, INT_MAX, 0, .unit = "flags"},
 {"recon_frame", "export reconstructed frames", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_RECON_FRAME}, .unit = "flags"},
 {"copy_opaque", "propagate opaque values", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_COPY_OPAQUE}, .unit = "flags"},
 {"frame_duration", "use frame durations", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_FRAME_DURATION}, .unit = "flags"},
-{"pass1", "use internal 2-pass ratecontrol in first  pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS1 }, INT_MIN, INT_MAX, 0, "flags"},
-{"pass2", "use internal 2-pass ratecontrol in second pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS2 }, INT_MIN, INT_MAX, 0, "flags"},
-{"gray", "only decode/encode grayscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GRAY }, INT_MIN, INT_MAX, V|E|D, "flags"},
-{"psnr", "error[?] variables will be set during encoding", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PSNR }, INT_MIN, INT_MAX, V|E, "flags"},
-{"ildct", "use interlaced DCT", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_INTERLACED_DCT }, INT_MIN, INT_MAX, V|E, "flags"},
-{"low_delay", "force low delay", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOW_DELAY }, INT_MIN, INT_MAX, V|D|E, "flags"},
-{"global_header", "place global headers in extradata instead of every keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GLOBAL_HEADER }, INT_MIN, INT_MAX, V|A|E, "flags"},
-{"bitexact", "use only bitexact functions (except (I)DCT)", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_BITEXACT }, INT_MIN, INT_MAX, A|V|S|D|E, "flags"},
-{"aic", "H.263 advanced intra coding / MPEG-4 AC prediction", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_AC_PRED }, INT_MIN, INT_MAX, V|E, "flags"},
-{"ilme", "interlaced motion estimation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_INTERLACED_ME }, INT_MIN, INT_MAX, V|E, "flags"},
-{"cgop", "closed GOP", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_CLOSED_GOP }, INT_MIN, INT_MAX, V|E, "flags"},
-{"output_corrupt", "Output even potentially corrupted frames", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_OUTPUT_CORRUPT }, INT_MIN, INT_MAX, V|D, "flags"},
+{"pass1", "use internal 2-pass ratecontrol in first  pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS1 }, INT_MIN, INT_MAX, 0, .unit = "flags"},
+{"pass2", "use internal 2-pass ratecontrol in second pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS2 }, INT_MIN, INT_MAX, 0, .unit = "flags"},
+{"gray", "only decode/encode grayscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GRAY }, INT_MIN, INT_MAX, V|E|D, .unit = "flags"},
+{"psnr", "error[?] variables will be set during encoding", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PSNR }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"ildct", "use interlaced DCT", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_INTERLACED_DCT }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"low_delay", "force low delay", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOW_DELAY }, INT_MIN, INT_MAX, V|D|E, .unit = "flags"},
+{"global_header", "place global headers in extradata instead of every keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GLOBAL_HEADER }, INT_MIN, INT_MAX, V|A|E, .unit = "flags"},
+{"bitexact", "use only bitexact functions (except (I)DCT)", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_BITEXACT }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "flags"},
+{"aic", "H.263 advanced intra coding / MPEG-4 AC prediction", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_AC_PRED }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"ilme", "interlaced motion estimation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_INTERLACED_ME }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"cgop", "closed GOP", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_CLOSED_GOP }, INT_MIN, INT_MAX, V|E, .unit = "flags"},
+{"output_corrupt", "Output even potentially corrupted frames", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_OUTPUT_CORRUPT }, INT_MIN, INT_MAX, V|D, .unit = "flags"},
 #if FF_API_DROPCHANGED
-{"drop_changed", "Drop frames whose parameters differ from first decoded frame", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_DROPCHANGED }, INT_MIN, INT_MAX, A|V|D | AV_OPT_FLAG_DEPRECATED, "flags"},
+{"drop_changed", "Drop frames whose parameters differ from first decoded frame", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_DROPCHANGED }, INT_MIN, INT_MAX, A|V|D | AV_OPT_FLAG_DEPRECATED, .unit = "flags"},
 #endif
-{"flags2", NULL, OFFSET(flags2), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, V|A|E|D|S, "flags2"},
-{"fast", "allow non-spec-compliant speedup tricks", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_FAST }, INT_MIN, INT_MAX, V|E, "flags2"},
-{"noout", "skip bitstream encoding", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_NO_OUTPUT }, INT_MIN, INT_MAX, V|E, "flags2"},
-{"ignorecrop", "ignore cropping information from sps", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_IGNORE_CROP }, INT_MIN, INT_MAX, V|D, "flags2"},
-{"local_header", "place global headers at every keyframe instead of in extradata", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_LOCAL_HEADER }, INT_MIN, INT_MAX, V|E, "flags2"},
-{"chunks", "Frame data might be split into multiple chunks", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_CHUNKS }, INT_MIN, INT_MAX, V|D, "flags2"},
-{"showall", "Show all frames before the first keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SHOW_ALL }, INT_MIN, INT_MAX, V|D, "flags2"},
-{"export_mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_EXPORT_MVS}, INT_MIN, INT_MAX, V|D, "flags2"},
-{"skip_manual", "do not skip samples and export skip information as frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SKIP_MANUAL}, INT_MIN, INT_MAX, A|D, "flags2"},
-{"ass_ro_flush_noop", "do not reset ASS ReadOrder field on flush", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_RO_FLUSH_NOOP}, INT_MIN, INT_MAX, S|D, "flags2"},
-{"icc_profiles", "generate/parse embedded ICC profiles from/to colorimetry tags", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_ICC_PROFILES}, INT_MIN, INT_MAX, S|D, "flags2"},
-{"export_side_data", "Export metadata as side data", OFFSET(export_side_data), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, A|V|S|D|E, "export_side_data"},
-{"mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_MVS}, INT_MIN, INT_MAX, V|D, "export_side_data"},
-{"prft", "export Producer Reference Time through packet side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_PRFT}, INT_MIN, INT_MAX, A|V|S|E, "export_side_data"},
-{"venc_params", "export video encoding parameters through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS}, INT_MIN, INT_MAX, V|D, "export_side_data"},
-{"film_grain", "export film grain parameters through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_FILM_GRAIN}, INT_MIN, INT_MAX, V|D, "export_side_data"},
+{"flags2", NULL, OFFSET(flags2), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, V|A|E|D|S, .unit = "flags2"},
+{"fast", "allow non-spec-compliant speedup tricks", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_FAST }, INT_MIN, INT_MAX, V|E, .unit = "flags2"},
+{"noout", "skip bitstream encoding", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_NO_OUTPUT }, INT_MIN, INT_MAX, V|E, .unit = "flags2"},
+{"ignorecrop", "ignore cropping information from sps", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_IGNORE_CROP }, INT_MIN, INT_MAX, V|D, .unit = "flags2"},
+{"local_header", "place global headers at every keyframe instead of in extradata", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_LOCAL_HEADER }, INT_MIN, INT_MAX, V|E, .unit = "flags2"},
+{"chunks", "Frame data might be split into multiple chunks", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_CHUNKS }, INT_MIN, INT_MAX, V|D, .unit = "flags2"},
+{"showall", "Show all frames before the first keyframe", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SHOW_ALL }, INT_MIN, INT_MAX, V|D, .unit = "flags2"},
+{"export_mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_EXPORT_MVS}, INT_MIN, INT_MAX, V|D, .unit = "flags2"},
+{"skip_manual", "do not skip samples and export skip information as frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SKIP_MANUAL}, INT_MIN, INT_MAX, A|D, .unit = "flags2"},
+{"ass_ro_flush_noop", "do not reset ASS ReadOrder field on flush", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_RO_FLUSH_NOOP}, INT_MIN, INT_MAX, S|D, .unit = "flags2"},
+{"icc_profiles", "generate/parse embedded ICC profiles from/to colorimetry tags", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_ICC_PROFILES}, INT_MIN, INT_MAX, S|D, .unit = "flags2"},
+{"export_side_data", "Export metadata as side data", OFFSET(export_side_data), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, A|V|S|D|E, .unit = "export_side_data"},
+{"mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_MVS}, INT_MIN, INT_MAX, V|D, .unit = "export_side_data"},
+{"prft", "export Producer Reference Time through packet side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_PRFT}, INT_MIN, INT_MAX, A|V|S|E, .unit = "export_side_data"},
+{"venc_params", "export video encoding parameters through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS}, INT_MIN, INT_MAX, V|D, .unit = "export_side_data"},
+{"film_grain", "export film grain parameters through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_FILM_GRAIN}, INT_MIN, INT_MAX, V|D, .unit = "export_side_data"},
 {"time_base", NULL, OFFSET(time_base), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, INT_MAX},
 {"g", "set the group of picture (GOP) size", OFFSET(gop_size), AV_OPT_TYPE_INT, {.i64 = 12 }, INT_MIN, INT_MAX, V|E},
 {"ar", "set audio sampling rate (in Hz)", OFFSET(sample_rate), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|D|E},
-#if FF_API_OLD_CHANNEL_LAYOUT
-{"ac", "set number of audio channels", OFFSET(channels), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|D|E},
-#endif
 {"cutoff", "set cutoff bandwidth", OFFSET(cutoff), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, A|E},
 {"frame_size", NULL, OFFSET(frame_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, A|E},
 {"frame_number", NULL, OFFSET(frame_num), AV_OPT_TYPE_INT64, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
@@ -111,38 +110,38 @@ static const AVOption avcodec_options[] = {
 {"bf", "set maximum number of B-frames between non-B-frames", OFFSET(max_b_frames), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, -1, INT_MAX, V|E},
 {"b_qfactor", "QP factor between P- and B-frames", OFFSET(b_quant_factor), AV_OPT_TYPE_FLOAT, {.dbl = 1.25 }, -FLT_MAX, FLT_MAX, V|E},
 {"codec_tag", NULL, OFFSET(codec_tag), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"bug", "work around not autodetected encoder bugs", OFFSET(workaround_bugs), AV_OPT_TYPE_FLAGS, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, "bug"},
-{"autodetect", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, "bug"},
-{"xvid_ilace", "Xvid interlacing bug (autodetected if FOURCC == XVIX)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_XVID_ILACE }, INT_MIN, INT_MAX, V|D, "bug"},
-{"ump4", "(autodetected if FOURCC == UMP4)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_UMP4 }, INT_MIN, INT_MAX, V|D, "bug"},
-{"no_padding", "padding bug (autodetected)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_NO_PADDING }, INT_MIN, INT_MAX, V|D, "bug"},
-{"amv", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_AMV }, INT_MIN, INT_MAX, V|D, "bug"},
-{"qpel_chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_QPEL_CHROMA }, INT_MIN, INT_MAX, V|D, "bug"},
-{"std_qpel", "old standard qpel (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_STD_QPEL }, INT_MIN, INT_MAX, V|D, "bug"},
-{"qpel_chroma2", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_QPEL_CHROMA2 }, INT_MIN, INT_MAX, V|D, "bug"},
-{"direct_blocksize", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_DIRECT_BLOCKSIZE }, INT_MIN, INT_MAX, V|D, "bug"},
-{"edge", "edge padding bug (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_EDGE }, INT_MIN, INT_MAX, V|D, "bug"},
-{"hpel_chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_HPEL_CHROMA }, INT_MIN, INT_MAX, V|D, "bug"},
-{"dc_clip", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_DC_CLIP }, INT_MIN, INT_MAX, V|D, "bug"},
-{"ms", "work around various bugs in Microsoft's broken decoders", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_MS }, INT_MIN, INT_MAX, V|D, "bug"},
-{"trunc", "truncated frames", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_TRUNCATED}, INT_MIN, INT_MAX, V|D, "bug"},
-{"iedge", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_IEDGE }, INT_MIN, INT_MAX, V|D, "bug"},
-{"strict", "how strictly to follow the standards", OFFSET(strict_std_compliance), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
-{"very", "strictly conform to a older more strict version of the spec or reference software", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_VERY_STRICT }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
-{"strict", "strictly conform to all the things in the spec no matter what the consequences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_STRICT }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
-{"normal", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_NORMAL }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
-{"unofficial", "allow unofficial extensions", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_UNOFFICIAL }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
-{"experimental", "allow non-standardized experimental things", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_EXPERIMENTAL }, INT_MIN, INT_MAX, A|V|D|E, "strict"},
+{"bug", "work around not autodetected encoder bugs", OFFSET(workaround_bugs), AV_OPT_TYPE_FLAGS, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"autodetect", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_AUTODETECT }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"xvid_ilace", "Xvid interlacing bug (autodetected if FOURCC == XVIX)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_XVID_ILACE }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"ump4", "(autodetected if FOURCC == UMP4)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_UMP4 }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"no_padding", "padding bug (autodetected)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_NO_PADDING }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"amv", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_AMV }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"qpel_chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_QPEL_CHROMA }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"std_qpel", "old standard qpel (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_STD_QPEL }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"qpel_chroma2", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_QPEL_CHROMA2 }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"direct_blocksize", "direct-qpel-blocksize bug (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_DIRECT_BLOCKSIZE }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"edge", "edge padding bug (autodetected per FOURCC/version)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_EDGE }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"hpel_chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_HPEL_CHROMA }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"dc_clip", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_DC_CLIP }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"ms", "work around various bugs in Microsoft's broken decoders", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_MS }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"trunc", "truncated frames", 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_TRUNCATED}, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"iedge", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_BUG_IEDGE }, INT_MIN, INT_MAX, V|D, .unit = "bug"},
+{"strict", "how strictly to follow the standards", OFFSET(strict_std_compliance), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
+{"very", "strictly conform to a older more strict version of the spec or reference software", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_VERY_STRICT }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
+{"strict", "strictly conform to all the things in the spec no matter what the consequences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_STRICT }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
+{"normal", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_NORMAL }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
+{"unofficial", "allow unofficial extensions", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_UNOFFICIAL }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
+{"experimental", "allow non-standardized experimental things", 0, AV_OPT_TYPE_CONST, {.i64 = FF_COMPLIANCE_EXPERIMENTAL }, INT_MIN, INT_MAX, A|V|D|E, .unit = "strict"},
 {"b_qoffset", "QP offset between P- and B-frames", OFFSET(b_quant_offset), AV_OPT_TYPE_FLOAT, {.dbl = 1.25 }, -FLT_MAX, FLT_MAX, V|E},
-{"err_detect", "set error detection flags", OFFSET(err_recognition), AV_OPT_TYPE_FLAGS, {.i64 = 0 }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"crccheck", "verify embedded CRCs", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_CRCCHECK }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"bitstream", "detect bitstream specification deviations", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_BITSTREAM }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"buffer", "detect improper bitstream length", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_BUFFER }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"explode", "abort decoding on minor error detection", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_EXPLODE }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"ignore_err", "ignore errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_IGNORE_ERR }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"careful",    "consider things that violate the spec, are fast to check and have not been seen in the wild as errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_CAREFUL }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"compliant",  "consider all spec non compliancies as errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_COMPLIANT | AV_EF_CAREFUL }, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
-{"aggressive", "consider things that a sane encoder should not do as an error", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_AGGRESSIVE | AV_EF_COMPLIANT | AV_EF_CAREFUL}, INT_MIN, INT_MAX, A|V|S|D|E, "err_detect"},
+{"err_detect", "set error detection flags", OFFSET(err_recognition), AV_OPT_TYPE_FLAGS, {.i64 = 0 }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"crccheck", "verify embedded CRCs", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_CRCCHECK }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"bitstream", "detect bitstream specification deviations", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_BITSTREAM }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"buffer", "detect improper bitstream length", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_BUFFER }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"explode", "abort decoding on minor error detection", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_EXPLODE }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"ignore_err", "ignore errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_IGNORE_ERR }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"careful",    "consider things that violate the spec, are fast to check and have not been seen in the wild as errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_CAREFUL }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"compliant",  "consider all spec non compliancies as errors", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_COMPLIANT | AV_EF_CAREFUL }, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
+{"aggressive", "consider things that a sane encoder should not do as an error", 0, AV_OPT_TYPE_CONST, {.i64 = AV_EF_AGGRESSIVE | AV_EF_COMPLIANT | AV_EF_CAREFUL}, INT_MIN, INT_MAX, A|V|S|D|E, .unit = "err_detect"},
 {"has_b_frames", NULL, OFFSET(has_b_frames), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
 {"block_align", NULL, OFFSET(block_align), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
 {"rc_override_count", NULL, OFFSET(rc_override_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
@@ -152,59 +151,56 @@ static const AVOption avcodec_options[] = {
 {"bufsize", "set ratecontrol buffer size (in bits)", OFFSET(rc_buffer_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, A|V|E},
 {"i_qfactor", "QP factor between P- and I-frames", OFFSET(i_quant_factor), AV_OPT_TYPE_FLOAT, {.dbl = -0.8 }, -FLT_MAX, FLT_MAX, V|E},
 {"i_qoffset", "QP offset between P- and I-frames", OFFSET(i_quant_offset), AV_OPT_TYPE_FLOAT, {.dbl = 0.0 }, -FLT_MAX, FLT_MAX, V|E},
-{"dct", "DCT algorithm", OFFSET(dct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E, "dct"},
-{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_AUTO }, INT_MIN, INT_MAX, V|E, "dct"},
-{"fastint", "fast integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FASTINT }, INT_MIN, INT_MAX, V|E, "dct"},
-{"int", "accurate integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_INT }, INT_MIN, INT_MAX, V|E, "dct"},
-{"mmx", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_MMX }, INT_MIN, INT_MAX, V|E, "dct"},
-{"altivec", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_ALTIVEC }, INT_MIN, INT_MAX, V|E, "dct"},
-{"faan", "floating point AAN DCT", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FAAN }, INT_MIN, INT_MAX, V|E, "dct"},
+{"dct", "DCT algorithm", OFFSET(dct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E, .unit = "dct"},
+{"auto", "autoselect a good one", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_AUTO }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"fastint", "fast integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FASTINT }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"int", "accurate integer", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_INT }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"mmx", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_MMX }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"altivec", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_ALTIVEC }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
+{"faan", "floating point AAN DCT", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DCT_FAAN }, INT_MIN, INT_MAX, V|E, .unit = "dct"},
 {"lumi_mask", "compresses bright areas stronger than medium ones", OFFSET(lumi_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, V|E},
 {"tcplx_mask", "temporal complexity masking", OFFSET(temporal_cplx_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, V|E},
 {"scplx_mask", "spatial complexity masking", OFFSET(spatial_cplx_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, V|E},
 {"p_mask", "inter masking", OFFSET(p_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, V|E},
 {"dark_mask", "compresses dark areas stronger than medium ones", OFFSET(dark_masking), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, -FLT_MAX, FLT_MAX, V|E},
-{"idct", "select IDCT implementation", OFFSET(idct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E|D, "idct"},
-{"auto", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_AUTO }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"int", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_INT }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simple", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLE }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplemmx", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEMMX }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"arm", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ARM }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"altivec", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ALTIVEC }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearm", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARM }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearmv5te", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV5TE }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simplearmv6", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV6 }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"simpleneon", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLENEON }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"xvid", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"xvidmmx", "deprecated, for compatibility only", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, "idct"},
-{"faani", "floating point AAN IDCT", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_FAAN }, INT_MIN, INT_MAX, V|D|E, "idct"},
-{"simpleauto", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEAUTO }, INT_MIN, INT_MAX, V|E|D, "idct"},
-#if FF_API_SLICE_OFFSET
-{"slice_count", NULL, OFFSET(slice_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-#endif
-{"ec", "set error concealment strategy", OFFSET(error_concealment), AV_OPT_TYPE_FLAGS, {.i64 = 3 }, INT_MIN, INT_MAX, V|D, "ec"},
-{"guess_mvs", "iterative motion vector (MV) search (slow)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_GUESS_MVS }, INT_MIN, INT_MAX, V|D, "ec"},
-{"deblock", "use strong deblock filter for damaged MBs", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_DEBLOCK }, INT_MIN, INT_MAX, V|D, "ec"},
-{"favor_inter", "favor predicting from the previous frame", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_FAVOR_INTER }, INT_MIN, INT_MAX, V|D, "ec"},
+{"idct", "select IDCT implementation", OFFSET(idct_algo), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX, V|E|D, .unit = "idct"},
+{"auto", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_AUTO }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"int", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_INT }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simple", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLE }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplemmx", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEMMX }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"arm", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ARM }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"altivec", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_ALTIVEC }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearm", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARM }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearmv5te", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV5TE }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simplearmv6", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEARMV6 }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"simpleneon", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLENEON }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"xvid", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"xvidmmx", "deprecated, for compatibility only", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_XVID }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"faani", "floating point AAN IDCT", 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_FAAN }, INT_MIN, INT_MAX, V|D|E, .unit = "idct"},
+{"simpleauto", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_IDCT_SIMPLEAUTO }, INT_MIN, INT_MAX, V|E|D, .unit = "idct"},
+{"ec", "set error concealment strategy", OFFSET(error_concealment), AV_OPT_TYPE_FLAGS, {.i64 = 3 }, INT_MIN, INT_MAX, V|D, .unit = "ec"},
+{"guess_mvs", "iterative motion vector (MV) search (slow)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_GUESS_MVS }, INT_MIN, INT_MAX, V|D, .unit = "ec"},
+{"deblock", "use strong deblock filter for damaged MBs", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_DEBLOCK }, INT_MIN, INT_MAX, V|D, .unit = "ec"},
+{"favor_inter", "favor predicting from the previous frame", 0, AV_OPT_TYPE_CONST, {.i64 = FF_EC_FAVOR_INTER }, INT_MIN, INT_MAX, V|D, .unit = "ec"},
 {"bits_per_coded_sample", NULL, OFFSET(bits_per_coded_sample), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
 {"aspect", "sample aspect ratio", OFFSET(sample_aspect_ratio), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, 10, V|E},
 {"sar",    "sample aspect ratio", OFFSET(sample_aspect_ratio), AV_OPT_TYPE_RATIONAL, {.dbl = 0}, 0, 10, V|E},
-{"debug", "print specific debug info", OFFSET(debug), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT }, 0, INT_MAX, V|A|S|E|D, "debug"},
-{"pict", "picture info", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_PICT_INFO }, INT_MIN, INT_MAX, V|D, "debug"},
-{"rc", "rate control", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_RC }, INT_MIN, INT_MAX, V|E, "debug"},
-{"bitstream", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BITSTREAM }, INT_MIN, INT_MAX, V|D, "debug"},
-{"mb_type", "macroblock (MB) type", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_MB_TYPE }, INT_MIN, INT_MAX, V|D, "debug"},
-{"qp", "per-block quantization parameter (QP)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_QP }, INT_MIN, INT_MAX, V|D, "debug"},
-{"dct_coeff", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_DCT_COEFF }, INT_MIN, INT_MAX, V|D, "debug"},
-{"green_metadata", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_GREEN_MD }, INT_MIN, INT_MAX, V|D, "debug"},
-{"skip", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_SKIP }, INT_MIN, INT_MAX, V|D, "debug"},
-{"startcode", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_STARTCODE }, INT_MIN, INT_MAX, V|D, "debug"},
-{"er", "error recognition", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_ER }, INT_MIN, INT_MAX, V|D, "debug"},
-{"mmco", "memory management control operations (H.264)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_MMCO }, INT_MIN, INT_MAX, V|D, "debug"},
-{"bugs", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BUGS }, INT_MIN, INT_MAX, V|D, "debug"},
-{"buffers", "picture buffer allocations", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BUFFERS }, INT_MIN, INT_MAX, V|D, "debug"},
-{"thread_ops", "threading operations", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_THREADS }, INT_MIN, INT_MAX, V|A|D, "debug"},
-{"nomc", "skip motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_NOMC }, INT_MIN, INT_MAX, V|A|D, "debug"},
+{"debug", "print specific debug info", OFFSET(debug), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT }, 0, INT_MAX, V|A|S|E|D, .unit = "debug"},
+{"pict", "picture info", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_PICT_INFO }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"rc", "rate control", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_RC }, INT_MIN, INT_MAX, V|E, .unit = "debug"},
+{"bitstream", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BITSTREAM }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"mb_type", "macroblock (MB) type", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_MB_TYPE }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"qp", "per-block quantization parameter (QP)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_QP }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"dct_coeff", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_DCT_COEFF }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"green_metadata", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_GREEN_MD }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"skip", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_SKIP }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"startcode", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_STARTCODE }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"er", "error recognition", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_ER }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"mmco", "memory management control operations (H.264)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_MMCO }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"bugs", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BUGS }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"buffers", "picture buffer allocations", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_BUFFERS }, INT_MIN, INT_MAX, V|D, .unit = "debug"},
+{"thread_ops", "threading operations", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_THREADS }, INT_MIN, INT_MAX, V|A|D, .unit = "debug"},
+{"nomc", "skip motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = FF_DEBUG_NOMC }, INT_MIN, INT_MAX, V|A|D, .unit = "debug"},
 {"dia_size", "diamond type & size for motion estimation", OFFSET(dia_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"last_pred", "amount of motion predictors from the previous frame", OFFSET(last_predictor_count), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"pre_dia_size", "diamond type & size for motion estimation pre-pass", OFFSET(pre_dia_size), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
@@ -212,58 +208,58 @@ static const AVOption avcodec_options[] = {
 {"me_range", "limit motion vectors range (1023 for DivX player)", OFFSET(me_range), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
 {"global_quality", NULL, OFFSET(global_quality), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|A|E},
 {"slice_flags", NULL, OFFSET(slice_flags), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX},
-{"mbd", "macroblock decision algorithm (high quality mode)", OFFSET(mb_decision), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, 2, V|E, "mbd"},
-{"simple", "use mbcmp", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_SIMPLE }, INT_MIN, INT_MAX, V|E, "mbd"},
-{"bits", "use fewest bits", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_BITS }, INT_MIN, INT_MAX, V|E, "mbd"},
-{"rd", "use best rate distortion", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_RD }, INT_MIN, INT_MAX, V|E, "mbd"},
+{"mbd", "macroblock decision algorithm (high quality mode)", OFFSET(mb_decision), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, 2, V|E, .unit = "mbd"},
+{"simple", "use mbcmp", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_SIMPLE }, INT_MIN, INT_MAX, V|E, .unit = "mbd"},
+{"bits", "use fewest bits", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_BITS }, INT_MIN, INT_MAX, V|E, .unit = "mbd"},
+{"rd", "use best rate distortion", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MB_DECISION_RD }, INT_MIN, INT_MAX, V|E, .unit = "mbd"},
 {"rc_init_occupancy", "number of bits which should be loaded into the rc buffer before decoding starts", OFFSET(rc_initial_buffer_occupancy), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E},
-{"threads", "set the number of threads", OFFSET(thread_count), AV_OPT_TYPE_INT, {.i64 = 1 }, 0, INT_MAX, V|A|E|D, "threads"},
-{"auto", "autodetect a suitable number of threads to use", 0, AV_OPT_TYPE_CONST, {.i64 = 0 }, INT_MIN, INT_MAX, V|E|D, "threads"},
+{"threads", "set the number of threads", OFFSET(thread_count), AV_OPT_TYPE_INT, {.i64 = 1 }, 0, INT_MAX, V|A|E|D, .unit = "threads"},
+{"auto", "autodetect a suitable number of threads to use", 0, AV_OPT_TYPE_CONST, {.i64 = 0 }, INT_MIN, INT_MAX, V|E|D, .unit = "threads"},
 {"dc", "intra_dc_precision", OFFSET(intra_dc_precision), AV_OPT_TYPE_INT, {.i64 = 0 }, -8, 16, V|E},
 {"nssew", "nsse weight", OFFSET(nsse_weight), AV_OPT_TYPE_INT, {.i64 = 8 }, INT_MIN, INT_MAX, V|E},
 {"skip_top", "number of macroblock rows at the top which are skipped", OFFSET(skip_top), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|D},
 {"skip_bottom", "number of macroblock rows at the bottom which are skipped", OFFSET(skip_bottom), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|D},
-{"profile", NULL, OFFSET(profile), AV_OPT_TYPE_INT, {.i64 = AV_PROFILE_UNKNOWN }, INT_MIN, INT_MAX, V|A|E|CC, "avctx.profile"},
-{"unknown", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_PROFILE_UNKNOWN }, INT_MIN, INT_MAX, V|A|E, "avctx.profile"},
-{"main10",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_PROFILE_HEVC_MAIN_10 }, INT_MIN, INT_MAX, V|E, "avctx.profile"},
-{"level", "encoding level, usually corresponding to the profile level, codec-specific", OFFSET(level), AV_OPT_TYPE_INT, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E|CC, "avctx.level"},
-{"unknown", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E, "avctx.level"},
+{"profile", NULL, OFFSET(profile), AV_OPT_TYPE_INT, {.i64 = AV_PROFILE_UNKNOWN }, INT_MIN, INT_MAX, V|A|E|CC, .unit = "avctx.profile"},
+{"unknown", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_PROFILE_UNKNOWN }, INT_MIN, INT_MAX, V|A|E, .unit = "avctx.profile"},
+{"main10",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_PROFILE_HEVC_MAIN_10 }, INT_MIN, INT_MAX, V|E, .unit = "avctx.profile"},
+{"level", "encoding level, usually corresponding to the profile level, codec-specific", OFFSET(level), AV_OPT_TYPE_INT, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E|CC, .unit = "avctx.level"},
+{"unknown", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_LEVEL_UNKNOWN }, INT_MIN, INT_MAX, V|A|E, .unit = "avctx.level"},
 {"lowres", "decode at 1= 1/2, 2=1/4, 3=1/8 resolutions", OFFSET(lowres), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, V|A|D},
-{"cmp", "full-pel ME compare function", OFFSET(me_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"subcmp", "sub-pel ME compare function", OFFSET(me_sub_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"mbcmp", "macroblock compare function", OFFSET(mb_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"ildctcmp", "interlaced DCT compare function", OFFSET(ildct_cmp), AV_OPT_TYPE_INT, {.i64 = FF_CMP_VSAD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"precmp", "pre motion estimation compare function", OFFSET(me_pre_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"sad", "sum of absolute differences, fast", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SAD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"sse", "sum of squared errors", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SSE }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"satd", "sum of absolute Hadamard transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SATD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"dct", "sum of absolute DCT transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"psnr", "sum of squared quantization errors (avoid, low quality)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_PSNR }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"bit", "number of bits needed for the block", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_BIT }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"rd", "rate distortion optimal, slow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_RD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"zero", "0", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_ZERO }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"vsad", "sum of absolute vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSAD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"vsse", "sum of squared vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSSE }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"nsse", "noise preserving sum of squared differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_NSSE }, INT_MIN, INT_MAX, V|E, "cmp_func"},
+{"cmp", "full-pel ME compare function", OFFSET(me_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"subcmp", "sub-pel ME compare function", OFFSET(me_sub_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"mbcmp", "macroblock compare function", OFFSET(mb_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"ildctcmp", "interlaced DCT compare function", OFFSET(ildct_cmp), AV_OPT_TYPE_INT, {.i64 = FF_CMP_VSAD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"precmp", "pre motion estimation compare function", OFFSET(me_pre_cmp), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"sad", "sum of absolute differences, fast", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SAD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"sse", "sum of squared errors", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SSE }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"satd", "sum of absolute Hadamard transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_SATD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"dct", "sum of absolute DCT transformed differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"psnr", "sum of squared quantization errors (avoid, low quality)", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_PSNR }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"bit", "number of bits needed for the block", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_BIT }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"rd", "rate distortion optimal, slow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_RD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"zero", "0", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_ZERO }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"vsad", "sum of absolute vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSAD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"vsse", "sum of squared vertical differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_VSSE }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"nsse", "noise preserving sum of squared differences", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_NSSE }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
 #if CONFIG_SNOW_ENCODER
-{"w53", "5/3 wavelet, only used in snow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_W53 }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"w97", "9/7 wavelet, only used in snow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_W97 }, INT_MIN, INT_MAX, V|E, "cmp_func"},
+{"w53", "5/3 wavelet, only used in snow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_W53 }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"w97", "9/7 wavelet, only used in snow", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_W97 }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
 #endif
-{"dctmax", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCTMAX }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_CHROMA }, INT_MIN, INT_MAX, V|E, "cmp_func"},
-{"msad", "sum of absolute differences, median predicted", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_MEDIAN_SAD }, INT_MIN, INT_MAX, V|E, "cmp_func"},
+{"dctmax", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_DCTMAX }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"chroma", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_CHROMA }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
+{"msad", "sum of absolute differences, median predicted", 0, AV_OPT_TYPE_CONST, {.i64 = FF_CMP_MEDIAN_SAD }, INT_MIN, INT_MAX, V|E, .unit = "cmp_func"},
 {"mblmin", "minimum macroblock Lagrange factor (VBR)", OFFSET(mb_lmin), AV_OPT_TYPE_INT, {.i64 = FF_QP2LAMBDA * 2 }, 1, FF_LAMBDA_MAX, V|E},
 {"mblmax", "maximum macroblock Lagrange factor (VBR)", OFFSET(mb_lmax), AV_OPT_TYPE_INT, {.i64 = FF_QP2LAMBDA * 31 }, 1, FF_LAMBDA_MAX, V|E},
-{"skip_loop_filter", "skip loop filtering process for the selected frames", OFFSET(skip_loop_filter), AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"skip_idct"       , "skip IDCT/dequantization for the selected frames",    OFFSET(skip_idct),        AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"skip_frame"      , "skip decoding for the selected frames",               OFFSET(skip_frame),       AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"none"            , "discard no frame",                    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONE    }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"default"         , "discard useless frames",              0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"noref"           , "discard all non-reference frames",    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONREF  }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"bidir"           , "discard all bidirectional frames",    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_BIDIR   }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"nointra"         , "discard all frames except I frames",  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONINTRA}, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"nokey"           , "discard all frames except keyframes", 0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONKEY  }, INT_MIN, INT_MAX, V|D, "avdiscard"},
-{"all"             , "discard all frames",                  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_ALL     }, INT_MIN, INT_MAX, V|D, "avdiscard"},
+{"skip_loop_filter", "skip loop filtering process for the selected frames", OFFSET(skip_loop_filter), AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"skip_idct"       , "skip IDCT/dequantization for the selected frames",    OFFSET(skip_idct),        AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"skip_frame"      , "skip decoding for the selected frames",               OFFSET(skip_frame),       AV_OPT_TYPE_INT, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"none"            , "discard no frame",                    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONE    }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"default"         , "discard useless frames",              0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_DEFAULT }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"noref"           , "discard all non-reference frames",    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONREF  }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"bidir"           , "discard all bidirectional frames",    0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_BIDIR   }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"nointra"         , "discard all frames except I frames",  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONINTRA}, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"nokey"           , "discard all frames except keyframes", 0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_NONKEY  }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
+{"all"             , "discard all frames",                  0, AV_OPT_TYPE_CONST, {.i64 = AVDISCARD_ALL     }, INT_MIN, INT_MAX, V|D, .unit = "avdiscard"},
 {"bidir_refine", "refine the two motion vectors used in bidirectional macroblocks", OFFSET(bidir_refine), AV_OPT_TYPE_INT, {.i64 = 1 }, 0, 4, V|E},
 {"keyint_min", "minimum interval between IDR-frames", OFFSET(keyint_min), AV_OPT_TYPE_INT, {.i64 = 25 }, INT_MIN, INT_MAX, V|E},
 {"refs", "reference frames to consider for motion compensation", OFFSET(refs), AV_OPT_TYPE_INT, {.i64 = 1 }, INT_MIN, INT_MAX, V|E},
@@ -271,140 +267,149 @@ static const AVOption avcodec_options[] = {
 {"mv0_threshold", NULL, OFFSET(mv0_threshold), AV_OPT_TYPE_INT, {.i64 = 256 }, 0, INT_MAX, V|E},
 {"compression_level", NULL, OFFSET(compression_level), AV_OPT_TYPE_INT, {.i64 = FF_COMPRESSION_DEFAULT }, INT_MIN, INT_MAX, V|A|E},
 {"bits_per_raw_sample", NULL, OFFSET(bits_per_raw_sample), AV_OPT_TYPE_INT, {.i64 = DEFAULT }, 0, INT_MAX},
-{"ch_layout", NULL, OFFSET(ch_layout), AV_OPT_TYPE_CHLAYOUT, {.str = NULL }, 0, 0, A|E|D, "ch_layout"},
-#if FF_API_OLD_CHANNEL_LAYOUT
-{"channel_layout", NULL, OFFSET(channel_layout), AV_OPT_TYPE_CHANNEL_LAYOUT, {.i64 = DEFAULT }, 0, UINT64_MAX, A|E|D, "channel_layout"},
-{"request_channel_layout", NULL, OFFSET(request_channel_layout), AV_OPT_TYPE_CHANNEL_LAYOUT, {.i64 = DEFAULT }, 0, UINT64_MAX, A|D, "request_channel_layout"},
-#endif
+{"ch_layout", NULL, OFFSET(ch_layout), AV_OPT_TYPE_CHLAYOUT, {.str = NULL }, 0, 0, A|E|D, .unit = "ch_layout"},
 {"rc_max_vbv_use", NULL, OFFSET(rc_max_available_vbv_use), AV_OPT_TYPE_FLOAT, {.dbl = 0 }, 0.0, FLT_MAX, V|E},
 {"rc_min_vbv_use", NULL, OFFSET(rc_min_vbv_overflow_use),  AV_OPT_TYPE_FLOAT, {.dbl = 3 },     0.0, FLT_MAX, V|E},
 #if FF_API_TICKS_PER_FRAME
 {"ticks_per_frame", NULL, OFFSET(ticks_per_frame), AV_OPT_TYPE_INT, {.i64 = 1 }, 1, INT_MAX, A|V|E|D},
 #endif
-{"color_primaries", "color primaries", OFFSET(color_primaries), AV_OPT_TYPE_INT, {.i64 = AVCOL_PRI_UNSPECIFIED }, 1, INT_MAX, V|E|D, "color_primaries_type"},
-{"bt709",       "BT.709",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT709 },        INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"unknown",     "Unspecified",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"bt470m",      "BT.470 M",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT470M },       INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"bt470bg",     "BT.470 BG",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT470BG },      INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte170m",   "SMPTE 170 M",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE170M },    INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte240m",   "SMPTE 240 M",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE240M },    INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"film",        "Film",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_FILM },         INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"bt2020",      "BT.2020",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT2020 },       INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte428",    "SMPTE 428-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte428_1",  "SMPTE 428-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte431",    "SMPTE 431-2",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE431 },     INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"smpte432",    "SMPTE 422-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE432 },     INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"jedec-p22",   "JEDEC P22",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_JEDEC_P22 },    INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"ebu3213",     "EBU 3213-E",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_EBU3213 },      INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"unspecified", "Unspecified",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, "color_primaries_type"},
-{"color_trc", "color transfer characteristics", OFFSET(color_trc), AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, INT_MAX, V|E|D, "color_trc_type"},
-{"bt709",        "BT.709",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"unknown",      "Unspecified",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"gamma22",      "BT.470 M",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"gamma28",      "BT.470 BG",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"smpte170m",    "SMPTE 170 M",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"smpte240m",    "SMPTE 240 M",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"linear",       "Linear",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"log100",       "Log",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"log316",       "Log square root",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"iec61966-2-4", "IEC 61966-2-4",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt1361e",      "BT.1361",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"iec61966-2-1", "IEC 61966-2-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt2020-10",    "BT.2020 - 10 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt2020-12",    "BT.2020 - 12 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"smpte2084",    "SMPTE 2084",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE2084 },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"smpte428",     "SMPTE 428-1",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"arib-std-b67", "ARIB STD-B67",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_ARIB_STD_B67 }, INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"unspecified",  "Unspecified",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"log",          "Log",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"log_sqrt",     "Log square root",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"iec61966_2_4", "IEC 61966-2-4",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt1361",       "BT.1361",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"iec61966_2_1", "IEC 61966-2-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt2020_10bit", "BT.2020 - 10 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"bt2020_12bit", "BT.2020 - 12 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"smpte428_1",   "SMPTE 428-1",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, "color_trc_type"},
-{"colorspace", "color space", OFFSET(colorspace), AV_OPT_TYPE_INT, {.i64 = AVCOL_SPC_UNSPECIFIED }, 0, INT_MAX, V|E|D, "colorspace_type"},
-{"rgb",               "RGB",                0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_RGB },                INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt709",             "BT.709",             0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT709 },              INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"unknown",           "Unspecified",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_UNSPECIFIED },        INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"fcc",               "FCC",                0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_FCC },                INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt470bg",           "BT.470 BG",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT470BG },            INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"smpte170m",         "SMPTE 170 M",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE170M },          INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"smpte240m",         "SMPTE 240 M",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE240M },          INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"ycgco",             "YCGCO",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO },              INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt2020nc",          "BT.2020 NCL",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_NCL },         INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt2020c",           "BT.2020 CL",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_CL },          INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"smpte2085",         "SMPTE 2085",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE2085 },          INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"chroma-derived-nc", "Chroma-derived NCL", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_CHROMA_DERIVED_NCL }, INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"chroma-derived-c",  "Chroma-derived CL",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_CHROMA_DERIVED_CL },  INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"ictcp",             "ICtCp",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_ICTCP },              INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"unspecified",       "Unspecified",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_UNSPECIFIED },        INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"ycocg",             "YCGCO",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO },              INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt2020_ncl",        "BT.2020 NCL",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_NCL },         INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"bt2020_cl",         "BT.2020 CL",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_CL },          INT_MIN, INT_MAX, V|E|D, "colorspace_type"},
-{"color_range", "color range", OFFSET(color_range), AV_OPT_TYPE_INT, {.i64 = AVCOL_RANGE_UNSPECIFIED }, 0, INT_MAX, V|E|D, "color_range_type"},
-{"unknown", "Unspecified",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"tv", "MPEG (219*2^(n-8))",   0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },        INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"pc", "JPEG (2^n-1)",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"unspecified", "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"mpeg", "MPEG (219*2^(n-8))", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },        INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"jpeg", "JPEG (2^n-1)",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"limited", "MPEG (219*2^(n-8))", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },     INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"full", "JPEG (2^n-1)",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, "color_range_type"},
-{"chroma_sample_location", "chroma sample location", OFFSET(chroma_sample_location), AV_OPT_TYPE_INT, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, 0, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"unknown",     "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"left",        "Left",        0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_LEFT },        INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"center",      "Center",      0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_CENTER },      INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"topleft",     "Top-left",    0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_TOPLEFT },     INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"top",         "Top",         0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_TOP },         INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"bottomleft",  "Bottom-left", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_BOTTOMLEFT },  INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"bottom",      "Bottom",      0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_BOTTOM },      INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
-{"unspecified", "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, "chroma_sample_location_type"},
+{"color_primaries", "color primaries", OFFSET(color_primaries), AV_OPT_TYPE_INT, {.i64 = AVCOL_PRI_UNSPECIFIED }, 1, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"bt709",       "BT.709",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT709 },        INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"unknown",     "Unspecified",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"bt470m",      "BT.470 M",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT470M },       INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"bt470bg",     "BT.470 BG",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT470BG },      INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte170m",   "SMPTE 170 M",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE170M },    INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte240m",   "SMPTE 240 M",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE240M },    INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"film",        "Film",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_FILM },         INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"bt2020",      "BT.2020",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_BT2020 },       INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte428",    "SMPTE 428-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte428_1",  "SMPTE 428-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte431",    "SMPTE 431-2",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE431 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"smpte432",    "SMPTE 422-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_SMPTE432 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"jedec-p22",   "JEDEC P22",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_JEDEC_P22 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"ebu3213",     "EBU 3213-E",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_EBU3213 },      INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"unspecified", "Unspecified",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_PRI_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, .unit = "color_primaries_type"},
+{"color_trc", "color transfer characteristics", OFFSET(color_trc), AV_OPT_TYPE_INT, {.i64 = AVCOL_TRC_UNSPECIFIED }, 1, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt709",        "BT.709",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT709 },        INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"unknown",      "Unspecified",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"gamma22",      "BT.470 M",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA22 },      INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"gamma28",      "BT.470 BG",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_GAMMA28 },      INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"smpte170m",    "SMPTE 170 M",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE170M },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"smpte240m",    "SMPTE 240 M",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE240M },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"linear",       "Linear",           0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LINEAR },       INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"log100",       "Log",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"log316",       "Log square root",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"iec61966-2-4", "IEC 61966-2-4",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt1361e",      "BT.1361",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"iec61966-2-1", "IEC 61966-2-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt2020-10",    "BT.2020 - 10 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt2020-12",    "BT.2020 - 12 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"smpte2084",    "SMPTE 2084",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE2084 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"smpte428",     "SMPTE 428-1",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"arib-std-b67", "ARIB STD-B67",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_ARIB_STD_B67 }, INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"unspecified",  "Unspecified",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_UNSPECIFIED },  INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"log",          "Log",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG },          INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"log_sqrt",     "Log square root",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_LOG_SQRT },     INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"iec61966_2_4", "IEC 61966-2-4",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_4 }, INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt1361",       "BT.1361",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT1361_ECG },   INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"iec61966_2_1", "IEC 61966-2-1",    0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_IEC61966_2_1 }, INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt2020_10bit", "BT.2020 - 10 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_10 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"bt2020_12bit", "BT.2020 - 12 bit", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_BT2020_12 },    INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"smpte428_1",   "SMPTE 428-1",      0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_TRC_SMPTE428 },     INT_MIN, INT_MAX, V|E|D, .unit = "color_trc_type"},
+{"colorspace", "color space", OFFSET(colorspace), AV_OPT_TYPE_INT, {.i64 = AVCOL_SPC_UNSPECIFIED }, 0, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"rgb",               "RGB",                0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_RGB },                INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt709",             "BT.709",             0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT709 },              INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"unknown",           "Unspecified",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_UNSPECIFIED },        INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"fcc",               "FCC",                0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_FCC },                INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt470bg",           "BT.470 BG",          0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT470BG },            INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"smpte170m",         "SMPTE 170 M",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE170M },          INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"smpte240m",         "SMPTE 240 M",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE240M },          INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ycgco",             "YCGCO",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO },              INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt2020nc",          "BT.2020 NCL",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_NCL },         INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt2020c",           "BT.2020 CL",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_CL },          INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"smpte2085",         "SMPTE 2085",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_SMPTE2085 },          INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"chroma-derived-nc", "Chroma-derived NCL", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_CHROMA_DERIVED_NCL }, INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"chroma-derived-c",  "Chroma-derived CL",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_CHROMA_DERIVED_CL },  INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ictcp",             "ICtCp",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_ICTCP },              INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ipt-c2",            "IPT-C2",             0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_IPT_C2 },             INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"unspecified",       "Unspecified",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_UNSPECIFIED },        INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ycocg",             "YCGCO",              0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO },              INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ycgco-re",          "YCgCo-R, even add.", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO_RE },           INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"ycgco-ro",          "YCgCo-R, odd add.",  0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_YCGCO_RO },           INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt2020_ncl",        "BT.2020 NCL",        0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_NCL },         INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"bt2020_cl",         "BT.2020 CL",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_SPC_BT2020_CL },          INT_MIN, INT_MAX, V|E|D, .unit = "colorspace_type"},
+{"color_range", "color range", OFFSET(color_range), AV_OPT_TYPE_INT, {.i64 = AVCOL_RANGE_UNSPECIFIED }, 0, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"unknown", "Unspecified",     0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"tv", "MPEG (219*2^(n-8))",   0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },        INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"pc", "JPEG (2^n-1)",         0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"unspecified", "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"mpeg", "MPEG (219*2^(n-8))", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },        INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"jpeg", "JPEG (2^n-1)",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"limited", "MPEG (219*2^(n-8))", 0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_MPEG },     INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"full", "JPEG (2^n-1)",       0, AV_OPT_TYPE_CONST, {.i64 = AVCOL_RANGE_JPEG },        INT_MIN, INT_MAX, V|E|D, .unit = "color_range_type"},
+{"chroma_sample_location", "chroma sample location", OFFSET(chroma_sample_location), AV_OPT_TYPE_INT, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, 0, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"unknown",     "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"left",        "Left",        0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_LEFT },        INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"center",      "Center",      0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_CENTER },      INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"topleft",     "Top-left",    0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_TOPLEFT },     INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"top",         "Top",         0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_TOP },         INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"bottomleft",  "Bottom-left", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_BOTTOMLEFT },  INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"bottom",      "Bottom",      0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_BOTTOM },      INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
+{"unspecified", "Unspecified", 0, AV_OPT_TYPE_CONST, {.i64 = AVCHROMA_LOC_UNSPECIFIED }, INT_MIN, INT_MAX, V|E|D, .unit = "chroma_sample_location_type"},
 {"log_level_offset", "set the log level offset", OFFSET(log_level_offset), AV_OPT_TYPE_INT, {.i64 = 0 }, INT_MIN, INT_MAX },
 {"slices", "set the number of slices, used in parallelized encoding", OFFSET(slices), AV_OPT_TYPE_INT, {.i64 = 0 }, 0, INT_MAX, V|E},
-{"thread_type", "select multithreading type", OFFSET(thread_type), AV_OPT_TYPE_FLAGS, {.i64 = FF_THREAD_SLICE|FF_THREAD_FRAME }, 0, INT_MAX, V|A|E|D, "thread_type"},
-{"slice", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_THREAD_SLICE }, INT_MIN, INT_MAX, V|E|D, "thread_type"},
-{"frame", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_THREAD_FRAME }, INT_MIN, INT_MAX, V|E|D, "thread_type"},
-{"audio_service_type", "audio service type", OFFSET(audio_service_type), AV_OPT_TYPE_INT, {.i64 = AV_AUDIO_SERVICE_TYPE_MAIN }, 0, AV_AUDIO_SERVICE_TYPE_NB-1, A|E, "audio_service_type"},
-{"ma", "Main Audio Service", 0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_MAIN },              INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"ef", "Effects",            0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_EFFECTS },           INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"vi", "Visually Impaired",  0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED }, INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"hi", "Hearing Impaired",   0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED },  INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"di", "Dialogue",           0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_DIALOGUE },          INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"co", "Commentary",         0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_COMMENTARY },        INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"em", "Emergency",          0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_EMERGENCY },         INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"vo", "Voice Over",         0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_VOICE_OVER },        INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"ka", "Karaoke",            0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_KARAOKE },           INT_MIN, INT_MAX, A|E, "audio_service_type"},
-{"request_sample_fmt", "sample format audio decoders should prefer", OFFSET(request_sample_fmt), AV_OPT_TYPE_SAMPLE_FMT, {.i64=AV_SAMPLE_FMT_NONE}, -1, INT_MAX, A|D, "request_sample_fmt"},
+{"thread_type", "select multithreading type", OFFSET(thread_type), AV_OPT_TYPE_FLAGS, {.i64 = FF_THREAD_SLICE|FF_THREAD_FRAME }, 0, INT_MAX, V|A|E|D, .unit = "thread_type"},
+{"slice", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_THREAD_SLICE }, INT_MIN, INT_MAX, V|E|D, .unit = "thread_type"},
+{"frame", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_THREAD_FRAME }, INT_MIN, INT_MAX, V|E|D, .unit = "thread_type"},
+{"audio_service_type", "audio service type", OFFSET(audio_service_type), AV_OPT_TYPE_INT, {.i64 = AV_AUDIO_SERVICE_TYPE_MAIN }, 0, AV_AUDIO_SERVICE_TYPE_NB-1, A|E, .unit = "audio_service_type"},
+{"ma", "Main Audio Service", 0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_MAIN },              INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"ef", "Effects",            0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_EFFECTS },           INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"vi", "Visually Impaired",  0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED }, INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"hi", "Hearing Impaired",   0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED },  INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"di", "Dialogue",           0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_DIALOGUE },          INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"co", "Commentary",         0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_COMMENTARY },        INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"em", "Emergency",          0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_EMERGENCY },         INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"vo", "Voice Over",         0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_VOICE_OVER },        INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"ka", "Karaoke",            0, AV_OPT_TYPE_CONST, {.i64 = AV_AUDIO_SERVICE_TYPE_KARAOKE },           INT_MIN, INT_MAX, A|E, .unit = "audio_service_type"},
+{"request_sample_fmt", "sample format audio decoders should prefer", OFFSET(request_sample_fmt), AV_OPT_TYPE_SAMPLE_FMT, {.i64=AV_SAMPLE_FMT_NONE}, -1, INT_MAX, A|D, .unit = "request_sample_fmt"},
 {"pkt_timebase", NULL, OFFSET(pkt_timebase), AV_OPT_TYPE_RATIONAL, {.dbl = 0 }, 0, INT_MAX, 0},
 {"sub_charenc", "set input text subtitles character encoding", OFFSET(sub_charenc), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, S|D},
-{"sub_charenc_mode", "set input text subtitles character encoding mode", OFFSET(sub_charenc_mode), AV_OPT_TYPE_FLAGS, {.i64 = FF_SUB_CHARENC_MODE_AUTOMATIC}, -1, INT_MAX, S|D, "sub_charenc_mode"},
-{"do_nothing",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_DO_NOTHING},  INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
-{"auto",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_AUTOMATIC},   INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
-{"pre_decoder", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_PRE_DECODER}, INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
-{"ignore",      NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_IGNORE},      INT_MIN, INT_MAX, S|D, "sub_charenc_mode"},
+{"sub_charenc_mode", "set input text subtitles character encoding mode", OFFSET(sub_charenc_mode), AV_OPT_TYPE_FLAGS, {.i64 = FF_SUB_CHARENC_MODE_AUTOMATIC}, -1, INT_MAX, S|D, .unit = "sub_charenc_mode"},
+{"do_nothing",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_DO_NOTHING},  INT_MIN, INT_MAX, S|D, .unit = "sub_charenc_mode"},
+{"auto",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_AUTOMATIC},   INT_MIN, INT_MAX, S|D, .unit = "sub_charenc_mode"},
+{"pre_decoder", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_PRE_DECODER}, INT_MIN, INT_MAX, S|D, .unit = "sub_charenc_mode"},
+{"ignore",      NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_SUB_CHARENC_MODE_IGNORE},      INT_MIN, INT_MAX, S|D, .unit = "sub_charenc_mode"},
 {"apply_cropping", NULL, OFFSET(apply_cropping), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, V | D },
 {"skip_alpha", "Skip processing alpha", OFFSET(skip_alpha), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, V|D },
-{"field_order", "Field order", OFFSET(field_order), AV_OPT_TYPE_INT, {.i64 = AV_FIELD_UNKNOWN }, 0, 5, V|D|E, "field_order" },
-{"progressive", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_PROGRESSIVE }, 0, 0, V|D|E, "field_order" },
-{"tt", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_TT }, 0, 0, V|D|E, "field_order" },
-{"bb", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_BB }, 0, 0, V|D|E, "field_order" },
-{"tb", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_TB }, 0, 0, V|D|E, "field_order" },
-{"bt", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_BT }, 0, 0, V|D|E, "field_order" },
+{"field_order", "Field order", OFFSET(field_order), AV_OPT_TYPE_INT, {.i64 = AV_FIELD_UNKNOWN }, 0, 5, V|D|E, .unit = "field_order" },
+{"progressive", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_PROGRESSIVE }, 0, 0, V|D|E, .unit = "field_order" },
+{"tt", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_TT }, 0, 0, V|D|E, .unit = "field_order" },
+{"bb", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_BB }, 0, 0, V|D|E, .unit = "field_order" },
+{"tb", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_TB }, 0, 0, V|D|E, .unit = "field_order" },
+{"bt", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = AV_FIELD_BT }, 0, 0, V|D|E, .unit = "field_order" },
 {"dump_separator", "set information dump field separator", OFFSET(dump_separator), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, A|V|S|D|E},
 {"codec_whitelist", "List of decoders that are allowed to be used", OFFSET(codec_whitelist), AV_OPT_TYPE_STRING, { .str = NULL },  0, 0, A|V|S|D },
 {"pixel_format", "set pixel format", OFFSET(pix_fmt), AV_OPT_TYPE_PIXEL_FMT, {.i64=AV_PIX_FMT_NONE}, -1, INT_MAX, 0 },
 {"video_size", "set video size", OFFSET(width), AV_OPT_TYPE_IMAGE_SIZE, {.str=NULL}, 0, INT_MAX, 0 },
 {"max_pixels", "Maximum number of pixels", OFFSET(max_pixels), AV_OPT_TYPE_INT64, {.i64 = INT_MAX }, 0, INT_MAX, A|V|S|D|E },
 {"max_samples", "Maximum number of samples", OFFSET(max_samples), AV_OPT_TYPE_INT64, {.i64 = INT_MAX }, 0, INT_MAX, A|D|E },
-{"hwaccel_flags", NULL, OFFSET(hwaccel_flags), AV_OPT_TYPE_FLAGS, {.i64 = AV_HWACCEL_FLAG_IGNORE_LEVEL }, 0, UINT_MAX, V|D, "hwaccel_flags"},
-{"ignore_level", "ignore level even if the codec level used is unknown or higher than the maximum supported level reported by the hardware driver", 0, AV_OPT_TYPE_CONST, { .i64 = AV_HWACCEL_FLAG_IGNORE_LEVEL }, INT_MIN, INT_MAX, V | D, "hwaccel_flags" },
-{"allow_high_depth", "allow to output YUV pixel formats with a different chroma sampling than 4:2:0 and/or other than 8 bits per component", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
-{"allow_profile_mismatch", "attempt to decode anyway if HW accelerated decoder's supported profiles do not exactly match the stream", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
-{"unsafe_output", "allow potentially unsafe hwaccel frame output that might require special care to process successfully", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_UNSAFE_OUTPUT }, INT_MIN, INT_MAX, V | D, "hwaccel_flags"},
+{"hwaccel_flags", NULL, OFFSET(hwaccel_flags), AV_OPT_TYPE_FLAGS, {.i64 = AV_HWACCEL_FLAG_IGNORE_LEVEL }, 0, UINT_MAX, V|D, .unit = "hwaccel_flags"},
+{"ignore_level", "ignore level even if the codec level used is unknown or higher than the maximum supported level reported by the hardware driver", 0, AV_OPT_TYPE_CONST, { .i64 = AV_HWACCEL_FLAG_IGNORE_LEVEL }, INT_MIN, INT_MAX, V | D, .unit = "hwaccel_flags" },
+{"allow_high_depth", "allow to output YUV pixel formats with a different chroma sampling than 4:2:0 and/or other than 8 bits per component", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH }, INT_MIN, INT_MAX, V | D, .unit = "hwaccel_flags"},
+{"allow_profile_mismatch", "attempt to decode anyway if HW accelerated decoder's supported profiles do not exactly match the stream", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH }, INT_MIN, INT_MAX, V | D, .unit = "hwaccel_flags"},
+{"unsafe_output", "allow potentially unsafe hwaccel frame output that might require special care to process successfully", 0, AV_OPT_TYPE_CONST, {.i64 = AV_HWACCEL_FLAG_UNSAFE_OUTPUT }, INT_MIN, INT_MAX, V | D, .unit = "hwaccel_flags"},
 {"extra_hw_frames", "Number of extra hardware frames to allocate for the user", OFFSET(extra_hw_frames), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, V|D },
 {"discard_damaged_percentage", "Percentage of damaged samples to discard a frame", OFFSET(discard_damaged_percentage), AV_OPT_TYPE_INT, {.i64 = 95 }, 0, 100, V|D },
+{"side_data_prefer_packet", "Comma-separated list of side data types for which user-supplied (container) data is preferred over coded bytestream",
+    OFFSET(side_data_prefer_packet), AV_OPT_TYPE_INT | AR, .min = -1, .max = INT_MAX, .flags = V|A|S|D, .unit = "side_data_pkt" },
+    {"replaygain",                  .default_val.i64 = AV_PKT_DATA_REPLAYGAIN,                  .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"displaymatrix",               .default_val.i64 = AV_PKT_DATA_DISPLAYMATRIX,               .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"spherical",                   .default_val.i64 = AV_PKT_DATA_SPHERICAL,                   .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"stereo3d",                    .default_val.i64 = AV_PKT_DATA_STEREO3D,                    .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"audio_service_type",          .default_val.i64 = AV_PKT_DATA_AUDIO_SERVICE_TYPE,          .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"mastering_display_metadata",  .default_val.i64 = AV_PKT_DATA_MASTERING_DISPLAY_METADATA,  .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"content_light_level",         .default_val.i64 = AV_PKT_DATA_CONTENT_LIGHT_LEVEL,         .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
+    {"icc_profile",                 .default_val.i64 = AV_PKT_DATA_ICC_PROFILE,                 .type = AV_OPT_TYPE_CONST, .flags = A|D, .unit = "side_data_pkt" },
 {NULL},
 };
 
diff --git a/media/ffvpx/libavcodec/avpacket.c b/media/ffvpx/libavcodec/packet.c
similarity index 99%
rename from media/ffvpx/libavcodec/avpacket.c
rename to media/ffvpx/libavcodec/packet.c
index 0f8c9b77aef05..e118bbaad1b7a 100644
--- a/media/ffvpx/libavcodec/avpacket.c
+++ b/media/ffvpx/libavcodec/packet.c
@@ -301,6 +301,7 @@ const char *av_packet_side_data_name(enum AVPacketSideDataType type)
     case AV_PKT_DATA_DOVI_CONF:                  return "DOVI configuration record";
     case AV_PKT_DATA_S12M_TIMECODE:              return "SMPTE ST 12-1:2014 timecode";
     case AV_PKT_DATA_DYNAMIC_HDR10_PLUS:         return "HDR10+ Dynamic Metadata (SMPTE 2094-40)";
+    case AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT:return "Ambient viewing environment";
     case AV_PKT_DATA_IAMF_MIX_GAIN_PARAM:        return "IAMF Mix Gain Parameter Data";
     case AV_PKT_DATA_IAMF_DEMIXING_INFO_PARAM:   return "IAMF Demixing Info Parameter Data";
     case AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM: return "IAMF Recon Gain Info Parameter Data";
diff --git a/media/ffvpx/libavcodec/packet.h b/media/ffvpx/libavcodec/packet.h
index 2c57d262c6322..a9a41576da803 100644
--- a/media/ffvpx/libavcodec/packet.h
+++ b/media/ffvpx/libavcodec/packet.h
@@ -323,6 +323,13 @@ enum AVPacketSideDataType {
      */
     AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM,
 
+    /**
+     * Ambient viewing environment metadata, as defined by H.274. This metadata
+     * should be associated with a video stream and contains data in the form
+     * of the AVAmbientViewingEnvironment struct.
+    */
+    AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT,
+
     /**
      * The number of side data types.
      * This is not part of the public API/ABI in the sense that it may
@@ -334,7 +341,9 @@ enum AVPacketSideDataType {
     AV_PKT_DATA_NB
 };
 
+#if FF_API_QUALITY_FACTOR
 #define AV_PKT_DATA_QUALITY_FACTOR AV_PKT_DATA_QUALITY_STATS //DEPRECATED
+#endif
 
 /**
  * This structure stores auxiliary information for decoding, presenting, or
@@ -589,13 +598,6 @@ typedef struct AVPacketList {
 #define AV_PKT_FLAG_DISPOSABLE 0x0010
 
 enum AVSideDataParamChangeFlags {
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * @deprecated those are not used by any decoder
-     */
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = 0x0001,
-    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
-#endif
     AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = 0x0004,
     AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = 0x0008,
 };
diff --git a/media/ffvpx/libavcodec/parser.c b/media/ffvpx/libavcodec/parser.c
index efc28b8918324..af17ee9c156d7 100644
--- a/media/ffvpx/libavcodec/parser.c
+++ b/media/ffvpx/libavcodec/parser.c
@@ -252,6 +252,7 @@ int ff_combine_frame(ParseContext *pc, int next,
                                            AV_INPUT_BUFFER_PADDING_SIZE);
         if (!new_buffer) {
             av_log(NULL, AV_LOG_ERROR, "Failed to reallocate parser buffer to %d\n", next + pc->index + AV_INPUT_BUFFER_PADDING_SIZE);
+            *buf_size =
             pc->overread_index =
             pc->index = 0;
             return AVERROR(ENOMEM);
diff --git a/media/ffvpx/libavcodec/pcm.c b/media/ffvpx/libavcodec/pcm.c
index 4abca7cc071e8..a51086a92d9ba 100644
--- a/media/ffvpx/libavcodec/pcm.c
+++ b/media/ffvpx/libavcodec/pcm.c
@@ -28,6 +28,7 @@
 #include "config_components.h"
 #include "libavutil/attributes.h"
 #include "libavutil/float_dsp.h"
+#include "libavutil/mem.h"
 #include "libavutil/reverse.h"
 #include "libavutil/thread.h"
 #include "avcodec.h"
diff --git a/media/ffvpx/libavcodec/pixblockdsp.h b/media/ffvpx/libavcodec/pixblockdsp.h
index 9b002aa3d68e1..cac5f3d4a2f9c 100644
--- a/media/ffvpx/libavcodec/pixblockdsp.h
+++ b/media/ffvpx/libavcodec/pixblockdsp.h
@@ -21,22 +21,20 @@
 
 #include <stdint.h>
 
-#include "config.h"
-
 #include "avcodec.h"
 
 typedef struct PixblockDSPContext {
-    void (*get_pixels)(int16_t *av_restrict block /* align 16 */,
+    void (*get_pixels)(int16_t *restrict block /* align 16 */,
                        const uint8_t *pixels /* align 8 */,
                        ptrdiff_t stride);
-    void (*get_pixels_unaligned)(int16_t *av_restrict block /* align 16 */,
+    void (*get_pixels_unaligned)(int16_t *restrict block /* align 16 */,
                        const uint8_t *pixels,
                        ptrdiff_t stride);
-    void (*diff_pixels)(int16_t *av_restrict block /* align 16 */,
+    void (*diff_pixels)(int16_t *restrict block /* align 16 */,
                         const uint8_t *s1 /* align 8 */,
                         const uint8_t *s2 /* align 8 */,
                         ptrdiff_t stride);
-    void (*diff_pixels_unaligned)(int16_t *av_restrict block /* align 16 */,
+    void (*diff_pixels_unaligned)(int16_t *restrict block /* align 16 */,
                         const uint8_t *s1,
                         const uint8_t *s2,
                         ptrdiff_t stride);
diff --git a/media/ffvpx/libavcodec/profiles.c b/media/ffvpx/libavcodec/profiles.c
index 5bb8f150e65f9..052b77926ebaa 100644
--- a/media/ffvpx/libavcodec/profiles.c
+++ b/media/ffvpx/libavcodec/profiles.c
@@ -18,7 +18,8 @@
 
 #include "config.h"
 
-#include "avcodec.h"
+#include "codec.h"
+#include "defs.h"
 #include "profiles.h"
 
 #if !CONFIG_SMALL
diff --git a/media/ffvpx/libavcodec/profiles.h b/media/ffvpx/libavcodec/profiles.h
index 270430a48b4c5..842201718b68b 100644
--- a/media/ffvpx/libavcodec/profiles.h
+++ b/media/ffvpx/libavcodec/profiles.h
@@ -19,11 +19,12 @@
 #ifndef AVCODEC_PROFILES_H
 #define AVCODEC_PROFILES_H
 
-#include "avcodec.h"
+#include "codec.h"
+#include "defs.h"
 #include "libavutil/opt.h"
 
 #define FF_AVCTX_PROFILE_OPTION(name, description, type, value) \
-    {name, description, 0, AV_OPT_TYPE_CONST, {.i64 = value }, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_## type ##_PARAM, "avctx.profile"},
+    {name, description, 0, AV_OPT_TYPE_CONST, {.i64 = value }, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_## type ##_PARAM, .unit = "avctx.profile"},
 
 #define FF_AAC_PROFILE_OPTS \
     FF_AVCTX_PROFILE_OPTION("aac_main",      NULL, AUDIO, AV_PROFILE_AAC_MAIN)\
diff --git a/media/ffvpx/libavcodec/pthread_frame.c b/media/ffvpx/libavcodec/pthread_frame.c
index 71e99a5728824..fd356bd1908a3 100644
--- a/media/ffvpx/libavcodec/pthread_frame.c
+++ b/media/ffvpx/libavcodec/pthread_frame.c
@@ -311,12 +311,6 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         dst->sample_rate    = src->sample_rate;
         dst->sample_fmt     = src->sample_fmt;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        dst->channels       = src->channels;
-        dst->channel_layout = src->channel_layout;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         err = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
         if (err < 0)
             return err;
@@ -418,16 +412,6 @@ static int update_context_from_user(AVCodecContext *dst, const AVCodecContext *s
     dst->skip_frame       = src->skip_frame;
 
     dst->frame_num        = src->frame_num;
-#if FF_API_AVCTX_FRAME_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->frame_number     = src->frame_number;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->reordered_opaque = src->reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     av_packet_unref(dst->internal->last_pkt_props);
     err = av_packet_copy_props(dst->internal->last_pkt_props, src->internal->last_pkt_props);
@@ -761,7 +745,7 @@ void ff_frame_thread_free(AVCodecContext *avctx, int thread_count)
     ff_pthread_free(fctx, thread_ctx_offsets);
 
     /* if we have stashed hwaccel state, move it to the user-facing context,
-     * so it will be freed in avcodec_close() */
+     * so it will be freed in ff_codec_close() */
     av_assert0(!avctx->hwaccel);
     FFSWAP(const AVHWAccel*, avctx->hwaccel,                     fctx->stash_hwaccel);
     FFSWAP(void*,            avctx->hwaccel_context,             fctx->stash_hwaccel_context);
diff --git a/media/ffvpx/libavcodec/ratecontrol.h b/media/ffvpx/libavcodec/ratecontrol.h
index 4de80fad9048c..1f44b44341e08 100644
--- a/media/ffvpx/libavcodec/ratecontrol.h
+++ b/media/ffvpx/libavcodec/ratecontrol.h
@@ -28,9 +28,7 @@
  * ratecontrol header.
  */
 
-#include <stdio.h>
 #include <stdint.h>
-#include "libavutil/eval.h"
 
 typedef struct Predictor{
     double coeff;
@@ -80,7 +78,7 @@ typedef struct RateControlContext{
     int frame_count[5];
     int last_non_b_pict_type;
 
-    AVExpr * rc_eq_eval;
+    struct AVExpr *rc_eq_eval;
 }RateControlContext;
 
 struct MpegEncContext;
diff --git a/media/ffvpx/libavcodec/refstruct.c b/media/ffvpx/libavcodec/refstruct.c
index 7597f6d0ee764..f89af156c2fe1 100644
--- a/media/ffvpx/libavcodec/refstruct.c
+++ b/media/ffvpx/libavcodec/refstruct.c
@@ -20,13 +20,13 @@
 #include <stdint.h>
 #include <string.h>
 
-#include "internal.h"
 #include "refstruct.h"
 
 #include "libavutil/avassert.h"
 #include "libavutil/error.h"
 #include "libavutil/macros.h"
 #include "libavutil/mem.h"
+#include "libavutil/mem_internal.h"
 #include "libavutil/thread.h"
 
 #ifndef REFSTRUCT_CHECKED
@@ -45,10 +45,10 @@
 #define REFSTRUCT_COOKIE AV_NE((uint64_t)MKBETAG('R', 'e', 'f', 'S') << 32 | MKBETAG('t', 'r', 'u', 'c'), \
                                MKTAG('R', 'e', 'f', 'S') | (uint64_t)MKTAG('t', 'r', 'u', 'c') << 32)
 
-#if __STDC_VERSION__ >= 201112L
-#define REFCOUNT_OFFSET FFALIGN(sizeof(RefCount), FFMAX3(STRIDE_ALIGN, 16, _Alignof(max_align_t)))
+#if __STDC_VERSION__ >= 201112L && !defined(_MSC_VER)
+#define REFCOUNT_OFFSET FFALIGN(sizeof(RefCount), FFMAX(ALIGN_64, _Alignof(max_align_t)))
 #else
-#define REFCOUNT_OFFSET FFALIGN(sizeof(RefCount), FFMAX(STRIDE_ALIGN, 16))
+#define REFCOUNT_OFFSET FFALIGN(sizeof(RefCount), ALIGN_64)
 #endif
 
 typedef struct RefCount {
diff --git a/media/ffvpx/libavcodec/utils.c b/media/ffvpx/libavcodec/utils.c
index 39b83c7791659..337c00e789ac5 100644
--- a/media/ffvpx/libavcodec/utils.c
+++ b/media/ffvpx/libavcodec/utils.c
@@ -362,17 +362,6 @@ void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
     *width              = FFALIGN(*width, align);
 }
-#if FF_API_AVCODEC_CHROMA_POS
-int avcodec_enum_to_chroma_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
-{
-    return av_chroma_location_enum_to_pos(xpos, ypos, pos);
-}
-
-enum AVChromaLocation avcodec_chroma_pos_to_enum(int xpos, int ypos)
-{
-    return av_chroma_location_pos_to_enum(xpos, ypos);
-}
-#endif
 
 int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels,
                              enum AVSampleFormat sample_fmt, const uint8_t *buf,
@@ -795,12 +784,7 @@ int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
 {
    int channels = avctx->ch_layout.nb_channels;
    int duration;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!channels)
-        channels = avctx->channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
+
     duration = get_audio_frame_duration(avctx->codec_id, avctx->sample_rate,
                                     channels, avctx->block_align,
                                     avctx->codec_tag, avctx->bits_per_coded_sample,
@@ -813,12 +797,7 @@ int av_get_audio_frame_duration2(AVCodecParameters *par, int frame_bytes)
 {
    int channels = par->ch_layout.nb_channels;
    int duration;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!channels)
-        channels = par->channels;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
+
     duration = get_audio_frame_duration(par->codec_id, par->sample_rate,
                                     channels, par->block_align,
                                     par->codec_tag, par->bits_per_coded_sample,
@@ -960,9 +939,9 @@ void ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, in
 
 #endif
 
-const uint8_t *avpriv_find_start_code(const uint8_t *av_restrict p,
+const uint8_t *avpriv_find_start_code(const uint8_t *restrict p,
                                       const uint8_t *end,
-                                      uint32_t *av_restrict state)
+                                      uint32_t *restrict state)
 {
     int i;
 
diff --git a/media/ffvpx/libavcodec/vaapi.h b/media/ffvpx/libavcodec/vaapi.h
deleted file mode 100644
index 2cf7da5889ab4..0000000000000
--- a/media/ffvpx/libavcodec/vaapi.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Video Acceleration API (shared data between FFmpeg and the video player)
- * HW decode acceleration for MPEG-2, MPEG-4, H.264 and VC-1
- *
- * Copyright (C) 2008-2009 Splitted-Desktop Systems
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_VAAPI_H
-#define AVCODEC_VAAPI_H
-
-/**
- * @file
- * @ingroup lavc_codec_hwaccel_vaapi
- * Public libavcodec VA API header.
- */
-
-#include <stdint.h>
-#include "libavutil/attributes.h"
-#include "version.h"
-
-#if FF_API_STRUCT_VAAPI_CONTEXT
-
-/**
- * @defgroup lavc_codec_hwaccel_vaapi VA API Decoding
- * @ingroup lavc_codec_hwaccel
- * @{
- */
-
-/**
- * This structure is used to share data between the FFmpeg library and
- * the client video application.
- * This shall be zero-allocated and available as
- * AVCodecContext.hwaccel_context. All user members can be set once
- * during initialization or through each AVCodecContext.get_buffer()
- * function call. In any case, they must be valid prior to calling
- * decoding functions.
- *
- * Deprecated: use AVCodecContext.hw_frames_ctx instead.
- */
-struct attribute_deprecated vaapi_context {
-    /**
-     * Window system dependent data
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    void *display;
-
-    /**
-     * Configuration ID
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    uint32_t config_id;
-
-    /**
-     * Context ID (video decode pipeline)
-     *
-     * - encoding: unused
-     * - decoding: Set by user
-     */
-    uint32_t context_id;
-};
-
-/* @} */
-
-#endif /* FF_API_STRUCT_VAAPI_CONTEXT */
-
-#endif /* AVCODEC_VAAPI_H */
diff --git a/media/ffvpx/libavcodec/vaapi_decode.c b/media/ffvpx/libavcodec/vaapi_decode.c
index ceac769c5247c..5665639dd75c4 100644
--- a/media/ffvpx/libavcodec/vaapi_decode.c
+++ b/media/ffvpx/libavcodec/vaapi_decode.c
@@ -20,6 +20,7 @@
 
 #include "libavutil/avassert.h"
 #include "libavutil/common.h"
+#include "libavutil/mem.h"
 #include "libavutil/pixdesc.h"
 
 #include "avcodec.h"
@@ -72,17 +73,14 @@ int ff_vaapi_decode_make_slice_buffer(AVCodecContext *avctx,
 
     av_assert0(pic->nb_slices <= pic->slices_allocated);
     if (pic->nb_slices == pic->slices_allocated) {
-        if (pic->slices_allocated > 0)
-            pic->slices_allocated *= 2;
-        else
-            pic->slices_allocated = 64;
-
         pic->slice_buffers =
             av_realloc_array(pic->slice_buffers,
-                             pic->slices_allocated,
+                             pic->slices_allocated ? pic->slices_allocated * 2 : 64,
                              2 * sizeof(*pic->slice_buffers));
         if (!pic->slice_buffers)
             return AVERROR(ENOMEM);
+
+        pic->slices_allocated = pic->slices_allocated ? pic->slices_allocated * 2 : 64;
     }
     av_assert0(pic->nb_slices + 1 <= pic->slices_allocated);
 
diff --git a/media/ffvpx/libavcodec/version.c b/media/ffvpx/libavcodec/version.c
index d7966b20153df..27f94323b86d6 100644
--- a/media/ffvpx/libavcodec/version.c
+++ b/media/ffvpx/libavcodec/version.c
@@ -18,9 +18,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <assert.h>
+
 #include "config.h"
 
-#include "libavutil/avassert.h"
 #include "avcodec.h"
 #include "codec_id.h"
 #include "version.h"
@@ -30,10 +31,15 @@ const char av_codec_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
 
 unsigned avcodec_version(void)
 {
-    av_assert0(AV_CODEC_ID_PCM_S8_PLANAR==65563);
-    av_assert0(AV_CODEC_ID_ADPCM_G722==69660);
-    av_assert0(AV_CODEC_ID_SRT==94216);
-    av_assert0(LIBAVCODEC_VERSION_MICRO >= 100);
+    static_assert(AV_CODEC_ID_LEAD         ==   269 &&
+                  AV_CODEC_ID_PCM_SGA      == 65572 &&
+                  AV_CODEC_ID_ADPCM_XMD    == 69683 &&
+                  AV_CODEC_ID_CBD2_DPCM    == 81928 &&
+                  AV_CODEC_ID_QOA          == 86121 &&
+                  AV_CODEC_ID_ARIB_CAPTION == 94233 &&
+                  AV_CODEC_ID_SMPTE_2038   == 98315,
+                  "Don't insert new codec ids in the middle of a list");
+    static_assert(LIBAVCODEC_VERSION_MICRO >= 100, "micro version starts at 100");
 
     return LIBAVCODEC_VERSION_INT;
 }
diff --git a/media/ffvpx/libavcodec/version.h b/media/ffvpx/libavcodec/version.h
index 0fae3d06d385d..84a1c02ce4aad 100644
--- a/media/ffvpx/libavcodec/version.h
+++ b/media/ffvpx/libavcodec/version.h
@@ -29,8 +29,8 @@
 
 #include "version_major.h"
 
-#define LIBAVCODEC_VERSION_MINOR  38
-#define LIBAVCODEC_VERSION_MICRO 100
+#define LIBAVCODEC_VERSION_MINOR   5
+#define LIBAVCODEC_VERSION_MICRO 101
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
                                                LIBAVCODEC_VERSION_MINOR, \
diff --git a/media/ffvpx/libavcodec/version_major.h b/media/ffvpx/libavcodec/version_major.h
index b9164fe5c628d..63df40e9ddded 100644
--- a/media/ffvpx/libavcodec/version_major.h
+++ b/media/ffvpx/libavcodec/version_major.h
@@ -25,7 +25,7 @@
  * Libavcodec version macros.
  */
 
-#define LIBAVCODEC_VERSION_MAJOR  60
+#define LIBAVCODEC_VERSION_MAJOR  61
 
 /**
  * FF_API_* defines may be placed below to indicate public API that will be
@@ -37,23 +37,16 @@
  * at once through the bump. This improves the git bisect-ability of the change.
  */
 
-#define FF_API_INIT_PACKET         (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_IDCT_NONE           (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_SVTAV1_OPTS         (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_AYUV_CODECID        (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_VT_OUTPUT_CALLBACK  (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_AVCODEC_CHROMA_POS  (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_VT_HWACCEL_CONTEXT  (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_AVCTX_FRAME_NUMBER  (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_SLICE_OFFSET        (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_SUBFRAMES           (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_TICKS_PER_FRAME     (LIBAVCODEC_VERSION_MAJOR < 61)
-#define FF_API_DROPCHANGED         (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_INIT_PACKET         (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_SUBFRAMES           (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_TICKS_PER_FRAME     (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_DROPCHANGED         (LIBAVCODEC_VERSION_MAJOR < 62)
 
 #define FF_API_AVFFT               (LIBAVCODEC_VERSION_MAJOR < 62)
 #define FF_API_FF_PROFILE_LEVEL    (LIBAVCODEC_VERSION_MAJOR < 62)
-
-// reminder to remove CrystalHD decoders on next major bump
-#define FF_CODEC_CRYSTAL_HD        (LIBAVCODEC_VERSION_MAJOR < 61)
+#define FF_API_AVCODEC_CLOSE       (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_BUFFER_MIN_SIZE     (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_VDPAU_ALLOC_GET_SET (LIBAVCODEC_VERSION_MAJOR < 62)
+#define FF_API_QUALITY_FACTOR      (LIBAVCODEC_VERSION_MAJOR < 62)
 
 #endif /* AVCODEC_VERSION_MAJOR_H */
diff --git a/media/ffvpx/libavcodec/vlc.c b/media/ffvpx/libavcodec/vlc.c
index 78510e30d6299..ee09d96fd61a0 100644
--- a/media/ffvpx/libavcodec/vlc.c
+++ b/media/ffvpx/libavcodec/vlc.c
@@ -440,8 +440,8 @@ static void add_level(VLC_MULTI_ELEM *table, const int is16bit,
             code = curcode + (buf[t].code >> curlen);
             newlimit = curlimit - l;
             l  += curlen;
-            if (is16bit) AV_WN16(info.val+2*curlevel, sym);
-            else info.val[curlevel] = sym&0xFF;
+            if (is16bit) info.val16[curlevel] = sym;
+            else info.val8[curlevel] = sym&0xFF;
 
             if (curlevel) { // let's not add single entries
                 uint32_t val = code >> (32 - numbits);
@@ -468,7 +468,7 @@ static int vlc_multi_gen(VLC_MULTI_ELEM *table, const VLC *single,
 {
     int minbits, maxbits, max;
     unsigned count[VLC_MULTI_MAX_SYMBOLS-1] = { 0, };
-    VLC_MULTI_ELEM info = { { 0, }, 0, 0, };
+    VLC_MULTI_ELEM info = { 0 };
     int count0 = 0;
 
     for (int j = 0; j < 1<<numbits; j++) {
@@ -499,7 +499,10 @@ static int vlc_multi_gen(VLC_MULTI_ELEM *table, const VLC *single,
     for (int j = 0; j < 1<<numbits; j++) {
         table[j].len = single->table[j].len;
         table[j].num = single->table[j].len > 0 ? 1 : 0;
-        AV_WN16(table[j].val, single->table[j].sym);
+        if (is16bit)
+            table[j].val16[0] = single->table[j].sym;
+        else
+            table[j].val8[0]  = single->table[j].sym;
     }
 
     add_level(table, is16bit, nb_codes, numbits, buf,
diff --git a/media/ffvpx/libavcodec/vlc.h b/media/ffvpx/libavcodec/vlc.h
index 679666801a5c6..bf7b0e65b4863 100644
--- a/media/ffvpx/libavcodec/vlc.h
+++ b/media/ffvpx/libavcodec/vlc.h
@@ -40,7 +40,10 @@ typedef struct VLC {
 } VLC;
 
 typedef struct VLC_MULTI_ELEM {
-    uint8_t val[VLC_MULTI_MAX_SYMBOLS];
+    union {
+        uint8_t   val8[VLC_MULTI_MAX_SYMBOLS];
+        uint16_t val16[VLC_MULTI_MAX_SYMBOLS / 2];
+    };
     int8_t len; // -31,32
     uint8_t num;
 } VLC_MULTI_ELEM;
@@ -185,47 +188,6 @@ void ff_vlc_free(VLC *vlc);
 #define VLC_INIT_OUTPUT_LE      8
 #define VLC_INIT_LE             (VLC_INIT_INPUT_LE | VLC_INIT_OUTPUT_LE)
 
-#define VLC_INIT_CUSTOM_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g,      \
-                                      h, i, j, flags, static_size)         \
-    do {                                                                   \
-        static VLCElem table[static_size];                                 \
-        (vlc)->table           = table;                                    \
-        (vlc)->table_allocated = static_size;                              \
-        ff_vlc_init_sparse(vlc, bits, a, b, c, d, e, f, g, h, i, j,        \
-                           flags | VLC_INIT_USE_STATIC);                   \
-    } while (0)
-
-#define VLC_INIT_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g, h, i, j, static_size) \
-    VLC_INIT_CUSTOM_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g,          \
-                                  h, i, j, 0, static_size)
-
-#define VLC_INIT_LE_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g, h, i, j, static_size) \
-    VLC_INIT_CUSTOM_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g,          \
-                                  h, i, j, VLC_INIT_LE, static_size)
-
-#define VLC_INIT_CUSTOM_STATIC(vlc, bits, a, b, c, d, e, f, g, flags, static_size) \
-    VLC_INIT_CUSTOM_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g,          \
-                                  NULL, 0, 0, flags, static_size)
-
-#define VLC_INIT_STATIC(vlc, bits, a, b, c, d, e, f, g, static_size)       \
-    VLC_INIT_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g, NULL, 0, 0, static_size)
-
-#define VLC_INIT_LE_STATIC(vlc, bits, a, b, c, d, e, f, g, static_size) \
-    VLC_INIT_LE_SPARSE_STATIC(vlc, bits, a, b, c, d, e, f, g, NULL, 0, 0, static_size)
-
-#define VLC_INIT_STATIC_FROM_LENGTHS(vlc, bits, nb_codes, lens, len_wrap,  \
-                                     symbols, symbols_wrap, symbols_size,  \
-                                     offset, flags, static_size)           \
-    do {                                                                   \
-        static VLCElem table[static_size];                                 \
-        (vlc)->table           = table;                                    \
-        (vlc)->table_allocated = static_size;                              \
-        ff_vlc_init_from_lengths(vlc, bits, nb_codes, lens, len_wrap,      \
-                                 symbols, symbols_wrap, symbols_size,      \
-                                 offset, flags | VLC_INIT_USE_STATIC,      \
-                                 NULL);                                    \
-    } while (0)
-
 /**
  * For static VLCs, the number of bits can often be hardcoded
  * at each get_vlc2() callsite. Then using a full VLC would be uneconomical,
diff --git a/media/ffvpx/libavcodec/vorbis_data.c b/media/ffvpx/libavcodec/vorbis_data.c
index 1ebe146d8f356..d7edc695c153b 100644
--- a/media/ffvpx/libavcodec/vorbis_data.c
+++ b/media/ffvpx/libavcodec/vorbis_data.c
@@ -34,20 +34,6 @@ const uint8_t ff_vorbis_channel_layout_offsets[8][8] = {
     { 0, 2, 1, 7, 5, 6, 3, 4 },
 };
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-const uint64_t ff_vorbis_channel_layouts[9] = {
-    AV_CH_LAYOUT_MONO,
-    AV_CH_LAYOUT_STEREO,
-    AV_CH_LAYOUT_SURROUND,
-    AV_CH_LAYOUT_QUAD,
-    AV_CH_LAYOUT_5POINT0_BACK,
-    AV_CH_LAYOUT_5POINT1_BACK,
-    AV_CH_LAYOUT_5POINT1|AV_CH_BACK_CENTER,
-    AV_CH_LAYOUT_7POINT1,
-    0
-};
-#endif
-
 const AVChannelLayout ff_vorbis_ch_layouts[9] = {
     AV_CHANNEL_LAYOUT_MONO,
     AV_CHANNEL_LAYOUT_STEREO,
diff --git a/media/ffvpx/libavcodec/vorbis_data.h b/media/ffvpx/libavcodec/vorbis_data.h
index 0fe19e509f3c7..327e5ab2efdf7 100644
--- a/media/ffvpx/libavcodec/vorbis_data.h
+++ b/media/ffvpx/libavcodec/vorbis_data.h
@@ -21,14 +21,14 @@
 
 #include <stdint.h>
 
+#include "libavutil/attributes_internal.h"
 #include "libavutil/channel_layout.h"
 
+FF_VISIBILITY_PUSH_HIDDEN
 extern const float ff_vorbis_floor1_inverse_db_table[256];
 extern const float * const ff_vorbis_vwin[8];
 extern const uint8_t ff_vorbis_channel_layout_offsets[8][8];
-#if FF_API_OLD_CHANNEL_LAYOUT
-extern const uint64_t ff_vorbis_channel_layouts[9];
-#endif
 extern const AVChannelLayout ff_vorbis_ch_layouts[9];
+FF_VISIBILITY_POP_HIDDEN
 
 #endif /* AVCODEC_VORBIS_DATA_H */
diff --git a/media/ffvpx/libavcodec/vorbis_parser.c b/media/ffvpx/libavcodec/vorbis_parser.c
index d2c9e647ce564..c6969f139fcfe 100644
--- a/media/ffvpx/libavcodec/vorbis_parser.c
+++ b/media/ffvpx/libavcodec/vorbis_parser.c
@@ -28,9 +28,9 @@
 #include "config_components.h"
 
 #include "libavutil/log.h"
+#include "libavutil/mem.h"
 
 #include "get_bits.h"
-#include "parser.h"
 #include "xiph.h"
 #include "vorbis_parser_internal.h"
 
diff --git a/media/ffvpx/libavcodec/vp8.c b/media/ffvpx/libavcodec/vp8.c
index 83c60adeb0a27..539b5c5395aa2 100644
--- a/media/ffvpx/libavcodec/vp8.c
+++ b/media/ffvpx/libavcodec/vp8.c
@@ -26,6 +26,7 @@
 
 #include "config_components.h"
 
+#include "libavutil/mem.h"
 #include "libavutil/mem_internal.h"
 
 #include "avcodec.h"
@@ -2665,7 +2666,11 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
     if (ret < 0)
         goto err;
 
-    if (s->actually_webp) {
+    if (!is_vp7 && s->actually_webp) {
+        // VP8 in WebP is supposed to be intra-only. Enforce this here
+        // to ensure that output is reproducible with frame-threading.
+        if (!s->keyframe)
+            return AVERROR_INVALIDDATA;
         // avctx->pix_fmt already set in caller.
     } else if (!is_vp7 && s->pix_fmt == AV_PIX_FMT_NONE) {
         s->pix_fmt = get_pixel_format(s);
@@ -2750,7 +2755,7 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
 
     s->next_framep[VP8_FRAME_CURRENT] = curframe;
 
-    if (ffcodec(avctx->codec)->update_thread_context)
+    if (!is_vp7 && !s->actually_webp)
         ff_thread_finish_setup(avctx);
 
     if (avctx->hwaccel) {
@@ -2883,7 +2888,6 @@ int vp78_decode_init(AVCodecContext *avctx, int is_vp7)
     int ret;
 
     s->avctx = avctx;
-    s->vp7   = avctx->codec->id == AV_CODEC_ID_VP7;
     s->pix_fmt = AV_PIX_FMT_NONE;
     avctx->pix_fmt = AV_PIX_FMT_YUV420P;
 
diff --git a/media/ffvpx/libavcodec/vp8.h b/media/ffvpx/libavcodec/vp8.h
index eb9fa2f166be1..798f67b3de2ca 100644
--- a/media/ffvpx/libavcodec/vp8.h
+++ b/media/ffvpx/libavcodec/vp8.h
@@ -331,8 +331,6 @@ typedef struct VP8Context {
     int (*decode_mb_row_no_filter)(AVCodecContext *avctx, void *tdata, int jobnr, int threadnr);
     void (*filter_mb_row)(AVCodecContext *avctx, void *tdata, int jobnr, int threadnr);
 
-    int vp7;
-
     /**
      * Interframe DC prediction (VP7)
      * [0] VP8_FRAME_PREVIOUS
diff --git a/media/ffvpx/libavcodec/vp8dsp.c b/media/ffvpx/libavcodec/vp8dsp.c
index 7a85e9f4cae6c..72d4ea37933ff 100644
--- a/media/ffvpx/libavcodec/vp8dsp.c
+++ b/media/ffvpx/libavcodec/vp8dsp.c
@@ -742,6 +742,8 @@ av_cold void ff_vp8dsp_init(VP8DSPContext *dsp)
     ff_vp8dsp_init_aarch64(dsp);
 #elif ARCH_ARM
     ff_vp8dsp_init_arm(dsp);
+#elif ARCH_RISCV
+    ff_vp8dsp_init_riscv(dsp);
 #elif ARCH_X86
     ff_vp8dsp_init_x86(dsp);
 #elif ARCH_MIPS
diff --git a/media/ffvpx/libavcodec/vp8dsp.h b/media/ffvpx/libavcodec/vp8dsp.h
index 16b5e9c35b84a..30dc2c6cc1c68 100644
--- a/media/ffvpx/libavcodec/vp8dsp.h
+++ b/media/ffvpx/libavcodec/vp8dsp.h
@@ -92,6 +92,7 @@ void ff_vp78dsp_init_x86(VP8DSPContext *c);
 void ff_vp8dsp_init(VP8DSPContext *c);
 void ff_vp8dsp_init_aarch64(VP8DSPContext *c);
 void ff_vp8dsp_init_arm(VP8DSPContext *c);
+void ff_vp8dsp_init_riscv(VP8DSPContext *c);
 void ff_vp8dsp_init_x86(VP8DSPContext *c);
 void ff_vp8dsp_init_mips(VP8DSPContext *c);
 void ff_vp8dsp_init_loongarch(VP8DSPContext *c);
diff --git a/media/ffvpx/libavcodec/vp9.c b/media/ffvpx/libavcodec/vp9.c
index 855936cdc1c7e..6bcda8bfff44c 100644
--- a/media/ffvpx/libavcodec/vp9.c
+++ b/media/ffvpx/libavcodec/vp9.c
@@ -42,6 +42,7 @@
 #include "vp9dec.h"
 #include "vpx_rac.h"
 #include "libavutil/avassert.h"
+#include "libavutil/mem.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/video_enc_params.h"
 
diff --git a/media/ffvpx/libavcodec/x86/h264_intrapred.asm b/media/ffvpx/libavcodec/x86/h264_intrapred.asm
index 8a38ba2bb5d20..a8a630dbe6c8a 100644
--- a/media/ffvpx/libavcodec/x86/h264_intrapred.asm
+++ b/media/ffvpx/libavcodec/x86/h264_intrapred.asm
@@ -86,8 +86,6 @@ cglobal pred16x16_horizontal_8, 2,3
     punpcklbw m1, m1
     SPLATW    m0, m0, 3
     SPLATW    m1, m1, 3
-    mova [r0+r1*0+8], m0
-    mova [r0+r1*1+8], m1
 %endif
 
     mova [r0+r1*0], m0
@@ -98,7 +96,7 @@ cglobal pred16x16_horizontal_8, 2,3
     RET
 %endmacro
 
-INIT_MMX mmxext
+INIT_XMM sse2
 PRED16x16_H
 INIT_XMM ssse3
 PRED16x16_H
@@ -568,17 +566,17 @@ H264_PRED8x8_PLANE
 ; void ff_pred8x8_vertical_8(uint8_t *src, ptrdiff_t stride)
 ;-----------------------------------------------------------------------------
 
-INIT_MMX mmx
+INIT_XMM sse2
 cglobal pred8x8_vertical_8, 2,2
     sub    r0, r1
-    movq  mm0, [r0]
+    movq   m0, [r0]
 %rep 3
-    movq [r0+r1*1], mm0
-    movq [r0+r1*2], mm0
+    movq [r0+r1*1], m0
+    movq [r0+r1*2], m0
     lea    r0, [r0+r1*2]
 %endrep
-    movq [r0+r1*1], mm0
-    movq [r0+r1*2], mm0
+    movq [r0+r1*1], m0
+    movq [r0+r1*2], m0
     RET
 
 ;-----------------------------------------------------------------------------
@@ -1313,10 +1311,7 @@ PRED8x8L_DOWN_RIGHT
 ;-----------------------------------------------------------------------------
 
 %macro PRED8x8L_VERTICAL_RIGHT 0
-cglobal pred8x8l_vertical_right_8, 4,5,7
-    ; manually spill XMM registers for Win64 because
-    ; the code here is initialized with INIT_MMX
-    WIN64_SPILL_XMM 7
+cglobal pred8x8l_vertical_right_8, 4,5,6
     sub          r0, r3
     lea          r4, [r0+r3*2]
     movq        mm0, [r0+r3*1-8]
@@ -1386,7 +1381,6 @@ cglobal pred8x8l_vertical_right_8, 4,5,7
     movq2dq     xmm4, mm6
     pslldq      xmm4, 8
     por         xmm0, xmm4
-    movdqa      xmm6, [pw_ff00]
     movdqa      xmm1, xmm0
     lea           r2, [r1+r3*2]
     movdqa      xmm2, xmm0
@@ -1396,15 +1390,16 @@ cglobal pred8x8l_vertical_right_8, 4,5,7
     pavgb       xmm2, xmm0
 INIT_XMM cpuname
     PRED4x4_LOWPASS xmm4, xmm3, xmm1, xmm0, xmm5
-    pandn       xmm6, xmm4
+    movdqa      xmm0, [pw_ff00]
+    pandn       xmm0, xmm4
     movdqa      xmm5, xmm4
     psrlw       xmm4, 8
-    packuswb    xmm6, xmm4
-    movhlps     xmm4, xmm6
+    packuswb    xmm0, xmm4
+    movhlps     xmm4, xmm0
     movhps [r0+r3*2], xmm5
     movhps [r0+r3*1], xmm2
     psrldq      xmm5, 4
-    movss       xmm5, xmm6
+    movss       xmm5, xmm0
     psrldq      xmm2, 4
     movss       xmm2, xmm4
     lea           r0, [r2+r3*2]
diff --git a/media/ffvpx/libavcodec/x86/h264_intrapred_init.c b/media/ffvpx/libavcodec/x86/h264_intrapred_init.c
index ee46927a24c9f..aa9bc721f048f 100644
--- a/media/ffvpx/libavcodec/x86/h264_intrapred_init.c
+++ b/media/ffvpx/libavcodec/x86/h264_intrapred_init.c
@@ -100,7 +100,7 @@ PRED16x16(horizontal, 10, sse2)
 
 /* 8-bit versions */
 PRED16x16(vertical, 8, sse)
-PRED16x16(horizontal, 8, mmxext)
+PRED16x16(horizontal, 8, sse2)
 PRED16x16(horizontal, 8, ssse3)
 PRED16x16(dc, 8, sse2)
 PRED16x16(dc, 8, ssse3)
@@ -116,7 +116,7 @@ PRED16x16(tm_vp8, 8, avx2)
 PRED8x8(top_dc, 8, mmxext)
 PRED8x8(dc_rv40, 8, mmxext)
 PRED8x8(dc, 8, mmxext)
-PRED8x8(vertical, 8, mmx)
+PRED8x8(vertical, 8, sse2)
 PRED8x8(horizontal, 8, mmxext)
 PRED8x8(horizontal, 8, ssse3)
 PRED8x8(plane, 8, sse2)
@@ -163,14 +163,7 @@ av_cold void ff_h264_pred_init_x86(H264PredContext *h, int codec_id,
     int cpu_flags = av_get_cpu_flags();
 
     if (bit_depth == 8) {
-        if (EXTERNAL_MMX(cpu_flags)) {
-            if (chroma_format_idc <= 1) {
-                h->pred8x8  [VERT_PRED8x8     ] = ff_pred8x8_vertical_8_mmx;
-            }
-        }
-
         if (EXTERNAL_MMXEXT(cpu_flags)) {
-            h->pred16x16[HOR_PRED8x8            ] = ff_pred16x16_horizontal_8_mmxext;
             if (chroma_format_idc <= 1)
                 h->pred8x8[HOR_PRED8x8          ] = ff_pred8x8_horizontal_8_mmxext;
             h->pred8x8l [TOP_DC_PRED            ] = ff_pred8x8l_top_dc_8_mmxext;
@@ -210,12 +203,15 @@ av_cold void ff_h264_pred_init_x86(H264PredContext *h, int codec_id,
         }
 
         if (EXTERNAL_SSE2(cpu_flags)) {
+            h->pred16x16[HOR_PRED8x8          ] = ff_pred16x16_horizontal_8_sse2;
             h->pred16x16[DC_PRED8x8           ] = ff_pred16x16_dc_8_sse2;
             h->pred8x8l [DIAG_DOWN_LEFT_PRED  ] = ff_pred8x8l_down_left_8_sse2;
             h->pred8x8l [DIAG_DOWN_RIGHT_PRED ] = ff_pred8x8l_down_right_8_sse2;
             h->pred8x8l [VERT_RIGHT_PRED      ] = ff_pred8x8l_vertical_right_8_sse2;
             h->pred8x8l [VERT_LEFT_PRED       ] = ff_pred8x8l_vertical_left_8_sse2;
             h->pred8x8l [HOR_DOWN_PRED        ] = ff_pred8x8l_horizontal_down_8_sse2;
+            if (chroma_format_idc <= 1)
+                h->pred8x8  [VERT_PRED8x8     ] = ff_pred8x8_vertical_8_sse2;
             if (codec_id == AV_CODEC_ID_VP7 || codec_id == AV_CODEC_ID_VP8) {
                 h->pred16x16[PLANE_PRED8x8    ] = ff_pred16x16_tm_vp8_8_sse2;
                 h->pred8x8  [PLANE_PRED8x8    ] = ff_pred8x8_tm_vp8_8_sse2;
diff --git a/media/ffvpx/libavcodec/x86/moz.build b/media/ffvpx/libavcodec/x86/moz.build
index bd721affadb93..c358b5fdb5b6e 100644
--- a/media/ffvpx/libavcodec/x86/moz.build
+++ b/media/ffvpx/libavcodec/x86/moz.build
@@ -37,6 +37,8 @@ SOURCES += [
     'vp9mc_16bpp.asm',
 ]
 
+LOCAL_INCLUDES += [ "../" ]
+
 if CONFIG['TARGET_CPU'] == 'x86':
     SOURCES += [ 'simple_idct.asm' ]
 
diff --git a/media/ffvpx/libavcodec/x86/simple_idct.asm b/media/ffvpx/libavcodec/x86/simple_idct.asm
index 982b2f0bbba1a..c79519372a76d 100644
--- a/media/ffvpx/libavcodec/x86/simple_idct.asm
+++ b/media/ffvpx/libavcodec/x86/simple_idct.asm
@@ -783,68 +783,33 @@ SECTION .text
 %macro PUT_PIXELS_CLAMPED_HALF 1
     mova     m0, [blockq+mmsize*0+%1]
     mova     m1, [blockq+mmsize*2+%1]
-%if mmsize == 8
-    mova     m2, [blockq+mmsize*4+%1]
-    mova     m3, [blockq+mmsize*6+%1]
-%endif
     packuswb m0, [blockq+mmsize*1+%1]
     packuswb m1, [blockq+mmsize*3+%1]
-%if mmsize == 8
-    packuswb m2, [blockq+mmsize*5+%1]
-    packuswb m3, [blockq+mmsize*7+%1]
-    movq           [pixelsq], m0
-    movq    [lsizeq+pixelsq], m1
-    movq  [2*lsizeq+pixelsq], m2
-    movq   [lsize3q+pixelsq], m3
-%else
     movq           [pixelsq], m0
     movhps  [lsizeq+pixelsq], m0
     movq  [2*lsizeq+pixelsq], m1
     movhps [lsize3q+pixelsq], m1
-%endif
 %endmacro
 
 %macro ADD_PIXELS_CLAMPED 1
     mova       m0, [blockq+mmsize*0+%1]
     mova       m1, [blockq+mmsize*1+%1]
-%if mmsize == 8
-    mova       m5, [blockq+mmsize*2+%1]
-    mova       m6, [blockq+mmsize*3+%1]
-%endif
     movq       m2, [pixelsq]
     movq       m3, [pixelsq+lsizeq]
-%if mmsize == 8
-    mova       m7, m2
-    punpcklbw  m2, m4
-    punpckhbw  m7, m4
-    paddsw     m0, m2
-    paddsw     m1, m7
-    mova       m7, m3
-    punpcklbw  m3, m4
-    punpckhbw  m7, m4
-    paddsw     m5, m3
-    paddsw     m6, m7
-%else
     punpcklbw  m2, m4
     punpcklbw  m3, m4
     paddsw     m0, m2
     paddsw     m1, m3
-%endif
     packuswb   m0, m1
-%if mmsize == 8
-    packuswb   m5, m6
-    movq       [pixelsq], m0
-    movq       [pixelsq+lsizeq], m5
-%else
     movq       [pixelsq], m0
     movhps     [pixelsq+lsizeq], m0
-%endif
 %endmacro
 
 INIT_MMX mmx
 
 cglobal simple_idct, 1, 2, 8, 128, block, t0
     IDCT
+    emms
 RET
 
 INIT_XMM sse2
diff --git a/media/ffvpx/libavcodec/x86/vp56_arith.h b/media/ffvpx/libavcodec/x86/vp56_arith.h
deleted file mode 100644
index 9f7639980c3a6..0000000000000
--- a/media/ffvpx/libavcodec/x86/vp56_arith.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/**
- * VP5 and VP6 compatible video decoder (arith decoder)
- *
- * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
- * Copyright (C) 2010  Eli Friedman
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVCODEC_X86_VP56_ARITH_H
-#define AVCODEC_X86_VP56_ARITH_H
-
-#if HAVE_INLINE_ASM && HAVE_FAST_CMOV && HAVE_6REGS
-#include "libavutil/attributes.h"
-
-#define vp56_rac_get_prob vp56_rac_get_prob
-static av_always_inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
-{
-    unsigned int code_word = vp56_rac_renorm(c);
-    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
-    unsigned int low_shift = low << 16;
-    int bit = 0;
-    c->code_word = code_word;
-
-    __asm__(
-        "subl  %4, %1      \n\t"
-        "subl  %3, %2      \n\t"
-        "setae %b0         \n\t"
-        "cmovb %4, %1      \n\t"
-        "cmovb %5, %2      \n\t"
-        : "+q"(bit), "+&r"(c->high), "+&r"(c->code_word)
-        : "r"(low_shift), "r"(low), "r"(code_word)
-    );
-
-    return bit;
-}
-#endif
-
-#endif /* AVCODEC_X86_VP56_ARITH_H */
diff --git a/media/ffvpx/libavcodec/x86/vp8dsp.asm b/media/ffvpx/libavcodec/x86/vp8dsp.asm
index 6ac5a7721bfc2..231c21ea0dc0c 100644
--- a/media/ffvpx/libavcodec/x86/vp8dsp.asm
+++ b/media/ffvpx/libavcodec/x86/vp8dsp.asm
@@ -114,7 +114,7 @@ bilinear_filter_vb_m: times 8 db 7, 1
                       times 8 db 2, 6
                       times 8 db 1, 7
 
-%ifdef PIC
+%if PIC
 %define fourtap_filter_hw  picregq
 %define sixtap_filter_hw   picregq
 %define fourtap_filter_hb  picregq
@@ -166,7 +166,7 @@ cglobal put_vp8_epel%1_h6, 6, 6 + npicregs, 8, dst, dststride, src, srcstride, h
     lea      mxd, [mxq*3]
     mova      m3, [filter_h6_shuf2]
     mova      m4, [filter_h6_shuf3]
-%ifdef PIC
+%if PIC
     lea  picregq, [sixtap_filter_hb_m]
 %endif
     mova      m5, [sixtap_filter_hb+mxq*8-48] ; set up 6tap filter in bytes
@@ -207,7 +207,7 @@ cglobal put_vp8_epel%1_h4, 6, 6 + npicregs, 7, dst, dststride, src, srcstride, h
     mova      m2, [pw_256]
     mova      m3, [filter_h2_shuf]
     mova      m4, [filter_h4_shuf]
-%ifdef PIC
+%if PIC
     lea  picregq, [fourtap_filter_hb_m]
 %endif
     mova      m5, [fourtap_filter_hb+mxq-16] ; set up 4tap filter in bytes
@@ -234,7 +234,7 @@ cglobal put_vp8_epel%1_h4, 6, 6 + npicregs, 7, dst, dststride, src, srcstride, h
 
 cglobal put_vp8_epel%1_v4, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [fourtap_filter_hb_m]
 %endif
     mova      m5, [fourtap_filter_hb+myq-16]
@@ -272,7 +272,7 @@ cglobal put_vp8_epel%1_v4, 7, 7, 8, dst, dststride, src, srcstride, height, picr
 
 cglobal put_vp8_epel%1_v6, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     lea      myd, [myq*3]
-%ifdef PIC
+%if PIC
     lea  picregq, [sixtap_filter_hb_m]
 %endif
     lea      myq, [sixtap_filter_hb+myq*8]
@@ -326,7 +326,7 @@ FILTER_SSSE3 8
 INIT_MMX mmxext
 cglobal put_vp8_epel4_h4, 6, 6 + npicregs, 0, dst, dststride, src, srcstride, height, mx, picreg
     shl       mxd, 4
-%ifdef PIC
+%if PIC
     lea   picregq, [fourtap_filter_hw_m]
 %endif
     movq      mm4, [fourtap_filter_hw+mxq-16] ; set up 4tap filter in words
@@ -374,7 +374,7 @@ cglobal put_vp8_epel4_h4, 6, 6 + npicregs, 0, dst, dststride, src, srcstride, he
 INIT_MMX mmxext
 cglobal put_vp8_epel4_h6, 6, 6 + npicregs, 0, dst, dststride, src, srcstride, height, mx, picreg
     lea       mxd, [mxq*3]
-%ifdef PIC
+%if PIC
     lea   picregq, [sixtap_filter_hw_m]
 %endif
     movq      mm4, [sixtap_filter_hw+mxq*8-48] ; set up 4tap filter in words
@@ -431,7 +431,7 @@ cglobal put_vp8_epel4_h6, 6, 6 + npicregs, 0, dst, dststride, src, srcstride, he
 INIT_XMM sse2
 cglobal put_vp8_epel8_h4, 6, 6 + npicregs, 10, dst, dststride, src, srcstride, height, mx, picreg
     shl      mxd, 5
-%ifdef PIC
+%if PIC
     lea  picregq, [fourtap_filter_v_m]
 %endif
     lea      mxq, [fourtap_filter_v+mxq-32]
@@ -480,7 +480,7 @@ INIT_XMM sse2
 cglobal put_vp8_epel8_h6, 6, 6 + npicregs, 14, dst, dststride, src, srcstride, height, mx, picreg
     lea      mxd, [mxq*3]
     shl      mxd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [sixtap_filter_v_m]
 %endif
     lea      mxq, [sixtap_filter_v+mxq-96]
@@ -543,7 +543,7 @@ cglobal put_vp8_epel8_h6, 6, 6 + npicregs, 14, dst, dststride, src, srcstride, h
 ; 4x4 block, V-only 4-tap filter
 cglobal put_vp8_epel%1_v4, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 5
-%ifdef PIC
+%if PIC
     lea  picregq, [fourtap_filter_v_m]
 %endif
     lea      myq, [fourtap_filter_v+myq-32]
@@ -597,7 +597,7 @@ cglobal put_vp8_epel%1_v4, 7, 7, 8, dst, dststride, src, srcstride, height, picr
 cglobal put_vp8_epel%1_v6, 7, 7, 8, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 4
     lea      myq, [myq*3]
-%ifdef PIC
+%if PIC
     lea  picregq, [sixtap_filter_v_m]
 %endif
     lea      myq, [sixtap_filter_v+myq-96]
@@ -667,7 +667,7 @@ FILTER_V 8
 %if cpuflag(ssse3)
 cglobal put_vp8_bilinear%1_v, 7, 7, 5, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [bilinear_filter_vb_m]
 %endif
     pxor      m4, m4
@@ -697,7 +697,7 @@ cglobal put_vp8_bilinear%1_v, 7, 7, 5, dst, dststride, src, srcstride, height, p
 %else ; cpuflag(ssse3)
 cglobal put_vp8_bilinear%1_v, 7, 7, 7, dst, dststride, src, srcstride, height, picreg, my
     shl      myd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [bilinear_filter_vw_m]
 %endif
     pxor      m6, m6
@@ -743,7 +743,7 @@ cglobal put_vp8_bilinear%1_v, 7, 7, 7, dst, dststride, src, srcstride, height, p
 %if cpuflag(ssse3)
 cglobal put_vp8_bilinear%1_h, 6, 6 + npicregs, 5, dst, dststride, src, srcstride, height, mx, picreg
     shl      mxd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [bilinear_filter_vb_m]
 %endif
     pxor      m4, m4
@@ -773,7 +773,7 @@ cglobal put_vp8_bilinear%1_h, 6, 6 + npicregs, 5, dst, dststride, src, srcstride
 %else ; cpuflag(ssse3)
 cglobal put_vp8_bilinear%1_h, 6, 6 + npicregs, 7, dst, dststride, src, srcstride, height, mx, picreg
     shl      mxd, 4
-%ifdef PIC
+%if PIC
     lea  picregq, [bilinear_filter_vw_m]
 %endif
     pxor      m6, m6
diff --git a/media/ffvpx/libavcodec/x86/vp9itxfm.asm b/media/ffvpx/libavcodec/x86/vp9itxfm.asm
index 2c63fe514a3f4..2f290f2f8831e 100644
--- a/media/ffvpx/libavcodec/x86/vp9itxfm.asm
+++ b/media/ffvpx/libavcodec/x86/vp9itxfm.asm
@@ -330,7 +330,9 @@ IDCT_4x4_FN ssse3
 INIT_MMX %5
 cglobal vp9_%1_%3_4x4_add, 3, 3, 0, dst, stride, block, eob
 %if WIN64 && notcpuflag(ssse3)
+INIT_XMM cpuname
     WIN64_SPILL_XMM 8
+INIT_MMX cpuname
 %endif
     movdqa            xmm5, [pd_8192]
     mova                m0, [blockq+ 0]
diff --git a/media/ffvpx/libavcodec/x86/vp9itxfm_16bpp.asm b/media/ffvpx/libavcodec/x86/vp9itxfm_16bpp.asm
index 902685edf6b9a..ebe6222285bc1 100644
--- a/media/ffvpx/libavcodec/x86/vp9itxfm_16bpp.asm
+++ b/media/ffvpx/libavcodec/x86/vp9itxfm_16bpp.asm
@@ -303,7 +303,9 @@ IDCT4_10_FN
 %macro IADST4_FN 4
 cglobal vp9_%1_%3_4x4_add_10, 3, 3, 0, dst, stride, block, eob
 %if WIN64 && notcpuflag(ssse3)
+INIT_XMM cpuname
     WIN64_SPILL_XMM 8
+INIT_MMX cpuname
 %endif
     movdqa            xmm5, [pd_8192]
     mova                m0, [blockq+0*16+0]
@@ -672,7 +674,7 @@ cglobal vp9_idct_idct_8x8_add_10, 4, 6 + ARCH_X86_64, 14, \
     mov            dstbakq, dstq
     movsxd            cntq, cntd
 %endif
-%ifdef PIC
+%if PIC
     lea               ptrq, [default_8x8]
     movzx             cntd, byte [ptrq+cntq-1]
 %else
@@ -921,7 +923,7 @@ cglobal vp9_%1_%3_8x8_add_10, 4, 6 + ARCH_X86_64, 16, \
     mov            dstbakq, dstq
     movsxd            cntq, cntd
 %endif
-%ifdef PIC
+%if PIC
     lea               ptrq, [%5_8x8]
     movzx             cntd, byte [ptrq+cntq-1]
 %else
@@ -1128,7 +1130,7 @@ cglobal vp9_idct_idct_16x16_add_10, 4, 6 + ARCH_X86_64, 16, \
     mov            dstbakq, dstq
     movsxd            cntq, cntd
 %endif
-%ifdef PIC
+%if PIC
     lea               ptrq, [default_16x16]
     movzx             cntd, byte [ptrq+cntq-1]
 %else
@@ -1445,7 +1447,7 @@ cglobal vp9_%1_%4_16x16_add_10, 4, 6 + ARCH_X86_64, 16, \
     mov            dstbakq, dstq
     movsxd            cntq, cntd
 %endif
-%ifdef PIC
+%if PIC
     lea               ptrq, [%7_16x16]
     movzx             cntd, byte [ptrq+cntq-1]
 %else
@@ -1958,7 +1960,7 @@ cglobal vp9_idct_idct_32x32_add_10, 4, 6 + ARCH_X86_64, 16, \
     mov            dstbakq, dstq
     movsxd            cntq, cntd
 %endif
-%ifdef PIC
+%if PIC
     lea               ptrq, [default_32x32]
     movzx             cntd, byte [ptrq+cntq-1]
 %else
diff --git a/media/ffvpx/libavutil/aarch64/cpu.c b/media/ffvpx/libavutil/aarch64/cpu.c
index f27fef399252b..7a05391343006 100644
--- a/media/ffvpx/libavutil/aarch64/cpu.c
+++ b/media/ffvpx/libavutil/aarch64/cpu.c
@@ -24,34 +24,20 @@
 #include <stdint.h>
 #include <sys/auxv.h>
 
-#define get_cpu_feature_reg(reg, val) \
-        __asm__("mrs %0, " #reg : "=r" (val))
+#define HWCAP_AARCH64_ASIMDDP (1 << 20)
+#define HWCAP2_AARCH64_I8MM   (1 << 13)
 
 static int detect_flags(void)
 {
     int flags = 0;
 
-#if defined(HWCAP_CPUID) && HAVE_INLINE_ASM
     unsigned long hwcap = getauxval(AT_HWCAP);
-    // We can check for DOTPROD and I8MM using HWCAP_ASIMDDP and
-    // HWCAP2_I8MM too, avoiding to read the CPUID registers (which triggers
-    // a trap, handled by the kernel). However the HWCAP_* defines for these
-    // extensions are added much later than HWCAP_CPUID, so the userland
-    // headers might lack support for them even if the binary later is run
-    // on hardware that does support it (and where the kernel might support
-    // HWCAP_CPUID).
-    // See https://www.kernel.org/doc/html/latest/arm64/cpu-feature-registers.html
-    if (hwcap & HWCAP_CPUID) {
-        uint64_t tmp;
-
-        get_cpu_feature_reg(ID_AA64ISAR0_EL1, tmp);
-        if (((tmp >> 44) & 0xf) == 0x1)
-            flags |= AV_CPU_FLAG_DOTPROD;
-        get_cpu_feature_reg(ID_AA64ISAR1_EL1, tmp);
-        if (((tmp >> 52) & 0xf) == 0x1)
-            flags |= AV_CPU_FLAG_I8MM;
-    }
-#endif
+    unsigned long hwcap2 = getauxval(AT_HWCAP2);
+
+    if (hwcap & HWCAP_AARCH64_ASIMDDP)
+        flags |= AV_CPU_FLAG_DOTPROD;
+    if (hwcap2 & HWCAP2_AARCH64_I8MM)
+        flags |= AV_CPU_FLAG_I8MM;
 
     return flags;
 }
diff --git a/media/ffvpx/libavutil/arm/float_dsp_init_vfp.c b/media/ffvpx/libavutil/arm/float_dsp_init_vfp.c
index 05873e7e37546..6d6237aae830f 100644
--- a/media/ffvpx/libavutil/arm/float_dsp_init_vfp.c
+++ b/media/ffvpx/libavutil/arm/float_dsp_init_vfp.c
@@ -32,7 +32,7 @@ void ff_vector_fmul_window_vfp(float *dst, const float *src0,
 void ff_vector_fmul_reverse_vfp(float *dst, const float *src0,
                                 const float *src1, int len);
 
-void ff_butterflies_float_vfp(float *av_restrict v1, float *av_restrict v2, int len);
+void ff_butterflies_float_vfp(float *restrict v1, float *restrict v2, int len);
 
 av_cold void ff_float_dsp_init_vfp(AVFloatDSPContext *fdsp, int cpu_flags)
 {
diff --git a/media/ffvpx/libavutil/avstring.c b/media/ffvpx/libavutil/avstring.c
index 8751ce557609f..2071dd36a5999 100644
--- a/media/ffvpx/libavutil/avstring.c
+++ b/media/ffvpx/libavutil/avstring.c
@@ -345,7 +345,7 @@ int av_escape(char **dst, const char *src, const char *special_chars,
 int av_match_name(const char *name, const char *names)
 {
     const char *p;
-    int len, namelen;
+    size_t len, namelen;
 
     if (!name || !names)
         return 0;
diff --git a/media/ffvpx/libavutil/avutil.h b/media/ffvpx/libavutil/avutil.h
index a362c8baa831a..d2900dcb485f5 100644
--- a/media/ffvpx/libavutil/avutil.h
+++ b/media/ffvpx/libavutil/avutil.h
@@ -335,19 +335,6 @@ unsigned av_int_list_length_for_size(unsigned elsize,
 #define av_int_list_length(list, term) \
     av_int_list_length_for_size(sizeof(*(list)), list, term)
 
-#if FF_API_AV_FOPEN_UTF8
-/**
- * Open a file using a UTF-8 filename.
- * The API of this function matches POSIX fopen(), errors are returned through
- * errno.
- * @deprecated Avoid using it, as on Windows, the FILE* allocated by this
- *             function may be allocated with a different CRT than the caller
- *             who uses the FILE*. No replacement provided in public API.
- */
-attribute_deprecated
-FILE *av_fopen_utf8(const char *path, const char *mode);
-#endif
-
 /**
  * Return the fractional representation of the internal time base.
  */
diff --git a/media/ffvpx/libavutil/avutil.symbols b/media/ffvpx/libavutil/avutil.symbols
index 5ee7afb855044..75f5625d982b2 100644
--- a/media/ffvpx/libavutil/avutil.symbols
+++ b/media/ffvpx/libavutil/avutil.symbols
@@ -8,7 +8,6 @@ av_base64_decode
 av_base64_encode
 #endif
 av_bprint_append_data
-av_bprint_channel_layout
 av_bprint_chars
 av_bprint_clear
 av_bprint_escape
@@ -39,7 +38,6 @@ av_channel_layout_compare
 av_channel_layout_copy
 av_channel_layout_default
 av_channel_layout_describe
-av_channel_layout_extract_channel
 av_channel_layout_from_mask
 av_channel_layout_from_mask
 av_channel_layout_uninit
@@ -52,9 +50,7 @@ av_color_space_name
 av_color_transfer_name
 av_compare_mod
 av_compare_ts
-#ifndef MOZ_FFVPX_AUDIOONLY
 av_content_light_metadata_create_side_data
-#endif
 av_cpu_count
 av_crc
 av_crc_get_table
@@ -88,26 +84,13 @@ av_expr_parse_and_eval
 av_fast_malloc
 av_fast_mallocz
 av_fast_realloc
-av_fifo_alloc
 av_fifo_alloc2
-av_fifo_alloc_array
 av_fifo_can_read
 av_fifo_can_write
-av_fifo_drain
 av_fifo_drain2
-av_fifo_free
-av_fifo_freep
 av_fifo_freep2
-av_fifo_generic_peek
-av_fifo_generic_read
-av_fifo_generic_write
-av_fifo_grow
 av_fifo_peek
-av_fifo_realloc2
 av_fifo_read
-av_fifo_reset
-av_fifo_size
-av_fifo_space
 av_fifo_write
 av_find_best_pix_fmt_of_2
 av_find_info_tag
@@ -122,6 +105,8 @@ av_frame_apply_cropping
 av_frame_clone
 av_frame_copy
 av_frame_copy_props
+av_frame_side_data_free
+av_frame_side_data_get_c
 av_frame_free
 av_frame_get_buffer
 av_frame_get_plane_buffer
@@ -142,14 +127,7 @@ av_gcd
 av_get_alt_sample_fmt
 av_get_bits_per_pixel
 av_get_bytes_per_sample
-av_get_channel_description
-av_get_channel_layout
-av_get_channel_layout_channel_index
-av_get_channel_layout_nb_channels
-av_get_channel_layout_string
-av_get_channel_name
 av_get_cpu_flags
-av_get_default_channel_layout
 av_get_known_color_name
 av_get_media_type_string
 av_get_packed_sample_fmt
@@ -162,7 +140,6 @@ av_get_pix_fmt_string
 av_get_planar_sample_fmt
 av_get_sample_fmt
 av_get_sample_fmt_string
-av_get_standard_channel_layout
 av_get_time_base_q
 av_get_token
 av_gettime
@@ -201,9 +178,7 @@ av_log_set_flags
 av_log_set_level
 av_mallocz
 av_malloc
-#ifndef MOZ_FFVPX_AUDIOONLY
 av_mastering_display_metadata_create_side_data
-#endif
 av_match_list
 av_match_name
 av_max_alloc
@@ -225,7 +200,6 @@ av_opt_flag_is_set
 av_opt_free
 av_opt_freep_ranges
 av_opt_get
-av_opt_get_channel_layout
 av_opt_get_dict_val
 av_opt_get_double
 av_opt_get_image_size
@@ -244,7 +218,6 @@ av_opt_query_ranges_default
 av_opt_serialize
 av_opt_set
 av_opt_set_bin
-av_opt_set_channel_layout
 av_opt_set_defaults
 av_opt_set_defaults2
 av_opt_set_dict
diff --git a/media/ffvpx/libavutil/bprint.h b/media/ffvpx/libavutil/bprint.h
index 85597454788d6..4ac857056187a 100644
--- a/media/ffvpx/libavutil/bprint.h
+++ b/media/ffvpx/libavutil/bprint.h
@@ -172,9 +172,9 @@ void av_bprint_chars(AVBPrint *buf, char c, unsigned n);
 /**
  * Append data to a print buffer.
  *
- * param buf  bprint buffer to use
- * param data pointer to data
- * param size size of data
+ * @param buf  bprint buffer to use
+ * @param data pointer to data
+ * @param size size of data
  */
 void av_bprint_append_data(AVBPrint *buf, const char *data, unsigned size);
 
@@ -182,9 +182,9 @@ struct tm;
 /**
  * Append a formatted date and time to a print buffer.
  *
- * param buf  bprint buffer to use
- * param fmt  date and time format string, see strftime()
- * param tm   broken-down time structure to translate
+ * @param buf  bprint buffer to use
+ * @param fmt  date and time format string, see strftime()
+ * @param tm   broken-down time structure to translate
  *
  * @note due to poor design of the standard strftime function, it may
  * produce poor results if the format string expands to a very long text and
diff --git a/media/ffvpx/libavutil/channel_layout.c b/media/ffvpx/libavutil/channel_layout.c
index b59d798f299b6..fd6718e0e7749 100644
--- a/media/ffvpx/libavutil/channel_layout.c
+++ b/media/ffvpx/libavutil/channel_layout.c
@@ -33,6 +33,7 @@
 #include "common.h"
 #include "error.h"
 #include "macros.h"
+#include "mem.h"
 #include "opt.h"
 
 #define CHAN_IS_AMBI(x) ((x) >= AV_CHAN_AMBISONIC_BASE &&\
@@ -76,14 +77,6 @@ static const struct channel_name channel_names[] = {
     [AV_CHAN_BOTTOM_FRONT_RIGHT   ] = { "BFR",       "bottom front right"    },
 };
 
-static const char *get_channel_name(enum AVChannel channel_id)
-{
-    if ((unsigned) channel_id >= FF_ARRAY_ELEMS(channel_names) ||
-        !channel_names[channel_id].name)
-        return NULL;
-    return channel_names[channel_id].name;
-}
-
 void av_channel_name_bprint(AVBPrint *bp, enum AVChannel channel_id)
 {
     if (channel_id >= AV_CHAN_AMBISONIC_BASE &&
@@ -94,6 +87,10 @@ void av_channel_name_bprint(AVBPrint *bp, enum AVChannel channel_id)
         av_bprintf(bp, "%s", channel_names[channel_id].name);
     else if (channel_id == AV_CHAN_NONE)
         av_bprintf(bp, "NONE");
+    else if (channel_id == AV_CHAN_UNKNOWN)
+        av_bprintf(bp, "UNK");
+    else if (channel_id == AV_CHAN_UNUSED)
+        av_bprintf(bp, "UNSD");
     else
         av_bprintf(bp, "USR%d", channel_id);
 }
@@ -123,6 +120,10 @@ void av_channel_description_bprint(AVBPrint *bp, enum AVChannel channel_id)
         av_bprintf(bp, "%s", channel_names[channel_id].description);
     else if (channel_id == AV_CHAN_NONE)
         av_bprintf(bp, "none");
+    else if (channel_id == AV_CHAN_UNKNOWN)
+        av_bprintf(bp, "unknown");
+    else if (channel_id == AV_CHAN_UNUSED)
+        av_bprintf(bp, "unused");
     else
         av_bprintf(bp, "user %d", channel_id);
 }
@@ -159,6 +160,11 @@ enum AVChannel av_channel_from_string(const char *str)
         if (channel_names[i].name && !strcmp(str, channel_names[i].name))
             return i;
     }
+    if (!strcmp(str, "UNK"))
+        return AV_CHAN_UNKNOWN;
+    if (!strcmp(str, "UNSD"))
+        return AV_CHAN_UNUSED;
+
     if (!strncmp(str, "USR", 3)) {
         const char *p = str + 3;
         id = strtol(p, &endptr, 0);
@@ -214,199 +220,82 @@ static const struct channel_layout_name channel_layout_map[] = {
     { "22.2",           AV_CHANNEL_LAYOUT_22POINT2,           },
 };
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-static uint64_t get_channel_layout_single(const char *name, int name_len)
+int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels)
 {
-    int i;
-    char *end;
-    int64_t layout;
-
-    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) {
-        if (strlen(channel_layout_map[i].name) == name_len &&
-            !memcmp(channel_layout_map[i].name, name, name_len))
-            return channel_layout_map[i].layout.u.mask;
-    }
-    for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++)
-        if (channel_names[i].name &&
-            strlen(channel_names[i].name) == name_len &&
-            !memcmp(channel_names[i].name, name, name_len))
-            return (int64_t)1 << i;
-
-    errno = 0;
-    i = strtol(name, &end, 10);
-
-    if (!errno && (end + 1 - name == name_len && *end  == 'c'))
-        return av_get_default_channel_layout(i);
-
-    errno = 0;
-    layout = strtoll(name, &end, 0);
-    if (!errno && end - name == name_len)
-        return FFMAX(layout, 0);
-    return 0;
-}
-
-uint64_t av_get_channel_layout(const char *name)
-{
-    const char *n, *e;
-    const char *name_end = name + strlen(name);
-    int64_t layout = 0, layout_single;
-
-    for (n = name; n < name_end; n = e + 1) {
-        for (e = n; e < name_end && *e != '+' && *e != '|'; e++);
-        layout_single = get_channel_layout_single(n, e - n);
-        if (!layout_single)
-            return 0;
-        layout |= layout_single;
-    }
-    return layout;
-}
-
-int av_get_extended_channel_layout(const char *name, uint64_t* channel_layout, int* nb_channels)
-{
-    int nb = 0;
-    char *end;
-    uint64_t layout = av_get_channel_layout(name);
-
-    if (layout) {
-        *channel_layout = layout;
-        *nb_channels = av_get_channel_layout_nb_channels(layout);
-        return 0;
-    }
-
-    nb = strtol(name, &end, 10);
-    if (!errno && *end  == 'C' && *(end + 1) == '\0' && nb > 0 && nb < 64) {
-        *channel_layout = 0;
-        *nb_channels = nb;
-        return 0;
-    }
-
-    return AVERROR(EINVAL);
-}
-
-void av_bprint_channel_layout(struct AVBPrint *bp,
-                              int nb_channels, uint64_t channel_layout)
-{
-    int i;
+    AVChannelCustom *map;
 
     if (nb_channels <= 0)
-        nb_channels = av_get_channel_layout_nb_channels(channel_layout);
-
-    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
-        if (nb_channels    == channel_layout_map[i].layout.nb_channels &&
-            channel_layout == channel_layout_map[i].layout.u.mask) {
-            av_bprintf(bp, "%s", channel_layout_map[i].name);
-            return;
-        }
-
-    av_bprintf(bp, "%d channels", nb_channels);
-    if (channel_layout) {
-        int i, ch;
-        av_bprintf(bp, " (");
-        for (i = 0, ch = 0; i < 64; i++) {
-            if ((channel_layout & (UINT64_C(1) << i))) {
-                const char *name = get_channel_name(i);
-                if (name) {
-                    if (ch > 0)
-                        av_bprintf(bp, "+");
-                    av_bprintf(bp, "%s", name);
-                }
-                ch++;
-            }
-        }
-        av_bprintf(bp, ")");
-    }
-}
-
-void av_get_channel_layout_string(char *buf, int buf_size,
-                                  int nb_channels, uint64_t channel_layout)
-{
-    AVBPrint bp;
+        return AVERROR(EINVAL);
 
-    av_bprint_init_for_buffer(&bp, buf, buf_size);
-    av_bprint_channel_layout(&bp, nb_channels, channel_layout);
-}
+    map = av_calloc(nb_channels, sizeof(*channel_layout->u.map));
+    if (!map)
+        return AVERROR(ENOMEM);
+    for (int i = 0; i < nb_channels; i++)
+        map[i].id = AV_CHAN_UNKNOWN;
 
-int av_get_channel_layout_nb_channels(uint64_t channel_layout)
-{
-    return av_popcount64(channel_layout);
-}
+    channel_layout->order       = AV_CHANNEL_ORDER_CUSTOM;
+    channel_layout->nb_channels = nb_channels;
+    channel_layout->u.map       = map;
 
-int64_t av_get_default_channel_layout(int nb_channels) {
-    int i;
-    for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++)
-        if (nb_channels == channel_layout_map[i].layout.nb_channels)
-            return channel_layout_map[i].layout.u.mask;
     return 0;
 }
 
-int av_get_channel_layout_channel_index(uint64_t channel_layout,
-                                        uint64_t channel)
+int av_channel_layout_from_mask(AVChannelLayout *channel_layout,
+                                uint64_t mask)
 {
-    if (!(channel_layout & channel) ||
-        av_get_channel_layout_nb_channels(channel) != 1)
+    if (!mask)
         return AVERROR(EINVAL);
-    channel_layout &= channel - 1;
-    return av_get_channel_layout_nb_channels(channel_layout);
-}
 
-const char *av_get_channel_name(uint64_t channel)
-{
-    int i;
-    if (av_get_channel_layout_nb_channels(channel) != 1)
-        return NULL;
-    for (i = 0; i < 64; i++)
-        if ((1ULL<<i) & channel)
-            return get_channel_name(i);
-    return NULL;
-}
+    channel_layout->order       = AV_CHANNEL_ORDER_NATIVE;
+    channel_layout->nb_channels = av_popcount64(mask);
+    channel_layout->u.mask      = mask;
 
-const char *av_get_channel_description(uint64_t channel)
-{
-    int i;
-    if (av_get_channel_layout_nb_channels(channel) != 1)
-        return NULL;
-    for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++)
-        if ((1ULL<<i) & channel)
-            return channel_names[i].description;
-    return NULL;
+    return 0;
 }
 
-uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index)
+static int parse_channel_list(AVChannelLayout *ch_layout, const char *str)
 {
-    int i;
+    int ret;
+    int nb_channels = 0;
+    AVChannelCustom *map = NULL;
+    AVChannelCustom custom = {0};
 
-    if (av_get_channel_layout_nb_channels(channel_layout) <= index)
-        return 0;
+    while (*str) {
+        char *channel, *chname;
+        int ret = av_opt_get_key_value(&str, "@", "+", AV_OPT_FLAG_IMPLICIT_KEY, &channel, &chname);
+        if (ret < 0) {
+            av_freep(&map);
+            return ret;
+        }
+        if (*str)
+            str++; // skip separator
+        if (!channel) {
+            channel = chname;
+            chname = NULL;
+        }
+        av_strlcpy(custom.name, chname ? chname : "", sizeof(custom.name));
+        custom.id = av_channel_from_string(channel);
+        av_free(channel);
+        av_free(chname);
+        if (custom.id == AV_CHAN_NONE) {
+            av_freep(&map);
+            return AVERROR(EINVAL);
+        }
 
-    for (i = 0; i < 64; i++) {
-        if ((1ULL << i) & channel_layout && !index--)
-            return 1ULL << i;
+        av_dynarray2_add((void **)&map, &nb_channels, sizeof(custom), (void *)&custom);
+        if (!map)
+            return AVERROR(ENOMEM);
     }
-    return 0;
-}
-
-int av_get_standard_channel_layout(unsigned index, uint64_t *layout,
-                                   const char **name)
-{
-    if (index >= FF_ARRAY_ELEMS(channel_layout_map))
-        return AVERROR_EOF;
-    if (layout) *layout = channel_layout_map[index].layout.u.mask;
-    if (name)   *name   = channel_layout_map[index].name;
-    return 0;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
-int av_channel_layout_from_mask(AVChannelLayout *channel_layout,
-                                uint64_t mask)
-{
-    if (!mask)
+    if (!nb_channels)
         return AVERROR(EINVAL);
 
-    channel_layout->order       = AV_CHANNEL_ORDER_NATIVE;
-    channel_layout->nb_channels = av_popcount64(mask);
-    channel_layout->u.mask      = mask;
+    ch_layout->order = AV_CHANNEL_ORDER_CUSTOM;
+    ch_layout->u.map = map;
+    ch_layout->nb_channels = nb_channels;
+
+    ret = av_channel_layout_retype(ch_layout, 0, AV_CHANNEL_LAYOUT_RETYPE_FLAG_CANONICAL);
+    av_assert0(ret == 0);
 
     return 0;
 }
@@ -414,10 +303,8 @@ int av_channel_layout_from_mask(AVChannelLayout *channel_layout,
 int av_channel_layout_from_string(AVChannelLayout *channel_layout,
                                   const char *str)
 {
-    int i;
-    int channels = 0, nb_channels = 0, native = 1;
-    enum AVChannel highest_channel = AV_CHAN_NONE;
-    const char *dup;
+    int i, matches, ret;
+    int channels = 0, nb_channels = 0;
     char *chlist, *end;
     uint64_t mask = 0;
 
@@ -429,6 +316,10 @@ int av_channel_layout_from_string(AVChannelLayout *channel_layout,
         }
     }
 
+    /* This function is a channel layout initializer, so we have to
+     * zero-initialize before we start setting fields individually. */
+    memset(channel_layout, 0, sizeof(*channel_layout));
+
     /* ambisonic */
     if (!strncmp(str, "ambisonic ", 10)) {
         const char *p = str + 10;
@@ -470,6 +361,7 @@ int av_channel_layout_from_string(AVChannelLayout *channel_layout,
                 for (i = 0; i < extra.nb_channels; i++) {
                     enum AVChannel ch = av_channel_layout_channel_from_index(&extra, i);
                     if (CHAN_IS_AMBI(ch)) {
+                        av_channel_layout_uninit(channel_layout);
                         av_channel_layout_uninit(&extra);
                         return AVERROR(EINVAL);
                     }
@@ -493,121 +385,20 @@ int av_channel_layout_from_string(AVChannelLayout *channel_layout,
         return AVERROR(ENOMEM);
 
     /* channel names */
-    av_sscanf(str, "%d channels (%[^)]", &nb_channels, chlist);
-    end = strchr(str, ')');
-
-    dup = chlist;
-    while (*dup) {
-        char *channel, *chname;
-        int ret = av_opt_get_key_value(&dup, "@", "+", AV_OPT_FLAG_IMPLICIT_KEY, &channel, &chname);
-        if (ret < 0) {
-            av_free(chlist);
-            return ret;
-        }
-        if (*dup)
-            dup++; // skip separator
-        if (channel && !*channel)
-            av_freep(&channel);
-        for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) {
-            if (channel_names[i].name && !strcmp(channel ? channel : chname, channel_names[i].name)) {
-                if (channel || i < highest_channel || mask & (1ULL << i))
-                    native = 0; // Not a native layout, use a custom one
-                highest_channel = i;
-                mask |= 1ULL << i;
-                break;
-            }
-        }
-
-        if (!channel && i >= FF_ARRAY_ELEMS(channel_names)) {
-            char *endptr = chname;
-            enum AVChannel id = AV_CHAN_NONE;
-
-            if (!strncmp(chname, "USR", 3)) {
-                const char *p = chname + 3;
-                id = strtol(p, &endptr, 0);
-            }
-            if (id < 0 || *endptr) {
-                native = 0; // Unknown channel name
-                channels = 0;
-                mask = 0;
-                av_free(chname);
-                break;
-            }
-            if (id > 63)
-                native = 0; // Not a native layout, use a custom one
-            else {
-                if (id < highest_channel || mask & (1ULL << id))
-                    native = 0; // Not a native layout, use a custom one
-                highest_channel = id;
-                mask |= 1ULL << id;
-            }
-        }
-        channels++;
-        av_free(channel);
-        av_free(chname);
-    }
-
-    if (mask && native) {
-        av_free(chlist);
-        if (nb_channels && ((nb_channels != channels) || (!end || *++end)))
-            return AVERROR(EINVAL);
-        av_channel_layout_from_mask(channel_layout, mask);
-        return 0;
-    }
-
-    /* custom layout of channel names */
-    if (channels && !native) {
-        int idx = 0;
+    matches = av_sscanf(str, "%d channels (%[^)]", &nb_channels, chlist);
+    ret = parse_channel_list(channel_layout, chlist);
+    av_freep(&chlist);
+    if (ret < 0 && ret != AVERROR(EINVAL))
+        return ret;
 
-        if (nb_channels && ((nb_channels != channels) || (!end || *++end))) {
-            av_free(chlist);
+    if (ret >= 0) {
+        end = strchr(str, ')');
+        if (matches == 2 && (nb_channels != channel_layout->nb_channels || !end || *++end)) {
+            av_channel_layout_uninit(channel_layout);
             return AVERROR(EINVAL);
         }
-
-        channel_layout->u.map = av_calloc(channels, sizeof(*channel_layout->u.map));
-        if (!channel_layout->u.map) {
-            av_free(chlist);
-            return AVERROR(ENOMEM);
-        }
-
-        channel_layout->order = AV_CHANNEL_ORDER_CUSTOM;
-        channel_layout->nb_channels = channels;
-
-        dup = chlist;
-        while (*dup) {
-            char *channel, *chname;
-            int ret = av_opt_get_key_value(&dup, "@", "+", AV_OPT_FLAG_IMPLICIT_KEY, &channel, &chname);
-            if (ret < 0) {
-                av_freep(&channel_layout->u.map);
-                av_free(chlist);
-                return ret;
-            }
-            if (*dup)
-                dup++; // skip separator
-            for (i = 0; i < FF_ARRAY_ELEMS(channel_names); i++) {
-                if (channel_names[i].name && !strcmp(channel ? channel : chname, channel_names[i].name)) {
-                    channel_layout->u.map[idx].id = i;
-                    if (channel)
-                        av_strlcpy(channel_layout->u.map[idx].name, chname, sizeof(channel_layout->u.map[idx].name));
-                    idx++;
-                    break;
-                }
-            }
-            if (i >= FF_ARRAY_ELEMS(channel_names)) {
-                const char *p = (channel ? channel : chname) + 3;
-                channel_layout->u.map[idx].id = strtol(p, NULL, 0);
-                if (channel)
-                    av_strlcpy(channel_layout->u.map[idx].name, chname, sizeof(channel_layout->u.map[idx].name));
-                idx++;
-            }
-            av_free(channel);
-            av_free(chname);
-        }
-        av_free(chlist);
-
         return 0;
     }
-    av_freep(&chlist);
 
     errno = 0;
     mask = strtoull(str, &end, 0);
@@ -659,6 +450,29 @@ int av_channel_layout_copy(AVChannelLayout *dst, const AVChannelLayout *src)
     return 0;
 }
 
+static int64_t masked_description(const AVChannelLayout *channel_layout, int start_channel)
+{
+    uint64_t mask = 0;
+    for (int i = start_channel; i < channel_layout->nb_channels; i++) {
+        enum AVChannel ch = channel_layout->u.map[i].id;
+        if (ch >= 0 && ch < 63 && mask < (1ULL << ch))
+            mask |= (1ULL << ch);
+        else
+            return AVERROR(EINVAL);
+    }
+    return mask;
+}
+
+static int has_channel_names(const AVChannelLayout *channel_layout)
+{
+    if (channel_layout->order != AV_CHANNEL_ORDER_CUSTOM)
+        return 0;
+    for (int i = 0; i < channel_layout->nb_channels; i++)
+        if (channel_layout->u.map[i].name[0])
+            return 1;
+    return 0;
+}
+
 /**
  * If the layout is n-th order standard-order ambisonic, with optional
  * extra non-diegetic channels at the end, return the order.
@@ -702,6 +516,33 @@ static int ambisonic_order(const AVChannelLayout *channel_layout)
     return order;
 }
 
+static enum AVChannelOrder canonical_order(AVChannelLayout *channel_layout)
+{
+    int has_known_channel = 0;
+    int order;
+
+    if (channel_layout->order != AV_CHANNEL_ORDER_CUSTOM)
+        return channel_layout->order;
+
+    if (has_channel_names(channel_layout))
+        return AV_CHANNEL_ORDER_CUSTOM;
+
+    for (int i = 0; i < channel_layout->nb_channels && !has_known_channel; i++)
+        if (channel_layout->u.map[i].id != AV_CHAN_UNKNOWN)
+            has_known_channel = 1;
+    if (!has_known_channel)
+        return AV_CHANNEL_ORDER_UNSPEC;
+
+    if (masked_description(channel_layout, 0) > 0)
+        return AV_CHANNEL_ORDER_NATIVE;
+
+    order = ambisonic_order(channel_layout);
+    if (order >= 0 && masked_description(channel_layout, (order + 1) * (order + 1)) >= 0)
+        return AV_CHANNEL_ORDER_AMBISONIC;
+
+    return AV_CHANNEL_ORDER_CUSTOM;
+}
+
 /**
  * If the custom layout is n-th order standard-order ambisonic, with optional
  * extra non-diegetic channels at the end, write its string description in bp.
@@ -726,9 +567,17 @@ static int try_describe_ambisonic(AVBPrint *bp, const AVChannelLayout *channel_l
             extra.nb_channels = av_popcount64(channel_layout->u.mask);
             extra.u.mask      = channel_layout->u.mask;
         } else {
-            extra.order       = AV_CHANNEL_ORDER_CUSTOM;
-            extra.nb_channels = channel_layout->nb_channels - nb_ambi_channels;
-            extra.u.map       = channel_layout->u.map + nb_ambi_channels;
+            int64_t mask;
+            if (!has_channel_names(channel_layout) &&
+                (mask = masked_description(channel_layout, nb_ambi_channels)) > 0) {
+                extra.order       = AV_CHANNEL_ORDER_NATIVE;
+                extra.nb_channels = av_popcount64(mask);
+                extra.u.mask      = mask;
+            } else {
+                extra.order       = AV_CHANNEL_ORDER_CUSTOM;
+                extra.nb_channels = channel_layout->nb_channels - nb_ambi_channels;
+                extra.u.map       = channel_layout->u.map + nb_ambi_channels;
+            }
         }
 
         av_bprint_chars(bp, '+', 1);
@@ -754,9 +603,17 @@ int av_channel_layout_describe_bprint(const AVChannelLayout *channel_layout,
         // fall-through
     case AV_CHANNEL_ORDER_CUSTOM:
         if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM) {
+            int64_t mask;
             int res = try_describe_ambisonic(bp, channel_layout);
             if (res >= 0)
                 return 0;
+            if (!has_channel_names(channel_layout) &&
+                (mask = masked_description(channel_layout, 0)) > 0) {
+                AVChannelLayout native = { .order       = AV_CHANNEL_ORDER_NATIVE,
+                                           .nb_channels = av_popcount64(mask),
+                                           .u.mask      = mask };
+                return av_channel_layout_describe_bprint(&native, bp);
+            }
         }
         if (channel_layout->nb_channels)
             av_bprintf(bp, "%d channels (", channel_layout->nb_channels);
@@ -1016,3 +873,97 @@ uint64_t av_channel_layout_subset(const AVChannelLayout *channel_layout,
 
     return ret;
 }
+
+int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags)
+{
+    int allow_lossy = !(flags & AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS);
+    int lossy;
+
+    if (!av_channel_layout_check(channel_layout))
+        return AVERROR(EINVAL);
+
+    if (flags & AV_CHANNEL_LAYOUT_RETYPE_FLAG_CANONICAL)
+        order = canonical_order(channel_layout);
+
+    if (channel_layout->order == order)
+        return 0;
+
+    switch (order) {
+    case AV_CHANNEL_ORDER_UNSPEC: {
+        int nb_channels = channel_layout->nb_channels;
+        if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM) {
+            lossy = 0;
+            for (int i = 0; i < nb_channels; i++) {
+                if (channel_layout->u.map[i].id != AV_CHAN_UNKNOWN || channel_layout->u.map[i].name[0]) {
+                    lossy = 1;
+                    break;
+                }
+            }
+        } else {
+            lossy = 1;
+        }
+        if (!lossy || allow_lossy) {
+            void *opaque = channel_layout->opaque;
+            av_channel_layout_uninit(channel_layout);
+            channel_layout->order       = AV_CHANNEL_ORDER_UNSPEC;
+            channel_layout->nb_channels = nb_channels;
+            channel_layout->opaque      = opaque;
+            return lossy;
+        }
+        return AVERROR(ENOSYS);
+        }
+    case AV_CHANNEL_ORDER_NATIVE:
+        if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM) {
+            int64_t mask = masked_description(channel_layout, 0);
+            if (mask < 0)
+                return AVERROR(ENOSYS);
+            lossy = has_channel_names(channel_layout);
+            if (!lossy || allow_lossy) {
+                void *opaque = channel_layout->opaque;
+                av_channel_layout_uninit(channel_layout);
+                av_channel_layout_from_mask(channel_layout, mask);
+                channel_layout->opaque = opaque;
+                return lossy;
+            }
+        }
+        return AVERROR(ENOSYS);
+    case AV_CHANNEL_ORDER_CUSTOM: {
+        AVChannelLayout custom = { 0 };
+        int ret = av_channel_layout_custom_init(&custom, channel_layout->nb_channels);
+        void *opaque = channel_layout->opaque;
+        if (ret < 0)
+            return ret;
+        if (channel_layout->order != AV_CHANNEL_ORDER_UNSPEC)
+            for (int i = 0; i < channel_layout->nb_channels; i++)
+                custom.u.map[i].id = av_channel_layout_channel_from_index(channel_layout, i);
+        av_channel_layout_uninit(channel_layout);
+        *channel_layout = custom;
+        channel_layout->opaque = opaque;
+        return 0;
+        }
+    case AV_CHANNEL_ORDER_AMBISONIC:
+        if (channel_layout->order == AV_CHANNEL_ORDER_CUSTOM) {
+            int64_t mask;
+            int nb_channels = channel_layout->nb_channels;
+            int order = ambisonic_order(channel_layout);
+            if (order < 0)
+                return AVERROR(ENOSYS);
+            mask = masked_description(channel_layout, (order + 1) * (order + 1));
+            if (mask < 0)
+                return AVERROR(ENOSYS);
+            lossy = has_channel_names(channel_layout);
+            if (!lossy || allow_lossy) {
+                void *opaque = channel_layout->opaque;
+                av_channel_layout_uninit(channel_layout);
+                channel_layout->order       = AV_CHANNEL_ORDER_AMBISONIC;
+                channel_layout->nb_channels = nb_channels;
+                channel_layout->u.mask      = mask;
+                channel_layout->opaque      = opaque;
+                return lossy;
+            }
+        }
+        return AVERROR(ENOSYS);
+    default:
+        return AVERROR(EINVAL);
+    }
+}
diff --git a/media/ffvpx/libavutil/channel_layout.h b/media/ffvpx/libavutil/channel_layout.h
index 8dc1a91401e69..8a078d160198c 100644
--- a/media/ffvpx/libavutil/channel_layout.h
+++ b/media/ffvpx/libavutil/channel_layout.h
@@ -119,7 +119,7 @@ enum AVChannelOrder {
     /**
      * The channel order does not correspond to any other predefined order and
      * is stored as an explicit map. For example, this could be used to support
-     * layouts with 64 or more channels, or with empty/skipped (AV_CHAN_SILENCE)
+     * layouts with 64 or more channels, or with empty/skipped (AV_CHAN_UNUSED)
      * channels at arbitrary positions.
      */
     AV_CHANNEL_ORDER_CUSTOM,
@@ -146,6 +146,10 @@ enum AVChannelOrder {
      * as defined in AmbiX format $ 2.1.
      */
     AV_CHANNEL_ORDER_AMBISONIC,
+    /**
+     * Number of channel orders, not part of ABI/API
+     */
+    FF_CHANNEL_ORDER_NB
 };
 
 
@@ -192,16 +196,6 @@ enum AVChannelOrder {
 #define AV_CH_BOTTOM_FRONT_LEFT      (1ULL << AV_CHAN_BOTTOM_FRONT_LEFT    )
 #define AV_CH_BOTTOM_FRONT_RIGHT     (1ULL << AV_CHAN_BOTTOM_FRONT_RIGHT   )
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-/** Channel mask value used for AVCodecContext.request_channel_layout
-    to indicate that the user requests the channel order of the decoder output
-    to be the native codec channel order.
-    @deprecated channel order is now indicated in a special field in
-                AVChannelLayout
-    */
-#define AV_CH_LAYOUT_NATIVE          0x8000000000000000ULL
-#endif
-
 /**
  * @}
  * @defgroup channel_mask_c Audio channel layouts
@@ -430,146 +424,6 @@ typedef struct AVChannelLayout {
 
 struct AVBPrint;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-/**
- * @name Deprecated Functions
- * @{
- */
-
-/**
- * Return a channel layout id that matches name, or 0 if no match is found.
- *
- * name can be one or several of the following notations,
- * separated by '+' or '|':
- * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
- *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
- * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
- *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
- * - a number of channels, in decimal, followed by 'c', yielding
- *   the default channel layout for that number of channels (@see
- *   av_get_default_channel_layout);
- * - a channel layout mask, in hexadecimal starting with "0x" (see the
- *   AV_CH_* macros).
- *
- * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
- *
- * @deprecated use av_channel_layout_from_string()
- */
-attribute_deprecated
-uint64_t av_get_channel_layout(const char *name);
-
-/**
- * Return a channel layout and the number of channels based on the specified name.
- *
- * This function is similar to (@see av_get_channel_layout), but can also parse
- * unknown channel layout specifications.
- *
- * @param[in]  name             channel layout specification string
- * @param[out] channel_layout   parsed channel layout (0 if unknown)
- * @param[out] nb_channels      number of channels
- *
- * @return 0 on success, AVERROR(EINVAL) if the parsing fails.
- * @deprecated use av_channel_layout_from_string()
- */
-attribute_deprecated
-int av_get_extended_channel_layout(const char *name, uint64_t* channel_layout, int* nb_channels);
-
-/**
- * Return a description of a channel layout.
- * If nb_channels is <= 0, it is guessed from the channel_layout.
- *
- * @param buf put here the string containing the channel layout
- * @param buf_size size in bytes of the buffer
- * @param nb_channels number of channels
- * @param channel_layout channel layout bitset
- * @deprecated use av_channel_layout_describe()
- */
-attribute_deprecated
-void av_get_channel_layout_string(char *buf, int buf_size, int nb_channels, uint64_t channel_layout);
-
-/**
- * Append a description of a channel layout to a bprint buffer.
- * @deprecated use av_channel_layout_describe()
- */
-attribute_deprecated
-void av_bprint_channel_layout(struct AVBPrint *bp, int nb_channels, uint64_t channel_layout);
-
-/**
- * Return the number of channels in the channel layout.
- * @deprecated use AVChannelLayout.nb_channels
- */
-attribute_deprecated
-int av_get_channel_layout_nb_channels(uint64_t channel_layout);
-
-/**
- * Return default channel layout for a given number of channels.
- *
- * @deprecated use av_channel_layout_default()
- */
-attribute_deprecated
-int64_t av_get_default_channel_layout(int nb_channels);
-
-/**
- * Get the index of a channel in channel_layout.
- *
- * @param channel_layout channel layout bitset
- * @param channel a channel layout describing exactly one channel which must be
- *                present in channel_layout.
- *
- * @return index of channel in channel_layout on success, a negative AVERROR
- *         on error.
- *
- * @deprecated use av_channel_layout_index_from_channel()
- */
-attribute_deprecated
-int av_get_channel_layout_channel_index(uint64_t channel_layout,
-                                        uint64_t channel);
-
-/**
- * Get the channel with the given index in channel_layout.
- * @deprecated use av_channel_layout_channel_from_index()
- */
-attribute_deprecated
-uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index);
-
-/**
- * Get the name of a given channel.
- *
- * @return channel name on success, NULL on error.
- *
- * @deprecated use av_channel_name()
- */
-attribute_deprecated
-const char *av_get_channel_name(uint64_t channel);
-
-/**
- * Get the description of a given channel.
- *
- * @param channel  a channel layout with a single channel
- * @return  channel description on success, NULL on error
- * @deprecated use av_channel_description()
- */
-attribute_deprecated
-const char *av_get_channel_description(uint64_t channel);
-
-/**
- * Get the value and name of a standard channel layout.
- *
- * @param[in]  index   index in an internal list, starting at 0
- * @param[out] layout  channel layout mask
- * @param[out] name    name of the layout
- * @return  0  if the layout exists,
- *          <0 if index is beyond the limits
- * @deprecated use av_channel_layout_standard()
- */
-attribute_deprecated
-int av_get_standard_channel_layout(unsigned index, uint64_t *layout,
-                                   const char **name);
-/**
- * @}
- */
-#endif
-
 /**
  * Get a human readable string in an abbreviated form describing a given channel.
  * This is the inverse function of @ref av_channel_from_string().
@@ -617,6 +471,23 @@ void av_channel_description_bprint(struct AVBPrint *bp, enum AVChannel channel_i
  */
 enum AVChannel av_channel_from_string(const char *name);
 
+/**
+ * Initialize a custom channel layout with the specified number of channels.
+ * The channel map will be allocated and the designation of all channels will
+ * be set to AV_CHAN_UNKNOWN.
+ *
+ * This is only a convenience helper function, a custom channel layout can also
+ * be constructed without using this.
+ *
+ * @param channel_layout the layout structure to be initialized
+ * @param nb_channels the number of channels
+ *
+ * @return 0 on success
+ *         AVERROR(EINVAL) if the number of channels <= 0
+ *         AVERROR(ENOMEM) if the channel map could not be allocated
+ */
+int av_channel_layout_custom_init(AVChannelLayout *channel_layout, int nb_channels);
+
 /**
  * Initialize a native channel layout from a bitmask indicating which channels
  * are present.
@@ -641,10 +512,14 @@ int av_channel_layout_from_mask(AVChannelLayout *channel_layout, uint64_t mask);
  *  - the number of unordered channels (eg. "4C" or "4 channels")
  *  - the ambisonic order followed by optional non-diegetic channels (eg.
  *    "ambisonic 2+stereo")
+ * On error, the channel layout will remain uninitialized, but not necessarily
+ * untouched.
  *
- * @param channel_layout input channel layout
+ * @param channel_layout uninitialized channel layout for the result
  * @param str string describing the channel layout
- * @return 0 channel layout was detected, AVERROR_INVALIDATATA otherwise
+ * @return 0 on success parsing the channel layout
+ *         AVERROR(EINVAL) if an invalid channel layout string was provided
+ *         AVERROR(ENOMEM) if there was not enough memory
  */
 int av_channel_layout_from_string(AVChannelLayout *channel_layout,
                                   const char *str);
@@ -804,6 +679,53 @@ int av_channel_layout_check(const AVChannelLayout *channel_layout);
  */
 int av_channel_layout_compare(const AVChannelLayout *chl, const AVChannelLayout *chl1);
 
+/**
+ * The conversion must be lossless.
+ */
+#define AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS (1 << 0)
+
+/**
+ * The specified retype target order is ignored and the simplest possible
+ * (canonical) order is used for which the input layout can be losslessy
+ * represented.
+ */
+#define AV_CHANNEL_LAYOUT_RETYPE_FLAG_CANONICAL (1 << 1)
+
+/**
+ * Change the AVChannelOrder of a channel layout.
+ *
+ * Change of AVChannelOrder can be either lossless or lossy. In case of a
+ * lossless conversion all the channel designations and the associated channel
+ * names (if any) are kept. On a lossy conversion the channel names and channel
+ * designations might be lost depending on the capabilities of the desired
+ * AVChannelOrder. Note that some conversions are simply not possible in which
+ * case this function returns AVERROR(ENOSYS).
+ *
+ * The following conversions are supported:
+ *
+ * Any       -> Custom     : Always possible, always lossless.
+ * Any       -> Unspecified: Always possible, lossless if channel designations
+ *   are all unknown and channel names are not used, lossy otherwise.
+ * Custom    -> Ambisonic  : Possible if it contains ambisonic channels with
+ *   optional non-diegetic channels in the end. Lossy if the channels have
+ *   custom names, lossless otherwise.
+ * Custom    -> Native     : Possible if it contains native channels in native
+ *     order. Lossy if the channels have custom names, lossless otherwise.
+ *
+ * On error this function keeps the original channel layout untouched.
+ *
+ * @param channel_layout channel layout which will be changed
+ * @param order the desired channel layout order
+ * @param flags a combination of AV_CHANNEL_LAYOUT_RETYPE_FLAG_* constants
+ * @return 0 if the conversion was successful and lossless or if the channel
+ *           layout was already in the desired order
+ *         >0 if the conversion was successful but lossy
+ *         AVERROR(ENOSYS) if the conversion was not possible (or would be
+ *           lossy and AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS was specified)
+ *         AVERROR(EINVAL), AVERROR(ENOMEM) on error
+ */
+int av_channel_layout_retype(AVChannelLayout *channel_layout, enum AVChannelOrder order, int flags);
+
 /**
  * @}
  */
diff --git a/media/ffvpx/libavutil/color_utils.c b/media/ffvpx/libavutil/color_utils.c
deleted file mode 100644
index 5e221fb798323..0000000000000
--- a/media/ffvpx/libavutil/color_utils.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Copyright (c) 2015 Kevin Wheatley <kevin.j.wheatley@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include <stddef.h>
-#include <math.h>
-
-#include "libavutil/color_utils.h"
-#include "libavutil/pixfmt.h"
-
-double avpriv_get_gamma_from_trc(enum AVColorTransferCharacteristic trc)
-{
-    double gamma;
-    switch (trc) {
-        case AVCOL_TRC_BT709:
-        case AVCOL_TRC_SMPTE170M:
-        case AVCOL_TRC_SMPTE240M:
-        case AVCOL_TRC_BT1361_ECG:
-        case AVCOL_TRC_BT2020_10:
-        case AVCOL_TRC_BT2020_12:
-            /* these share a segmented TRC, but gamma 1.961 is a close
-              approximation, and also more correct for decoding content */
-            gamma = 1.961;
-            break;
-        case AVCOL_TRC_GAMMA22:
-        case AVCOL_TRC_IEC61966_2_1:
-            gamma = 2.2;
-            break;
-        case AVCOL_TRC_GAMMA28:
-            gamma = 2.8;
-            break;
-        case AVCOL_TRC_LINEAR:
-            gamma = 1.0;
-            break;
-        default:
-            gamma = 0.0; // Unknown value representation
-    }
-    return gamma;
-}
-
-#define BT709_alpha 1.099296826809442
-#define BT709_beta 0.018053968510807
-
-static double avpriv_trc_bt709(double Lc)
-{
-    const double a = BT709_alpha;
-    const double b = BT709_beta;
-
-    return (0.0 > Lc) ? 0.0
-         : (  b > Lc) ? 4.500 * Lc
-         :              a * pow(Lc, 0.45) - (a - 1.0);
-}
-
-static double avpriv_trc_gamma22(double Lc)
-{
-    return (0.0 > Lc) ? 0.0 : pow(Lc, 1.0/ 2.2);
-}
-
-static double avpriv_trc_gamma28(double Lc)
-{
-    return (0.0 > Lc) ? 0.0 : pow(Lc, 1.0/ 2.8);
-}
-
-static double avpriv_trc_smpte240M(double Lc)
-{
-    const double a = 1.1115;
-    const double b = 0.0228;
-
-    return (0.0 > Lc) ? 0.0
-         : (  b > Lc) ? 4.000 * Lc
-         :              a * pow(Lc, 0.45) - (a - 1.0);
-}
-
-static double avpriv_trc_linear(double Lc)
-{
-    return Lc;
-}
-
-static double avpriv_trc_log(double Lc)
-{
-    return (0.01 > Lc) ? 0.0 : 1.0 + log10(Lc) / 2.0;
-}
-
-static double avpriv_trc_log_sqrt(double Lc)
-{
-    // sqrt(10) / 1000
-    return (0.00316227766 > Lc) ? 0.0 : 1.0 + log10(Lc) / 2.5;
-}
-
-static double avpriv_trc_iec61966_2_4(double Lc)
-{
-    const double a = BT709_alpha;
-    const double b = BT709_beta;
-
-    return (-b >= Lc) ? -a * pow(-Lc, 0.45) + (a - 1.0)
-         : ( b >  Lc) ? 4.500 * Lc
-         :               a * pow( Lc, 0.45) - (a - 1.0);
-}
-
-static double avpriv_trc_bt1361(double Lc)
-{
-    const double a = BT709_alpha;
-    const double b = BT709_beta;
-
-    return (-0.0045 >= Lc) ? -(a * pow(-4.0 * Lc, 0.45) + (a - 1.0)) / 4.0
-         : ( b >  Lc) ? 4.500 * Lc
-         :               a * pow( Lc, 0.45) - (a - 1.0);
-}
-
-static double avpriv_trc_iec61966_2_1(double Lc)
-{
-    const double a = 1.055;
-    const double b = 0.0031308;
-
-    return (0.0 > Lc) ? 0.0
-         : (  b > Lc) ? 12.92 * Lc
-         :              a * pow(Lc, 1.0  / 2.4) - (a - 1.0);
-}
-
-static double avpriv_trc_smpte_st2084(double Lc)
-{
-    const double c1 =         3424.0 / 4096.0; // c3-c2 + 1
-    const double c2 =  32.0 * 2413.0 / 4096.0;
-    const double c3 =  32.0 * 2392.0 / 4096.0;
-    const double m  = 128.0 * 2523.0 / 4096.0;
-    const double n  =  0.25 * 2610.0 / 4096.0;
-    const double L  = Lc / 10000.0;
-    const double Ln = pow(L, n);
-
-    return (0.0 > Lc) ? 0.0
-         :              pow((c1 + c2 * Ln) / (1.0 + c3 * Ln), m);
-
-}
-
-static double avpriv_trc_smpte_st428_1(double Lc)
-{
-    return (0.0 > Lc) ? 0.0
-         :              pow(48.0 * Lc / 52.37, 1.0 / 2.6);
-}
-
-
-static double avpriv_trc_arib_std_b67(double Lc) {
-    // The function uses the definition from HEVC, which assumes that the peak
-    // white is input level = 1. (this is equivalent to scaling E = Lc * 12 and
-    // using the definition from the ARIB STD-B67 spec)
-    const double a = 0.17883277;
-    const double b = 0.28466892;
-    const double c = 0.55991073;
-    return (0.0 > Lc) ? 0.0 :
-        (Lc <= 1.0 / 12.0 ? sqrt(3.0 * Lc) : a * log(12.0 * Lc - b) + c);
-}
-
-avpriv_trc_function avpriv_get_trc_function_from_trc(enum AVColorTransferCharacteristic trc)
-{
-    avpriv_trc_function func = NULL;
-    switch (trc) {
-        case AVCOL_TRC_BT709:
-        case AVCOL_TRC_SMPTE170M:
-        case AVCOL_TRC_BT2020_10:
-        case AVCOL_TRC_BT2020_12:
-            func = avpriv_trc_bt709;
-            break;
-
-        case AVCOL_TRC_GAMMA22:
-            func = avpriv_trc_gamma22;
-            break;
-        case AVCOL_TRC_GAMMA28:
-            func = avpriv_trc_gamma28;
-            break;
-
-        case AVCOL_TRC_SMPTE240M:
-            func = avpriv_trc_smpte240M;
-            break;
-
-        case AVCOL_TRC_LINEAR:
-            func = avpriv_trc_linear;
-            break;
-
-        case AVCOL_TRC_LOG:
-            func = avpriv_trc_log;
-            break;
-
-        case AVCOL_TRC_LOG_SQRT:
-            func = avpriv_trc_log_sqrt;
-            break;
-
-        case AVCOL_TRC_IEC61966_2_4:
-            func = avpriv_trc_iec61966_2_4;
-            break;
-
-        case AVCOL_TRC_BT1361_ECG:
-            func = avpriv_trc_bt1361;
-            break;
-
-        case AVCOL_TRC_IEC61966_2_1:
-            func = avpriv_trc_iec61966_2_1;
-            break;
-
-        case AVCOL_TRC_SMPTEST2084:
-            func = avpriv_trc_smpte_st2084;
-            break;
-
-        case AVCOL_TRC_SMPTEST428_1:
-            func = avpriv_trc_smpte_st428_1;
-            break;
-
-        case AVCOL_TRC_ARIB_STD_B67:
-            func = avpriv_trc_arib_std_b67;
-            break;
-
-        case AVCOL_TRC_RESERVED0:
-        case AVCOL_TRC_UNSPECIFIED:
-        case AVCOL_TRC_RESERVED:
-        default:
-            break;
-    }
-    return func;
-}
diff --git a/media/ffvpx/libavutil/color_utils.h b/media/ffvpx/libavutil/color_utils.h
deleted file mode 100644
index 9529006452c35..0000000000000
--- a/media/ffvpx/libavutil/color_utils.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2015 Kevin Wheatley <kevin.j.wheatley@gmail.com>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_COLOR_UTILS_H
-#define AVUTIL_COLOR_UTILS_H
-
-
-#include "libavutil/pixfmt.h"
-
-/**
- * Determine a suitable 'gamma' value to match the supplied
- * AVColorTransferCharacteristic.
- *
- * See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/_index.html)
- *
- * @return Will return an approximation to the simple gamma function matching
- *         the supplied Transfer Characteristic, Will return 0.0 for any
- *         we cannot reasonably match against.
- */
-double avpriv_get_gamma_from_trc(enum AVColorTransferCharacteristic trc);
-
-
-typedef double (*avpriv_trc_function)(double);
-
-/**
- * Determine the function needed to apply the given
- * AVColorTransferCharacteristic to linear input.
- *
- * The function returned should expect a nominal domain and range of [0.0-1.0]
- * values outside of this range maybe valid depending on the chosen
- * characteristic function.
- *
- * @return Will return pointer to the function matching the
- *         supplied Transfer Characteristic. If unspecified will
- *         return NULL:
- */
-avpriv_trc_function avpriv_get_trc_function_from_trc(enum AVColorTransferCharacteristic trc);
-
-#endif
diff --git a/media/ffvpx/libavutil/common.h b/media/ffvpx/libavutil/common.h
index de2140a678670..3e4c3398930dc 100644
--- a/media/ffvpx/libavutil/common.h
+++ b/media/ffvpx/libavutil/common.h
@@ -43,6 +43,14 @@
 #include "error.h"
 #include "macros.h"
 
+#ifdef HAVE_AV_CONFIG_H
+#   include "config.h"
+#   include "intmath.h"
+#   include "internal.h"
+#else
+#   include "mem.h"
+#endif /* HAVE_AV_CONFIG_H */
+
 //rounded division & shift
 #define RSHIFT(a,b) ((a) > 0 ? ((a) + ((1<<(b))>>1))>>(b) : ((a) + ((1<<(b))>>1)-1)>>(b))
 /* assume b>0 */
@@ -84,11 +92,6 @@
 
 /* misc math functions */
 
-#ifdef HAVE_AV_CONFIG_H
-#   include "config.h"
-#   include "intmath.h"
-#endif
-
 #ifndef av_ceil_log2
 #   define av_ceil_log2     av_ceil_log2_c
 #endif
@@ -568,12 +571,4 @@ static av_always_inline av_const int av_parity_c(uint32_t v)
         }\
     }\
 
-
-
-#include "mem.h"
-
-#ifdef HAVE_AV_CONFIG_H
-#    include "internal.h"
-#endif /* HAVE_AV_CONFIG_H */
-
 #endif /* AVUTIL_COMMON_H */
diff --git a/media/ffvpx/libavutil/cpu.c b/media/ffvpx/libavutil/cpu.c
index 48d195168c171..d4f947360a597 100644
--- a/media/ffvpx/libavutil/cpu.c
+++ b/media/ffvpx/libavutil/cpu.c
@@ -49,8 +49,8 @@
 #include <unistd.h>
 #endif
 
-static atomic_int cpu_flags = ATOMIC_VAR_INIT(-1);
-static atomic_int cpu_count = ATOMIC_VAR_INIT(-1);
+static atomic_int cpu_flags = -1;
+static atomic_int cpu_count = -1;
 
 static int get_cpu_flags(void)
 {
@@ -208,7 +208,7 @@ int av_parse_cpu_caps(unsigned *flags, const char *s)
 
 int av_cpu_count(void)
 {
-    static atomic_int printed = ATOMIC_VAR_INIT(0);
+    static atomic_int printed = 0;
 
     int nb_cpus = 1;
     int count   = 0;
diff --git a/media/ffvpx/libavutil/csp.h b/media/ffvpx/libavutil/csp.h
new file mode 100644
index 0000000000000..73bce52bc0c8c
--- /dev/null
+++ b/media/ffvpx/libavutil/csp.h
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2015 Kevin Wheatley <kevin.j.wheatley@gmail.com>
+ * Copyright (c) 2016 Ronald S. Bultje <rsbultje@gmail.com>
+ * Copyright (c) 2023 Leo Izen <leo.izen@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_CSP_H
+#define AVUTIL_CSP_H
+
+#include "pixfmt.h"
+#include "rational.h"
+
+/**
+ * @file
+ * Colorspace value utility functions for libavutil.
+ * @ingroup lavu_math_csp
+ * @author Ronald S. Bultje <rsbultje@gmail.com>
+ * @author Leo Izen <leo.izen@gmail.com>
+ * @author Kevin Wheatley <kevin.j.wheatley@gmail.com>
+ */
+
+/**
+ * @defgroup lavu_math_csp Colorspace Utility
+ * @ingroup lavu_math
+ * @{
+ */
+
+/**
+ * Struct containing luma coefficients to be used for RGB to YUV/YCoCg, or similar
+ * calculations.
+ */
+typedef struct AVLumaCoefficients {
+    AVRational cr, cg, cb;
+} AVLumaCoefficients;
+
+/**
+ * Struct containing chromaticity x and y values for the standard CIE 1931
+ * chromaticity definition.
+ */
+typedef struct AVCIExy {
+    AVRational x, y;
+} AVCIExy;
+
+/**
+ * Struct defining the red, green, and blue primary locations in terms of CIE
+ * 1931 chromaticity x and y.
+ */
+typedef struct AVPrimaryCoefficients {
+    AVCIExy r, g, b;
+} AVPrimaryCoefficients;
+
+/**
+ * Struct defining white point location in terms of CIE 1931 chromaticity x
+ * and y.
+ */
+typedef AVCIExy AVWhitepointCoefficients;
+
+/**
+ * Struct that contains both white point location and primaries location, providing
+ * the complete description of a color gamut.
+ */
+typedef struct AVColorPrimariesDesc {
+    AVWhitepointCoefficients wp;
+    AVPrimaryCoefficients prim;
+} AVColorPrimariesDesc;
+
+/**
+ * Function pointer representing a double -> double transfer function that performs
+ * an EOTF transfer inversion. This function outputs linear light.
+ */
+typedef double (*av_csp_trc_function)(double);
+
+/**
+ * Retrieves the Luma coefficients necessary to construct a conversion matrix
+ * from an enum constant describing the colorspace.
+ * @param csp An enum constant indicating YUV or similar colorspace.
+ * @return The Luma coefficients associated with that colorspace, or NULL
+ *     if the constant is unknown to libavutil.
+ */
+const AVLumaCoefficients *av_csp_luma_coeffs_from_avcsp(enum AVColorSpace csp);
+
+/**
+ * Retrieves a complete gamut description from an enum constant describing the
+ * color primaries.
+ * @param prm An enum constant indicating primaries
+ * @return A description of the colorspace gamut associated with that enum
+ *     constant, or NULL if the constant is unknown to libavutil.
+ */
+const AVColorPrimariesDesc *av_csp_primaries_desc_from_id(enum AVColorPrimaries prm);
+
+/**
+ * Detects which enum AVColorPrimaries constant corresponds to the given complete
+ * gamut description.
+ * @see enum AVColorPrimaries
+ * @param prm A description of the colorspace gamut
+ * @return The enum constant associated with this gamut, or
+ *     AVCOL_PRI_UNSPECIFIED if no clear match can be idenitified.
+ */
+enum AVColorPrimaries av_csp_primaries_id_from_desc(const AVColorPrimariesDesc *prm);
+
+/**
+ * Determine a suitable 'gamma' value to match the supplied
+ * AVColorTransferCharacteristic.
+ *
+ * See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/_index.html)
+ *
+ * This function returns the gamma exponent for the OETF. For example, sRGB is approximated
+ * by gamma 2.2, not by gamma 0.45455.
+ *
+ * @return Will return an approximation to the simple gamma function matching
+ *         the supplied Transfer Characteristic, Will return 0.0 for any
+ *         we cannot reasonably match against.
+ */
+double av_csp_approximate_trc_gamma(enum AVColorTransferCharacteristic trc);
+
+/**
+ * Determine the function needed to apply the given
+ * AVColorTransferCharacteristic to linear input.
+ *
+ * The function returned should expect a nominal domain and range of [0.0-1.0]
+ * values outside of this range maybe valid depending on the chosen
+ * characteristic function.
+ *
+ * @return Will return pointer to the function matching the
+ *         supplied Transfer Characteristic. If unspecified will
+ *         return NULL:
+ */
+av_csp_trc_function av_csp_trc_func_from_id(enum AVColorTransferCharacteristic trc);
+
+/**
+ * @}
+ */
+
+#endif /* AVUTIL_CSP_H */
diff --git a/media/ffvpx/libavutil/dict.c b/media/ffvpx/libavutil/dict.c
index 7f23d5336a267..6fb09399ba641 100644
--- a/media/ffvpx/libavutil/dict.c
+++ b/media/ffvpx/libavutil/dict.c
@@ -145,11 +145,8 @@ int av_dict_set(AVDictionary **pm, const char *key, const char *value,
         m->elems[m->count].value = copy_value;
         m->count++;
     } else {
-        if (!m->count) {
-            av_freep(&m->elems);
-            av_freep(pm);
-        }
-        av_freep(&copy_key);
+        err = 0;
+        goto end;
     }
 
     return 0;
@@ -157,12 +154,13 @@ int av_dict_set(AVDictionary **pm, const char *key, const char *value,
 enomem:
     err = AVERROR(ENOMEM);
 err_out:
+    av_free(copy_value);
+end:
     if (m && !m->count) {
         av_freep(&m->elems);
         av_freep(pm);
     }
     av_free(copy_key);
-    av_free(copy_value);
     return err;
 }
 
diff --git a/media/ffvpx/libavutil/eval.c b/media/ffvpx/libavutil/eval.c
index 95adb516099ec..84ff929130613 100644
--- a/media/ffvpx/libavutil/eval.c
+++ b/media/ffvpx/libavutil/eval.c
@@ -32,13 +32,12 @@
 #include "common.h"
 #include "eval.h"
 #include "ffmath.h"
-#include "internal.h"
 #include "log.h"
 #include "mathematics.h"
+#include "mem.h"
 #include "sfc64.h"
 #include "fftime.h"
 #include "avstring.h"
-#include "timer.h"
 #include "reverse.h"
 
 typedef struct Parser {
diff --git a/media/ffvpx/libavutil/fftime.h b/media/ffvpx/libavutil/fftime.h
index 8f3b320e381b8..dc169b064a0d7 100644
--- a/media/ffvpx/libavutil/fftime.h
+++ b/media/ffvpx/libavutil/fftime.h
@@ -22,7 +22,6 @@
 #define AVUTIL_TIME_H
 
 #include <stdint.h>
-#include <time.h>
 
 /**
  * Get the current time in microseconds.
diff --git a/media/ffvpx/libavutil/ffversion.h b/media/ffvpx/libavutil/ffversion.h
index 392808d726b4d..1aa567741fb7f 100644
--- a/media/ffvpx/libavutil/ffversion.h
+++ b/media/ffvpx/libavutil/ffversion.h
@@ -1,5 +1,5 @@
 /* Automatically generated by version.sh, do not manually edit! */
 #ifndef AVUTIL_FFVERSION_H
 #define AVUTIL_FFVERSION_H
-#define FFMPEG_VERSION "N-111736-gd9d5695390"
+#define FFMPEG_VERSION "N-114439-gf0ee4bbc6b"
 #endif /* AVUTIL_FFVERSION_H */
diff --git a/media/ffvpx/libavutil/fifo.c b/media/ffvpx/libavutil/fifo.c
index b0807abbf7ee5..8806c668d7e46 100644
--- a/media/ffvpx/libavutil/fifo.c
+++ b/media/ffvpx/libavutil/fifo.c
@@ -290,222 +290,3 @@ void av_fifo_freep2(AVFifo **f)
         av_freep(f);
     }
 }
-
-
-#if FF_API_FIFO_OLD_API
-#include "internal.h"
-FF_DISABLE_DEPRECATION_WARNINGS
-#define OLD_FIFO_SIZE_MAX (size_t)FFMIN3(INT_MAX, UINT32_MAX, SIZE_MAX)
-
-AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size)
-{
-    AVFifoBuffer *f;
-    void *buffer;
-
-    if (nmemb > OLD_FIFO_SIZE_MAX / size)
-        return NULL;
-
-    buffer = av_realloc_array(NULL, nmemb, size);
-    if (!buffer)
-        return NULL;
-    f = av_mallocz(sizeof(AVFifoBuffer));
-    if (!f) {
-        av_free(buffer);
-        return NULL;
-    }
-    f->buffer = buffer;
-    f->end    = f->buffer + nmemb * size;
-    av_fifo_reset(f);
-    return f;
-}
-
-AVFifoBuffer *av_fifo_alloc(unsigned int size)
-{
-    return av_fifo_alloc_array(size, 1);
-}
-
-void av_fifo_free(AVFifoBuffer *f)
-{
-    if (f) {
-        av_freep(&f->buffer);
-        av_free(f);
-    }
-}
-
-void av_fifo_freep(AVFifoBuffer **f)
-{
-    if (f) {
-        av_fifo_free(*f);
-        *f = NULL;
-    }
-}
-
-void av_fifo_reset(AVFifoBuffer *f)
-{
-    f->wptr = f->rptr = f->buffer;
-    f->wndx = f->rndx = 0;
-}
-
-int av_fifo_size(const AVFifoBuffer *f)
-{
-    return (uint32_t)(f->wndx - f->rndx);
-}
-
-int av_fifo_space(const AVFifoBuffer *f)
-{
-    return f->end - f->buffer - av_fifo_size(f);
-}
-
-int av_fifo_realloc2(AVFifoBuffer *f, unsigned int new_size)
-{
-    unsigned int old_size = f->end - f->buffer;
-
-    if (new_size > OLD_FIFO_SIZE_MAX)
-        return AVERROR(EINVAL);
-
-    if (old_size < new_size) {
-        size_t offset_r = f->rptr - f->buffer;
-        size_t offset_w = f->wptr - f->buffer;
-        uint8_t *tmp;
-
-        tmp = av_realloc(f->buffer, new_size);
-        if (!tmp)
-            return AVERROR(ENOMEM);
-
-        // move the data from the beginning of the ring buffer
-        // to the newly allocated space
-        // the second condition distinguishes full vs empty fifo
-        if (offset_w <= offset_r && av_fifo_size(f)) {
-            const size_t copy = FFMIN(new_size - old_size, offset_w);
-            memcpy(tmp + old_size, tmp, copy);
-            if (copy < offset_w) {
-                memmove(tmp, tmp + copy , offset_w - copy);
-                offset_w -= copy;
-            } else
-                offset_w = old_size + copy;
-        }
-
-        f->buffer = tmp;
-        f->end    = f->buffer + new_size;
-        f->rptr   = f->buffer + offset_r;
-        f->wptr   = f->buffer + offset_w;
-    }
-    return 0;
-}
-
-int av_fifo_grow(AVFifoBuffer *f, unsigned int size)
-{
-    unsigned int old_size = f->end - f->buffer;
-    if(size + (unsigned)av_fifo_size(f) < size)
-        return AVERROR(EINVAL);
-
-    size += av_fifo_size(f);
-
-    if (old_size < size)
-        return av_fifo_realloc2(f, FFMAX(size, 2*old_size));
-    return 0;
-}
-
-/* src must NOT be const as it can be a context for func that may need
- * updating (like a pointer or byte counter) */
-int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size,
-                          int (*func)(void *, void *, int))
-{
-    int total = size;
-    uint32_t wndx= f->wndx;
-    uint8_t *wptr= f->wptr;
-
-    if (size > av_fifo_space(f))
-        return AVERROR(ENOSPC);
-
-    do {
-        int len = FFMIN(f->end - wptr, size);
-        if (func) {
-            len = func(src, wptr, len);
-            if (len <= 0)
-                break;
-        } else {
-            memcpy(wptr, src, len);
-            src = (uint8_t *)src + len;
-        }
-        wptr += len;
-        if (wptr >= f->end)
-            wptr = f->buffer;
-        wndx    += len;
-        size    -= len;
-    } while (size > 0);
-    f->wndx= wndx;
-    f->wptr= wptr;
-    return total - size;
-}
-
-int av_fifo_generic_peek_at(AVFifoBuffer *f, void *dest, int offset, int buf_size, void (*func)(void*, void*, int))
-{
-    uint8_t *rptr = f->rptr;
-
-    if (offset < 0 || buf_size > av_fifo_size(f) - offset)
-        return AVERROR(EINVAL);
-
-    if (offset >= f->end - rptr)
-        rptr += offset - (f->end - f->buffer);
-    else
-        rptr += offset;
-
-    while (buf_size > 0) {
-        int len;
-
-        if (rptr >= f->end)
-            rptr -= f->end - f->buffer;
-
-        len = FFMIN(f->end - rptr, buf_size);
-        if (func)
-            func(dest, rptr, len);
-        else {
-            memcpy(dest, rptr, len);
-            dest = (uint8_t *)dest + len;
-        }
-
-        buf_size -= len;
-        rptr     += len;
-    }
-
-    return 0;
-}
-
-int av_fifo_generic_peek(AVFifoBuffer *f, void *dest, int buf_size,
-                         void (*func)(void *, void *, int))
-{
-    return av_fifo_generic_peek_at(f, dest, 0, buf_size, func);
-}
-
-int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size,
-                         void (*func)(void *, void *, int))
-{
-    if (buf_size > av_fifo_size(f))
-        return AVERROR(EINVAL);
-
-    do {
-        int len = FFMIN(f->end - f->rptr, buf_size);
-        if (func)
-            func(dest, f->rptr, len);
-        else {
-            memcpy(dest, f->rptr, len);
-            dest = (uint8_t *)dest + len;
-        }
-        av_fifo_drain(f, len);
-        buf_size -= len;
-    } while (buf_size > 0);
-    return 0;
-}
-
-/** Discard data from the FIFO. */
-void av_fifo_drain(AVFifoBuffer *f, int size)
-{
-    av_assert2(av_fifo_size(f) >= size);
-    f->rptr += size;
-    if (f->rptr >= f->end)
-        f->rptr -= f->end - f->buffer;
-    f->rndx += size;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
diff --git a/media/ffvpx/libavutil/fifo.h b/media/ffvpx/libavutil/fifo.h
index ce3a2aed7cec5..f2206c35f524c 100644
--- a/media/ffvpx/libavutil/fifo.h
+++ b/media/ffvpx/libavutil/fifo.h
@@ -26,10 +26,6 @@
 #define AVUTIL_FIFO_H
 
 #include <stddef.h>
-#include <stdint.h>
-
-#include "attributes.h"
-#include "version.h"
 
 /**
  * @defgroup lavu_fifo AVFifo
@@ -239,208 +235,6 @@ void av_fifo_reset2(AVFifo *f);
  */
 void av_fifo_freep2(AVFifo **f);
 
-
-#if FF_API_FIFO_OLD_API
-typedef struct AVFifoBuffer {
-    uint8_t *buffer;
-    uint8_t *rptr, *wptr, *end;
-    uint32_t rndx, wndx;
-} AVFifoBuffer;
-
-/**
- * Initialize an AVFifoBuffer.
- * @param size of FIFO
- * @return AVFifoBuffer or NULL in case of memory allocation failure
- * @deprecated use av_fifo_alloc2()
- */
-attribute_deprecated
-AVFifoBuffer *av_fifo_alloc(unsigned int size);
-
-/**
- * Initialize an AVFifoBuffer.
- * @param nmemb number of elements
- * @param size  size of the single element
- * @return AVFifoBuffer or NULL in case of memory allocation failure
- * @deprecated use av_fifo_alloc2()
- */
-attribute_deprecated
-AVFifoBuffer *av_fifo_alloc_array(size_t nmemb, size_t size);
-
-/**
- * Free an AVFifoBuffer.
- * @param f AVFifoBuffer to free
- * @deprecated use the AVFifo API with av_fifo_freep2()
- */
-attribute_deprecated
-void av_fifo_free(AVFifoBuffer *f);
-
-/**
- * Free an AVFifoBuffer and reset pointer to NULL.
- * @param f AVFifoBuffer to free
- * @deprecated use the AVFifo API with av_fifo_freep2()
- */
-attribute_deprecated
-void av_fifo_freep(AVFifoBuffer **f);
-
-/**
- * Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.
- * @param f AVFifoBuffer to reset
- * @deprecated use av_fifo_reset2() with the new AVFifo-API
- */
-attribute_deprecated
-void av_fifo_reset(AVFifoBuffer *f);
-
-/**
- * Return the amount of data in bytes in the AVFifoBuffer, that is the
- * amount of data you can read from it.
- * @param f AVFifoBuffer to read from
- * @return size
- * @deprecated use av_fifo_can_read() with the new AVFifo-API
- */
-attribute_deprecated
-int av_fifo_size(const AVFifoBuffer *f);
-
-/**
- * Return the amount of space in bytes in the AVFifoBuffer, that is the
- * amount of data you can write into it.
- * @param f AVFifoBuffer to write into
- * @return size
- * @deprecated use av_fifo_can_write() with the new AVFifo-API
- */
-attribute_deprecated
-int av_fifo_space(const AVFifoBuffer *f);
-
-/**
- * Feed data at specific position from an AVFifoBuffer to a user-supplied callback.
- * Similar as av_fifo_gereric_read but without discarding data.
- * @param f AVFifoBuffer to read from
- * @param offset offset from current read position
- * @param buf_size number of bytes to read
- * @param func generic read function
- * @param dest data destination
- *
- * @return a non-negative number on success, a negative error code on failure
- *
- * @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,
- *             av_fifo_peek_to_cb() otherwise
- */
-attribute_deprecated
-int av_fifo_generic_peek_at(AVFifoBuffer *f, void *dest, int offset, int buf_size, void (*func)(void*, void*, int));
-
-/**
- * Feed data from an AVFifoBuffer to a user-supplied callback.
- * Similar as av_fifo_gereric_read but without discarding data.
- * @param f AVFifoBuffer to read from
- * @param buf_size number of bytes to read
- * @param func generic read function
- * @param dest data destination
- *
- * @return a non-negative number on success, a negative error code on failure
- *
- * @deprecated use the new AVFifo-API with av_fifo_peek() when func == NULL,
- *             av_fifo_peek_to_cb() otherwise
- */
-attribute_deprecated
-int av_fifo_generic_peek(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
-
-/**
- * Feed data from an AVFifoBuffer to a user-supplied callback.
- * @param f AVFifoBuffer to read from
- * @param buf_size number of bytes to read
- * @param func generic read function
- * @param dest data destination
- *
- * @return a non-negative number on success, a negative error code on failure
- *
- * @deprecated use the new AVFifo-API with av_fifo_read() when func == NULL,
- *             av_fifo_read_to_cb() otherwise
- */
-attribute_deprecated
-int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int));
-
-/**
- * Feed data from a user-supplied callback to an AVFifoBuffer.
- * @param f AVFifoBuffer to write to
- * @param src data source; non-const since it may be used as a
- * modifiable context by the function defined in func
- * @param size number of bytes to write
- * @param func generic write function; the first parameter is src,
- * the second is dest_buf, the third is dest_buf_size.
- * func must return the number of bytes written to dest_buf, or <= 0 to
- * indicate no more data available to write.
- * If func is NULL, src is interpreted as a simple byte array for source data.
- * @return the number of bytes written to the FIFO or a negative error code on failure
- *
- * @deprecated use the new AVFifo-API with av_fifo_write() when func == NULL,
- *             av_fifo_write_from_cb() otherwise
- */
-attribute_deprecated
-int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int));
-
-/**
- * Resize an AVFifoBuffer.
- * In case of reallocation failure, the old FIFO is kept unchanged.
- *
- * @param f AVFifoBuffer to resize
- * @param size new AVFifoBuffer size in bytes
- * @return <0 for failure, >=0 otherwise
- *
- * @deprecated use the new AVFifo-API with av_fifo_grow2() to increase FIFO size,
- *             decreasing FIFO size is not supported
- */
-attribute_deprecated
-int av_fifo_realloc2(AVFifoBuffer *f, unsigned int size);
-
-/**
- * Enlarge an AVFifoBuffer.
- * In case of reallocation failure, the old FIFO is kept unchanged.
- * The new fifo size may be larger than the requested size.
- *
- * @param f AVFifoBuffer to resize
- * @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()
- * @return <0 for failure, >=0 otherwise
- *
- * @deprecated use the new AVFifo-API with av_fifo_grow2(); note that unlike
- * this function it adds to the allocated size, rather than to the used size
- */
-attribute_deprecated
-int av_fifo_grow(AVFifoBuffer *f, unsigned int additional_space);
-
-/**
- * Read and discard the specified amount of data from an AVFifoBuffer.
- * @param f AVFifoBuffer to read from
- * @param size amount of data to read in bytes
- *
- * @deprecated use the new AVFifo-API with av_fifo_drain2()
- */
-attribute_deprecated
-void av_fifo_drain(AVFifoBuffer *f, int size);
-
-#if FF_API_FIFO_PEEK2
-/**
- * Return a pointer to the data stored in a FIFO buffer at a certain offset.
- * The FIFO buffer is not modified.
- *
- * @param f    AVFifoBuffer to peek at, f must be non-NULL
- * @param offs an offset in bytes, its absolute value must be less
- *             than the used buffer size or the returned pointer will
- *             point outside to the buffer data.
- *             The used buffer size can be checked with av_fifo_size().
- * @deprecated use the new AVFifo-API with av_fifo_peek() or av_fifo_peek_to_cb()
- */
-attribute_deprecated
-static inline uint8_t *av_fifo_peek2(const AVFifoBuffer *f, int offs)
-{
-    uint8_t *ptr = f->rptr + offs;
-    if (ptr >= f->end)
-        ptr = f->buffer + (ptr - f->end);
-    else if (ptr < f->buffer)
-        ptr = f->end - (f->buffer - ptr);
-    return ptr;
-}
-#endif
-#endif
-
 /**
  * @}
  */
diff --git a/media/ffvpx/libavutil/film_grain_params.c b/media/ffvpx/libavutil/film_grain_params.c
index 930d23c7fe921..0a6004b6b308b 100644
--- a/media/ffvpx/libavutil/film_grain_params.c
+++ b/media/ffvpx/libavutil/film_grain_params.c
@@ -17,6 +17,8 @@
  */
 
 #include "film_grain_params.h"
+#include "mem.h"
+#include "pixdesc.h"
 
 AVFilmGrainParams *av_film_grain_params_alloc(size_t *size)
 {
@@ -30,13 +32,75 @@ AVFilmGrainParams *av_film_grain_params_alloc(size_t *size)
 
 AVFilmGrainParams *av_film_grain_params_create_side_data(AVFrame *frame)
 {
+    AVFilmGrainParams *fgp;
     AVFrameSideData *side_data = av_frame_new_side_data(frame,
                                                         AV_FRAME_DATA_FILM_GRAIN_PARAMS,
                                                         sizeof(AVFilmGrainParams));
     if (!side_data)
         return NULL;
 
-    memset(side_data->data, 0, sizeof(AVFilmGrainParams));
+    fgp = (AVFilmGrainParams *) side_data->data;
+    *fgp = (AVFilmGrainParams) {
+        .color_range     = AVCOL_RANGE_UNSPECIFIED,
+        .color_primaries = AVCOL_PRI_UNSPECIFIED,
+        .color_trc       = AVCOL_TRC_UNSPECIFIED,
+        .color_space     = AVCOL_SPC_UNSPECIFIED,
+    };
 
-    return (AVFilmGrainParams *)side_data->data;
+    return fgp;
+}
+
+const AVFilmGrainParams *av_film_grain_params_select(const AVFrame *frame)
+{
+    const AVFilmGrainParams *fgp, *best = NULL;
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
+    int bit_depth_luma, bit_depth_chroma;
+    if (!desc)
+        return NULL;
+
+    /* There are no YUV formats with different bit depth per component,
+     * so just check both against the first component for simplicity */
+    bit_depth_luma = bit_depth_chroma = desc->comp[0].depth;
+
+    for (int i = 0; i < frame->nb_side_data; i++) {
+        if (frame->side_data[i]->type != AV_FRAME_DATA_FILM_GRAIN_PARAMS)
+            continue;
+        fgp = (const AVFilmGrainParams*)frame->side_data[i]->data;
+        if (fgp->width  && fgp->width  > frame->width ||
+            fgp->height && fgp->height > frame->height)
+            continue;
+
+#define CHECK(a, b, unspec)                                     \
+        if ((a) != (unspec) && (b) != (unspec) && (a) != (b))   \
+            continue
+
+        CHECK(fgp->bit_depth_luma,   bit_depth_luma,         0);
+        CHECK(fgp->bit_depth_chroma, bit_depth_chroma,       0);
+        CHECK(fgp->color_range,      frame->color_range,     AVCOL_RANGE_UNSPECIFIED);
+        CHECK(fgp->color_primaries,  frame->color_primaries, AVCOL_PRI_UNSPECIFIED);
+        CHECK(fgp->color_trc,        frame->color_trc,       AVCOL_TRC_UNSPECIFIED);
+        CHECK(fgp->color_space,      frame->colorspace,      AVCOL_SPC_UNSPECIFIED);
+
+        switch (fgp->type) {
+        case AV_FILM_GRAIN_PARAMS_NONE:
+            continue;
+        case AV_FILM_GRAIN_PARAMS_AV1:
+            /* AOM FGS needs an exact match for the chroma resolution */
+            if (fgp->subsampling_x != desc->log2_chroma_w ||
+                fgp->subsampling_y != desc->log2_chroma_h)
+                continue;
+            break;
+        case AV_FILM_GRAIN_PARAMS_H274:
+            /* H.274 FGS can be adapted to any lower chroma resolution */
+            if (fgp->subsampling_x > desc->log2_chroma_w ||
+                fgp->subsampling_y > desc->log2_chroma_h)
+                continue;
+            break;
+        }
+
+        if (!best || best->width < fgp->width || best->height < fgp->height)
+            best = fgp;
+    }
+
+    return best;
 }
diff --git a/media/ffvpx/libavutil/film_grain_params.h b/media/ffvpx/libavutil/film_grain_params.h
index f3bd0a4a6a345..ccacab88fed93 100644
--- a/media/ffvpx/libavutil/film_grain_params.h
+++ b/media/ffvpx/libavutil/film_grain_params.h
@@ -136,20 +136,42 @@ typedef struct AVFilmGrainH274Params {
      */
     int model_id;
 
-    /**
-     * Specifies the bit depth used for the luma component.
-     */
+#if FF_API_H274_FILM_GRAIN_VCS
+  /**
+   * TODO: On this ABI bump, please also re-order the fields in
+   * AVFilmGrainParams (see below)
+   */
+
+  /**
+   * Specifies the bit depth used for the luma component.
+   *
+   * @deprecated use AVFilmGrainParams.bit_depth_luma.
+   */
+    attribute_deprecated
     int bit_depth_luma;
 
     /**
      * Specifies the bit depth used for the chroma components.
+     *
+     * @deprecated use AVFilmGrainParams.bit_depth_chroma.
      */
+    attribute_deprecated
     int bit_depth_chroma;
 
+    /**
+     * Specifies the video signal characteristics.
+     *
+     * @deprecated use AVFilmGrainParams.color_{range,primaries,trc,space}.
+     */
+    attribute_deprecated
     enum AVColorRange                  color_range;
+    attribute_deprecated
     enum AVColorPrimaries              color_primaries;
+    attribute_deprecated
     enum AVColorTransferCharacteristic color_trc;
+    attribute_deprecated
     enum AVColorSpace                  color_space;
+#endif
 
     /**
      * Specifies the blending mode used to blend the simulated film grain
@@ -231,11 +253,40 @@ typedef struct AVFilmGrainParams {
      * Additional fields may be added both here and in any structure included.
      * If a codec's film grain structure differs slightly over another
      * codec's, fields within may change meaning depending on the type.
+     *
+     * TODO: Move this to the end of the structure, at the next ABI bump.
      */
     union {
         AVFilmGrainAOMParams aom;
         AVFilmGrainH274Params h274;
     } codec;
+
+    /**
+     * Intended display resolution. May be 0 if the codec does not specify
+     * any restrictions.
+     */
+
+    int width, height;
+
+    /**
+     * Intended subsampling ratio, or 0 for luma-only streams.
+     */
+    int subsampling_x, subsampling_y;
+
+    /**
+     * Intended video signal characteristics.
+     */
+    enum AVColorRange                  color_range;
+    enum AVColorPrimaries              color_primaries;
+    enum AVColorTransferCharacteristic color_trc;
+    enum AVColorSpace                  color_space;
+
+    /**
+     * Intended bit depth, or 0 for unknown/unspecified.
+     */
+    int bit_depth_luma;
+    int bit_depth_chroma;
+
 } AVFilmGrainParams;
 
 /**
@@ -257,4 +308,15 @@ AVFilmGrainParams *av_film_grain_params_alloc(size_t *size);
  */
 AVFilmGrainParams *av_film_grain_params_create_side_data(AVFrame *frame);
 
+/**
+ * Select the most appropriate film grain parameters set for the frame,
+ * taking into account the frame's format, resolution and video signal
+ * characteristics.
+ *
+ * @note, for H.274, this may select a film grain parameter set with
+ * greater chroma resolution than the frame. Users should take care to
+ * correctly adjust the chroma grain frequency to the frame.
+ */
+const AVFilmGrainParams *av_film_grain_params_select(const AVFrame *frame);
+
 #endif /* AVUTIL_FILM_GRAIN_PARAMS_H */
diff --git a/media/ffvpx/libavutil/fixed_dsp.c b/media/ffvpx/libavutil/fixed_dsp.c
index 5ab47d55d06e6..95f0eb2595499 100644
--- a/media/ffvpx/libavutil/fixed_dsp.c
+++ b/media/ffvpx/libavutil/fixed_dsp.c
@@ -47,6 +47,7 @@
 
 #include "common.h"
 #include "fixed_dsp.h"
+#include "mem.h"
 
 static void vector_fmul_add_c(int *dst, const int *src0, const int *src1, const int *src2, int len){
     int i;
@@ -135,7 +136,7 @@ static int scalarproduct_fixed_c(const int *v1, const int *v2, int len)
     return (int)(p >> 31);
 }
 
-static void butterflies_fixed_c(int *av_restrict v1s, int *av_restrict v2, int len)
+static void butterflies_fixed_c(int *restrict v1s, int *restrict v2, int len)
 {
     int i;
     unsigned int *v1 = v1s;
diff --git a/media/ffvpx/libavutil/fixed_dsp.h b/media/ffvpx/libavutil/fixed_dsp.h
index 1217d3a53bf5b..9b566af675813 100644
--- a/media/ffvpx/libavutil/fixed_dsp.h
+++ b/media/ffvpx/libavutil/fixed_dsp.h
@@ -49,7 +49,6 @@
 #define AVUTIL_FIXED_DSP_H
 
 #include <stdint.h>
-#include "config.h"
 #include "attributes.h"
 #include "libavcodec/mathops.h"
 
@@ -150,7 +149,7 @@ typedef struct AVFixedDSPContext {
      * @param v2  second input vector, difference output, 16-byte aligned
      * @param len length of vectors, multiple of 4
      */
-    void (*butterflies_fixed)(int *av_restrict v1, int *av_restrict v2, int len);
+    void (*butterflies_fixed)(int *restrict v1, int *restrict v2, int len);
 } AVFixedDSPContext;
 
 /**
diff --git a/media/ffvpx/libavutil/float_dsp.c b/media/ffvpx/libavutil/float_dsp.c
index 742dd679d243f..e9fb02346654f 100644
--- a/media/ffvpx/libavutil/float_dsp.c
+++ b/media/ffvpx/libavutil/float_dsp.c
@@ -109,7 +109,7 @@ static void vector_fmul_reverse_c(float *dst, const float *src0,
         dst[i] = src0[i] * src1[-i];
 }
 
-static void butterflies_float_c(float *av_restrict v1, float *av_restrict v2,
+static void butterflies_float_c(float *restrict v1, float *restrict v2,
                                 int len)
 {
     int i;
diff --git a/media/ffvpx/libavutil/float_dsp.h b/media/ffvpx/libavutil/float_dsp.h
index 7cad9fc622d52..342a8715c5077 100644
--- a/media/ffvpx/libavutil/float_dsp.h
+++ b/media/ffvpx/libavutil/float_dsp.h
@@ -19,8 +19,6 @@
 #ifndef AVUTIL_FLOAT_DSP_H
 #define AVUTIL_FLOAT_DSP_H
 
-#include "config.h"
-
 typedef struct AVFloatDSPContext {
     /**
      * Calculate the entry wise product of two vectors of floats and store the result in
@@ -161,7 +159,7 @@ typedef struct AVFloatDSPContext {
      * @param v2  second input vector, difference output, 16-byte aligned
      * @param len length of vectors, multiple of 4
      */
-    void (*butterflies_float)(float *av_restrict v1, float *av_restrict v2, int len);
+    void (*butterflies_float)(float *restrict v1, float *restrict v2, int len);
 
     /**
      * Calculate the scalar product of two vectors of floats.
diff --git a/media/ffvpx/libavutil/frame.c b/media/ffvpx/libavutil/frame.c
index a3f07ca089211..930f01dc19c79 100644
--- a/media/ffvpx/libavutil/frame.c
+++ b/media/ffvpx/libavutil/frame.c
@@ -28,12 +28,35 @@
 #include "samplefmt.h"
 #include "hwcontext.h"
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-#define CHECK_CHANNELS_CONSISTENCY(frame) \
-    av_assert2(!(frame)->channel_layout || \
-               (frame)->channels == \
-               av_get_channel_layout_nb_channels((frame)->channel_layout))
-#endif
+static const AVSideDataDescriptor sd_props[] = {
+    [AV_FRAME_DATA_PANSCAN]                     = { "AVPanScan" },
+    [AV_FRAME_DATA_A53_CC]                      = { "ATSC A53 Part 4 Closed Captions" },
+    [AV_FRAME_DATA_MATRIXENCODING]              = { "AVMatrixEncoding" },
+    [AV_FRAME_DATA_DOWNMIX_INFO]                = { "Metadata relevant to a downmix procedure" },
+    [AV_FRAME_DATA_AFD]                         = { "Active format description" },
+    [AV_FRAME_DATA_MOTION_VECTORS]              = { "Motion vectors" },
+    [AV_FRAME_DATA_SKIP_SAMPLES]                = { "Skip samples" },
+    [AV_FRAME_DATA_GOP_TIMECODE]                = { "GOP timecode" },
+    [AV_FRAME_DATA_S12M_TIMECODE]               = { "SMPTE 12-1 timecode" },
+    [AV_FRAME_DATA_DYNAMIC_HDR_PLUS]            = { "HDR Dynamic Metadata SMPTE2094-40 (HDR10+)" },
+    [AV_FRAME_DATA_DYNAMIC_HDR_VIVID]           = { "HDR Dynamic Metadata CUVA 005.1 2021 (Vivid)" },
+    [AV_FRAME_DATA_REGIONS_OF_INTEREST]         = { "Regions Of Interest" },
+    [AV_FRAME_DATA_VIDEO_ENC_PARAMS]            = { "Video encoding parameters" },
+    [AV_FRAME_DATA_FILM_GRAIN_PARAMS]           = { "Film grain parameters" },
+    [AV_FRAME_DATA_DETECTION_BBOXES]            = { "Bounding boxes for object detection and classification" },
+    [AV_FRAME_DATA_DOVI_RPU_BUFFER]             = { "Dolby Vision RPU Data" },
+    [AV_FRAME_DATA_DOVI_METADATA]               = { "Dolby Vision Metadata" },
+    [AV_FRAME_DATA_STEREO3D]                    = { "Stereo 3D",                                    AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_REPLAYGAIN]                  = { "AVReplayGain",                                 AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_DISPLAYMATRIX]               = { "3x3 displaymatrix",                            AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_AUDIO_SERVICE_TYPE]          = { "Audio service type",                           AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_MASTERING_DISPLAY_METADATA]  = { "Mastering display metadata",                   AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_CONTENT_LIGHT_LEVEL]         = { "Content light level metadata",                 AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT] = { "Ambient viewing environment",                  AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_SPHERICAL]                   = { "Spherical Mapping",                            AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_ICC_PROFILE]                 = { "ICC profile",                                  AV_SIDE_DATA_PROP_GLOBAL },
+    [AV_FRAME_DATA_SEI_UNREGISTERED]            = { "H.26[45] User Data Unregistered SEI message",  AV_SIDE_DATA_PROP_MULTI },
+};
 
 static void get_frame_defaults(AVFrame *frame)
 {
@@ -43,11 +66,6 @@ static void get_frame_defaults(AVFrame *frame)
     frame->pkt_dts               = AV_NOPTS_VALUE;
     frame->best_effort_timestamp = AV_NOPTS_VALUE;
     frame->duration            = 0;
-#if FF_API_PKT_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    frame->pkt_duration        = 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 #if FF_API_FRAME_PKT
 FF_DISABLE_DEPRECATION_WARNINGS
     frame->pkt_pos             = -1;
@@ -75,14 +93,56 @@ static void free_side_data(AVFrameSideData **ptr_sd)
     av_freep(ptr_sd);
 }
 
-static void wipe_side_data(AVFrame *frame)
+static void wipe_side_data(AVFrameSideData ***sd, int *nb_side_data)
 {
-    for (int i = 0; i < frame->nb_side_data; i++) {
-        free_side_data(&frame->side_data[i]);
+    for (int i = 0; i < *nb_side_data; i++) {
+        free_side_data(&((*sd)[i]));
     }
-    frame->nb_side_data = 0;
+    *nb_side_data = 0;
+
+    av_freep(sd);
+}
 
-    av_freep(&frame->side_data);
+static void frame_side_data_wipe(AVFrame *frame)
+{
+    wipe_side_data(&frame->side_data, &frame->nb_side_data);
+}
+
+void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
+{
+    wipe_side_data(sd, nb_sd);
+}
+
+static void remove_side_data(AVFrameSideData ***sd, int *nb_side_data,
+                             const enum AVFrameSideDataType type)
+{
+    for (int i = *nb_side_data - 1; i >= 0; i--) {
+        AVFrameSideData *entry = ((*sd)[i]);
+        if (entry->type != type)
+            continue;
+
+        free_side_data(&entry);
+
+        ((*sd)[i]) = ((*sd)[*nb_side_data - 1]);
+        (*nb_side_data)--;
+    }
+}
+
+static void remove_side_data_by_entry(AVFrameSideData ***sd, int *nb_sd,
+                                      const AVFrameSideData *target)
+{
+    for (int i = *nb_sd - 1; i >= 0; i--) {
+        AVFrameSideData *entry = ((*sd)[i]);
+        if (entry != target)
+            continue;
+
+        free_side_data(&entry);
+
+        ((*sd)[i]) = ((*sd)[*nb_sd - 1]);
+        (*nb_sd)--;
+
+        return;
+    }
 }
 
 AVFrame *av_frame_alloc(void)
@@ -181,21 +241,6 @@ static int get_audio_buffer(AVFrame *frame, int align)
     int channels, planes;
     int ret;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!frame->ch_layout.nb_channels) {
-        if (frame->channel_layout) {
-            av_channel_layout_from_mask(&frame->ch_layout, frame->channel_layout);
-        } else {
-            frame->ch_layout.nb_channels = frame->channels;
-            frame->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-        }
-    }
-    frame->channels = frame->ch_layout.nb_channels;
-    frame->channel_layout = frame->ch_layout.order == AV_CHANNEL_ORDER_NATIVE ?
-                            frame->ch_layout.u.mask : 0;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     channels = frame->ch_layout.nb_channels;
     planes   = planar ? channels : 1;
     if (!frame->linesize[0]) {
@@ -245,17 +290,11 @@ int av_frame_get_buffer(AVFrame *frame, int align)
     if (frame->format < 0)
         return AVERROR(EINVAL);
 
-FF_DISABLE_DEPRECATION_WARNINGS
     if (frame->width > 0 && frame->height > 0)
         return get_video_buffer(frame, align);
     else if (frame->nb_samples > 0 &&
-             (av_channel_layout_check(&frame->ch_layout)
-#if FF_API_OLD_CHANNEL_LAYOUT
-              || frame->channel_layout || frame->channels > 0
-#endif
-             ))
+             (av_channel_layout_check(&frame->ch_layout)))
         return get_audio_buffer(frame, align);
-FF_ENABLE_DEPRECATION_WARNINGS
 
     return AVERROR(EINVAL);
 }
@@ -297,26 +336,10 @@ FF_DISABLE_DEPRECATION_WARNINGS
     dst->pkt_pos                = src->pkt_pos;
     dst->pkt_size               = src->pkt_size;
 FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-#if FF_API_PKT_DURATION
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->pkt_duration           = src->pkt_duration;
-FF_ENABLE_DEPRECATION_WARNINGS
 #endif
     dst->time_base              = src->time_base;
-#if FF_API_REORDERED_OPAQUE
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->reordered_opaque       = src->reordered_opaque;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     dst->quality                = src->quality;
     dst->best_effort_timestamp  = src->best_effort_timestamp;
-#if FF_API_FRAME_PICTURE_NUMBER
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->coded_picture_number   = src->coded_picture_number;
-    dst->display_picture_number = src->display_picture_number;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     dst->flags                  = src->flags;
     dst->decode_error_flags     = src->decode_error_flags;
     dst->color_primaries        = src->color_primaries;
@@ -337,7 +360,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
             sd_dst = av_frame_new_side_data(dst, sd_src->type,
                                             sd_src->size);
             if (!sd_dst) {
-                wipe_side_data(dst);
+                frame_side_data_wipe(dst);
                 return AVERROR(ENOMEM);
             }
             memcpy(sd_dst->data, sd_src->data, sd_src->size);
@@ -346,7 +369,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
             sd_dst = av_frame_new_side_data_from_buf(dst, sd_src->type, ref);
             if (!sd_dst) {
                 av_buffer_unref(&ref);
-                wipe_side_data(dst);
+                frame_side_data_wipe(dst);
                 return AVERROR(ENOMEM);
             }
         }
@@ -363,11 +386,6 @@ int av_frame_ref(AVFrame *dst, const AVFrame *src)
     int ret = 0;
 
     av_assert1(dst->width == 0 && dst->height == 0);
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_assert1(dst->channels == 0);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     av_assert1(dst->ch_layout.nb_channels == 0 &&
                dst->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);
 
@@ -375,31 +393,14 @@ FF_ENABLE_DEPRECATION_WARNINGS
     dst->width          = src->width;
     dst->height         = src->height;
     dst->nb_samples     = src->nb_samples;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->channels       = src->channels;
-    dst->channel_layout = src->channel_layout;
-    if (!av_channel_layout_check(&src->ch_layout)) {
-        if (src->channel_layout)
-            av_channel_layout_from_mask(&dst->ch_layout, src->channel_layout);
-        else {
-            dst->ch_layout.nb_channels = src->channels;
-            dst->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-        }
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
     ret = frame_copy_props(dst, src, 0);
     if (ret < 0)
         goto fail;
 
-    // this check is needed only until FF_API_OLD_CHANNEL_LAYOUT is out
-    if (av_channel_layout_check(&src->ch_layout)) {
-        ret = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
-        if (ret < 0)
-            goto fail;
-    }
+    ret = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
+    if (ret < 0)
+        goto fail;
 
     /* duplicate the frame data if it's not refcounted */
     if (!src->buf[0]) {
@@ -503,29 +504,12 @@ int av_frame_replace(AVFrame *dst, const AVFrame *src)
     dst->width          = src->width;
     dst->height         = src->height;
     dst->nb_samples     = src->nb_samples;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    dst->channels       = src->channels;
-    dst->channel_layout = src->channel_layout;
-    if (!av_channel_layout_check(&src->ch_layout)) {
-        av_channel_layout_uninit(&dst->ch_layout);
-        if (src->channel_layout)
-            av_channel_layout_from_mask(&dst->ch_layout, src->channel_layout);
-        else {
-            dst->ch_layout.nb_channels = src->channels;
-            dst->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-        }
-    } else {
-#endif
+
     ret = av_channel_layout_copy(&dst->ch_layout, &src->ch_layout);
     if (ret < 0)
         goto fail;
-#if FF_API_OLD_CHANNEL_LAYOUT
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
 
-    wipe_side_data(dst);
+    frame_side_data_wipe(dst);
     av_dict_free(&dst->metadata);
     ret = frame_copy_props(dst, src, 0);
     if (ret < 0)
@@ -624,7 +608,7 @@ void av_frame_unref(AVFrame *frame)
     if (!frame)
         return;
 
-    wipe_side_data(frame);
+    frame_side_data_wipe(frame);
 
     for (int i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)
         av_buffer_unref(&frame->buf[i]);
@@ -649,11 +633,6 @@ void av_frame_unref(AVFrame *frame)
 void av_frame_move_ref(AVFrame *dst, AVFrame *src)
 {
     av_assert1(dst->width == 0 && dst->height == 0);
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    av_assert1(dst->channels == 0);
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     av_assert1(dst->ch_layout.nb_channels == 0 &&
                dst->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC);
 
@@ -692,12 +671,6 @@ int av_frame_make_writable(AVFrame *frame)
     tmp.format         = frame->format;
     tmp.width          = frame->width;
     tmp.height         = frame->height;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    tmp.channels       = frame->channels;
-    tmp.channel_layout = frame->channel_layout;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     tmp.nb_samples     = frame->nb_samples;
     ret = av_channel_layout_copy(&tmp.ch_layout, &frame->ch_layout);
     if (ret < 0) {
@@ -745,15 +718,6 @@ AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
 
     if (frame->nb_samples) {
         int channels = frame->ch_layout.nb_channels;
-
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-        if (!channels) {
-            channels = frame->channels;
-            CHECK_CHANNELS_CONSISTENCY(frame);
-        }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         if (!channels)
             return NULL;
         planes = av_sample_fmt_is_planar(frame->format) ? channels : 1;
@@ -777,38 +741,57 @@ FF_ENABLE_DEPRECATION_WARNINGS
     return NULL;
 }
 
-AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame,
-                                                 enum AVFrameSideDataType type,
-                                                 AVBufferRef *buf)
+static AVFrameSideData *add_side_data_from_buf_ext(AVFrameSideData ***sd,
+                                                   int *nb_sd,
+                                                   enum AVFrameSideDataType type,
+                                                   AVBufferRef *buf, uint8_t *data,
+                                                   size_t size)
 {
     AVFrameSideData *ret, **tmp;
 
-    if (!buf)
-        return NULL;
-
-    if (frame->nb_side_data > INT_MAX / sizeof(*frame->side_data) - 1)
+    // *nb_sd + 1 needs to fit into an int and a size_t.
+    if ((unsigned)*nb_sd >= FFMIN(INT_MAX, SIZE_MAX))
         return NULL;
 
-    tmp = av_realloc(frame->side_data,
-                     (frame->nb_side_data + 1) * sizeof(*frame->side_data));
+    tmp = av_realloc_array(*sd, sizeof(**sd), *nb_sd + 1);
     if (!tmp)
         return NULL;
-    frame->side_data = tmp;
+    *sd = tmp;
 
     ret = av_mallocz(sizeof(*ret));
     if (!ret)
         return NULL;
 
     ret->buf = buf;
-    ret->data = ret->buf->data;
-    ret->size = buf->size;
+    ret->data = data;
+    ret->size = size;
     ret->type = type;
 
-    frame->side_data[frame->nb_side_data++] = ret;
+    (*sd)[(*nb_sd)++] = ret;
 
     return ret;
 }
 
+static AVFrameSideData *add_side_data_from_buf(AVFrameSideData ***sd,
+                                               int *nb_sd,
+                                               enum AVFrameSideDataType type,
+                                               AVBufferRef *buf)
+{
+    if (!buf)
+        return NULL;
+
+    return add_side_data_from_buf_ext(sd, nb_sd, type, buf, buf->data, buf->size);
+}
+
+AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame,
+                                                 enum AVFrameSideDataType type,
+                                                 AVBufferRef *buf)
+{
+    return
+        add_side_data_from_buf(
+            &frame->side_data, &frame->nb_side_data, type, buf);
+}
+
 AVFrameSideData *av_frame_new_side_data(AVFrame *frame,
                                         enum AVFrameSideDataType type,
                                         size_t size)
@@ -821,16 +804,76 @@ AVFrameSideData *av_frame_new_side_data(AVFrame *frame,
     return ret;
 }
 
-AVFrameSideData *av_frame_get_side_data(const AVFrame *frame,
-                                        enum AVFrameSideDataType type)
+AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd,
+                                        enum AVFrameSideDataType type,
+                                        size_t size, unsigned int flags)
+{
+    AVBufferRef     *buf = av_buffer_alloc(size);
+    AVFrameSideData *ret = NULL;
+
+    if (flags & AV_FRAME_SIDE_DATA_FLAG_UNIQUE)
+        remove_side_data(sd, nb_sd, type);
+
+    ret = add_side_data_from_buf(sd, nb_sd, type, buf);
+    if (!ret)
+        av_buffer_unref(&buf);
+
+    return ret;
+}
+
+int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd,
+                             const AVFrameSideData *src, unsigned int flags)
+{
+    AVBufferRef     *buf    = NULL;
+    AVFrameSideData *sd_dst = NULL;
+    int              ret    = AVERROR_BUG;
+
+    if (!sd || !src || !nb_sd || (*nb_sd && !*sd))
+        return AVERROR(EINVAL);
+
+    buf = av_buffer_ref(src->buf);
+    if (!buf)
+        return AVERROR(ENOMEM);
+
+    if (flags & AV_FRAME_SIDE_DATA_FLAG_UNIQUE)
+        remove_side_data(sd, nb_sd, src->type);
+
+    sd_dst = add_side_data_from_buf_ext(sd, nb_sd, src->type, buf,
+                                        src->data, src->size);
+    if (!sd_dst) {
+        av_buffer_unref(&buf);
+        return AVERROR(ENOMEM);
+    }
+
+    ret = av_dict_copy(&sd_dst->metadata, src->metadata, 0);
+    if (ret < 0) {
+        remove_side_data_by_entry(sd, nb_sd, sd_dst);
+        return ret;
+    }
+
+    return 0;
+}
+
+const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData * const *sd,
+                                                const int nb_sd,
+                                                enum AVFrameSideDataType type)
 {
-    for (int i = 0; i < frame->nb_side_data; i++) {
-        if (frame->side_data[i]->type == type)
-            return frame->side_data[i];
+    for (int i = 0; i < nb_sd; i++) {
+        if (sd[i]->type == type)
+            return sd[i];
     }
     return NULL;
 }
 
+AVFrameSideData *av_frame_get_side_data(const AVFrame *frame,
+                                        enum AVFrameSideDataType type)
+{
+    return (AVFrameSideData *)av_frame_side_data_get(
+        frame->side_data, frame->nb_side_data,
+        type
+    );
+}
+
 static int frame_copy_video(AVFrame *dst, const AVFrame *src)
 {
     int planes;
@@ -860,30 +903,8 @@ static int frame_copy_audio(AVFrame *dst, const AVFrame *src)
     int channels = dst->ch_layout.nb_channels;
     int planes   = planar ? channels : 1;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!channels || !src->ch_layout.nb_channels) {
-        if (dst->channels       != src->channels ||
-            dst->channel_layout != src->channel_layout)
-            return AVERROR(EINVAL);
-        CHECK_CHANNELS_CONSISTENCY(src);
-    }
-    if (!channels) {
-        channels = dst->channels;
-        planes = planar ? channels : 1;
-    }
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
     if (dst->nb_samples != src->nb_samples ||
-#if FF_API_OLD_CHANNEL_LAYOUT
-        (av_channel_layout_check(&dst->ch_layout) &&
-         av_channel_layout_check(&src->ch_layout) &&
-#endif
         av_channel_layout_compare(&dst->ch_layout, &src->ch_layout))
-#if FF_API_OLD_CHANNEL_LAYOUT
-        )
-#endif
         return AVERROR(EINVAL);
 
     for (int i = 0; i < planes; i++)
@@ -901,67 +922,34 @@ int av_frame_copy(AVFrame *dst, const AVFrame *src)
     if (dst->format != src->format || dst->format < 0)
         return AVERROR(EINVAL);
 
-FF_DISABLE_DEPRECATION_WARNINGS
     if (dst->width > 0 && dst->height > 0)
         return frame_copy_video(dst, src);
     else if (dst->nb_samples > 0 &&
-             (av_channel_layout_check(&dst->ch_layout)
-#if FF_API_OLD_CHANNEL_LAYOUT
-              || dst->channels > 0
-#endif
-            ))
+             (av_channel_layout_check(&dst->ch_layout)))
         return frame_copy_audio(dst, src);
-FF_ENABLE_DEPRECATION_WARNINGS
 
     return AVERROR(EINVAL);
 }
 
 void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
 {
-    for (int i = frame->nb_side_data - 1; i >= 0; i--) {
-        AVFrameSideData *sd = frame->side_data[i];
-        if (sd->type == type) {
-            free_side_data(&frame->side_data[i]);
-            frame->side_data[i] = frame->side_data[frame->nb_side_data - 1];
-            frame->nb_side_data--;
-        }
-    }
+    remove_side_data(&frame->side_data, &frame->nb_side_data, type);
 }
 
-const char *av_frame_side_data_name(enum AVFrameSideDataType type)
+const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
 {
-    switch(type) {
-    case AV_FRAME_DATA_PANSCAN:         return "AVPanScan";
-    case AV_FRAME_DATA_A53_CC:          return "ATSC A53 Part 4 Closed Captions";
-    case AV_FRAME_DATA_STEREO3D:        return "Stereo 3D";
-    case AV_FRAME_DATA_MATRIXENCODING:  return "AVMatrixEncoding";
-    case AV_FRAME_DATA_DOWNMIX_INFO:    return "Metadata relevant to a downmix procedure";
-    case AV_FRAME_DATA_REPLAYGAIN:      return "AVReplayGain";
-    case AV_FRAME_DATA_DISPLAYMATRIX:   return "3x3 displaymatrix";
-    case AV_FRAME_DATA_AFD:             return "Active format description";
-    case AV_FRAME_DATA_MOTION_VECTORS:  return "Motion vectors";
-    case AV_FRAME_DATA_SKIP_SAMPLES:    return "Skip samples";
-    case AV_FRAME_DATA_AUDIO_SERVICE_TYPE:          return "Audio service type";
-    case AV_FRAME_DATA_MASTERING_DISPLAY_METADATA:  return "Mastering display metadata";
-    case AV_FRAME_DATA_CONTENT_LIGHT_LEVEL:         return "Content light level metadata";
-    case AV_FRAME_DATA_GOP_TIMECODE:                return "GOP timecode";
-    case AV_FRAME_DATA_S12M_TIMECODE:               return "SMPTE 12-1 timecode";
-    case AV_FRAME_DATA_SPHERICAL:                   return "Spherical Mapping";
-    case AV_FRAME_DATA_ICC_PROFILE:                 return "ICC profile";
-    case AV_FRAME_DATA_DYNAMIC_HDR_PLUS: return "HDR Dynamic Metadata SMPTE2094-40 (HDR10+)";
-    case AV_FRAME_DATA_DYNAMIC_HDR_VIVID: return "HDR Dynamic Metadata CUVA 005.1 2021 (Vivid)";
-    case AV_FRAME_DATA_REGIONS_OF_INTEREST: return "Regions Of Interest";
-    case AV_FRAME_DATA_VIDEO_ENC_PARAMS:            return "Video encoding parameters";
-    case AV_FRAME_DATA_SEI_UNREGISTERED:            return "H.26[45] User Data Unregistered SEI message";
-    case AV_FRAME_DATA_FILM_GRAIN_PARAMS:           return "Film grain parameters";
-    case AV_FRAME_DATA_DETECTION_BBOXES:            return "Bounding boxes for object detection and classification";
-    case AV_FRAME_DATA_DOVI_RPU_BUFFER:             return "Dolby Vision RPU Data";
-    case AV_FRAME_DATA_DOVI_METADATA:               return "Dolby Vision Metadata";
-    case AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT: return "Ambient viewing environment";
-    }
+    unsigned t = type;
+    if (t < FF_ARRAY_ELEMS(sd_props) && sd_props[t].name)
+        return &sd_props[t];
     return NULL;
 }
 
+const char *av_frame_side_data_name(enum AVFrameSideDataType type)
+{
+    const AVSideDataDescriptor *desc = av_frame_side_data_desc(type);
+    return desc ? desc->name : NULL;
+}
+
 static int calc_cropping_offsets(size_t offsets[4], const AVFrame *frame,
                                  const AVPixFmtDescriptor *desc)
 {
diff --git a/media/ffvpx/libavutil/frame.h b/media/ffvpx/libavutil/frame.h
index c0c1b23db7ced..3b6d746a16d92 100644
--- a/media/ffvpx/libavutil/frame.h
+++ b/media/ffvpx/libavutil/frame.h
@@ -180,6 +180,10 @@ enum AVFrameSideDataType {
     /**
      * Film grain parameters for a frame, described by AVFilmGrainParams.
      * Must be present for every frame which should have film grain applied.
+     *
+     * May be present multiple times, for example when there are multiple
+     * alternative parameter sets for different video signal characteristics.
+     * The user should select the most appropriate set for the application.
      */
     AV_FRAME_DATA_FILM_GRAIN_PARAMS,
 
@@ -251,6 +255,37 @@ typedef struct AVFrameSideData {
     AVBufferRef *buf;
 } AVFrameSideData;
 
+enum AVSideDataProps {
+    /**
+     * The side data type can be used in stream-global structures.
+     * Side data types without this property are only meaningful on per-frame
+     * basis.
+     */
+    AV_SIDE_DATA_PROP_GLOBAL = (1 << 0),
+
+    /**
+     * Multiple instances of this side data type can be meaningfully present in
+     * a single side data array.
+     */
+    AV_SIDE_DATA_PROP_MULTI  = (1 << 1),
+};
+
+/**
+ * This struct describes the properties of a side data type. Its instance
+ * corresponding to a given type can be obtained from av_frame_side_data_desc().
+ */
+typedef struct AVSideDataDescriptor {
+    /**
+     * Human-readable side data description.
+     */
+    const char      *name;
+
+    /**
+     * Side data property flags, a combination of AVSideDataProps values.
+     */
+    unsigned         props;
+} AVSideDataDescriptor;
+
 /**
  * Structure describing a single Region Of Interest.
  *
@@ -466,19 +501,6 @@ typedef struct AVFrame {
      */
     AVRational time_base;
 
-#if FF_API_FRAME_PICTURE_NUMBER
-    /**
-     * picture number in bitstream order
-     */
-    attribute_deprecated
-    int coded_picture_number;
-    /**
-     * picture number in display order
-     */
-    attribute_deprecated
-    int display_picture_number;
-#endif
-
     /**
      * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
      */
@@ -546,35 +568,11 @@ typedef struct AVFrame {
     int palette_has_changed;
 #endif
 
-#if FF_API_REORDERED_OPAQUE
-    /**
-     * reordered opaque 64 bits (generally an integer or a double precision float
-     * PTS but can be anything).
-     * The user sets AVCodecContext.reordered_opaque to represent the input at
-     * that time,
-     * the decoder reorders values as needed and sets AVFrame.reordered_opaque
-     * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
-     *
-     * @deprecated Use AV_CODEC_FLAG_COPY_OPAQUE instead
-     */
-    attribute_deprecated
-    int64_t reordered_opaque;
-#endif
-
     /**
      * Sample rate of the audio data.
      */
     int sample_rate;
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * Channel layout of the audio data.
-     * @deprecated use ch_layout instead
-     */
-    attribute_deprecated
-    uint64_t channel_layout;
-#endif
-
     /**
      * AVBuffer references backing the data for this frame. All the pointers in
      * data and extended_data must point inside one of the buffers in buf or
@@ -687,19 +685,6 @@ typedef struct AVFrame {
     int64_t pkt_pos;
 #endif
 
-#if FF_API_PKT_DURATION
-    /**
-     * duration of the corresponding packet, expressed in
-     * AVStream->time_base units, 0 if unknown.
-     * - encoding: unused
-     * - decoding: Read by user.
-     *
-     * @deprecated use duration instead
-     */
-    attribute_deprecated
-    int64_t pkt_duration;
-#endif
-
     /**
      * metadata.
      * - encoding: Set by user.
@@ -720,17 +705,6 @@ typedef struct AVFrame {
 #define FF_DECODE_ERROR_CONCEALMENT_ACTIVE  4
 #define FF_DECODE_ERROR_DECODE_SLICES       8
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-    /**
-     * number of audio channels, only used for audio.
-     * - encoding: unused
-     * - decoding: Read by user.
-     * @deprecated use ch_layout instead
-     */
-    attribute_deprecated
-    int channels;
-#endif
-
 #if FF_API_FRAME_PKT
     /**
      * size of the corresponding packet containing the compressed
@@ -1049,6 +1023,94 @@ int av_frame_apply_cropping(AVFrame *frame, int flags);
  */
 const char *av_frame_side_data_name(enum AVFrameSideDataType type);
 
+/**
+ * @return side data descriptor corresponding to a given side data type, NULL
+ *         when not available.
+ */
+const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type);
+
+/**
+ * Free all side data entries and their contents, then zeroes out the
+ * values which the pointers are pointing to.
+ *
+ * @param sd    pointer to array of side data to free. Will be set to NULL
+ *              upon return.
+ * @param nb_sd pointer to an integer containing the number of entries in
+ *              the array. Will be set to 0 upon return.
+ */
+void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd);
+
+#define AV_FRAME_SIDE_DATA_FLAG_UNIQUE (1 << 0)
+
+/**
+ * Add new side data entry to an array.
+ *
+ * @param sd    pointer to array of side data to which to add another entry,
+ *              or to NULL in order to start a new array.
+ * @param nb_sd pointer to an integer containing the number of entries in
+ *              the array.
+ * @param type  type of the added side data
+ * @param size  size of the side data
+ * @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.
+ *
+ * @return newly added side data on success, NULL on error. In case of
+ *         AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching
+ *         AVFrameSideDataType will be removed before the addition is
+ *         attempted.
+ */
+AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd,
+                                        enum AVFrameSideDataType type,
+                                        size_t size, unsigned int flags);
+
+/**
+ * Add a new side data entry to an array based on existing side data, taking
+ * a reference towards the contained AVBufferRef.
+ *
+ * @param sd    pointer to array of side data to which to add another entry,
+ *              or to NULL in order to start a new array.
+ * @param nb_sd pointer to an integer containing the number of entries in
+ *              the array.
+ * @param src   side data to be cloned, with a new reference utilized
+ *              for the buffer.
+ * @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.
+ *
+ * @return negative error code on failure, >=0 on success. In case of
+ *         AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of matching
+ *         AVFrameSideDataType will be removed before the addition is
+ *         attempted.
+ */
+int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd,
+                             const AVFrameSideData *src, unsigned int flags);
+
+/**
+ * Get a side data entry of a specific type from an array.
+ *
+ * @param sd    array of side data.
+ * @param nb_sd integer containing the number of entries in the array.
+ * @param type  type of side data to be queried
+ *
+ * @return a pointer to the side data of a given type on success, NULL if there
+ *         is no side data with such type in this set.
+ */
+const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData * const *sd,
+                                                const int nb_sd,
+                                                enum AVFrameSideDataType type);
+
+/**
+ * Wrapper around av_frame_side_data_get_c() to workaround the limitation
+ * that for any type T the conversion from T * const * to const T * const *
+ * is not performed automatically in C.
+ * @see av_frame_side_data_get_c()
+ */
+static inline
+const AVFrameSideData *av_frame_side_data_get(AVFrameSideData * const *sd,
+                                              const int nb_sd,
+                                              enum AVFrameSideDataType type)
+{
+    return av_frame_side_data_get_c((const AVFrameSideData * const *)sd,
+                                    nb_sd, type);
+}
+
 /**
  * @}
  */
diff --git a/media/ffvpx/libavutil/hdr_dynamic_metadata.h b/media/ffvpx/libavutil/hdr_dynamic_metadata.h
index 09e9d8bbccf4b..5100ed6f41f71 100644
--- a/media/ffvpx/libavutil/hdr_dynamic_metadata.h
+++ b/media/ffvpx/libavutil/hdr_dynamic_metadata.h
@@ -359,13 +359,13 @@ int av_dynamic_hdr_plus_from_t35(AVDynamicHDRPlus *s, const uint8_t *data,
  * Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer,
  * excluding the first 48 bytes of the header, and beginning with the application mode.
  * @param s A pointer containing the decoded AVDynamicHDRPlus structure.
- * @param data[in,out] A pointer to pointer to a byte buffer to be filled with the
+ * @param[in,out] data A pointer to pointer to a byte buffer to be filled with the
  *                     serialized metadata.
  *                     If *data is NULL, a buffer be will be allocated and a pointer to
  *                     it stored in its place. The caller assumes ownership of the buffer.
  *                     May be NULL, in which case the function will only store the
  *                     required buffer size in *size.
- * @param size[in,out] A pointer to a size to be set to the returned buffer's size.
+ * @param[in,out] size A pointer to a size to be set to the returned buffer's size.
  *                     If *data is not NULL, *size must contain the size of the input
  *                     buffer. May be NULL only if *data is NULL.
  *
diff --git a/media/ffvpx/libavutil/hwcontext.c b/media/ffvpx/libavutil/hwcontext.c
index e23bad230fff5..fa99a0d8a40ed 100644
--- a/media/ffvpx/libavutil/hwcontext.c
+++ b/media/ffvpx/libavutil/hwcontext.c
@@ -84,6 +84,21 @@ static const char *const hw_type_names[] = {
     [AV_HWDEVICE_TYPE_VULKAN] = "vulkan",
 };
 
+typedef struct FFHWDeviceContext {
+    /**
+     * The public AVHWDeviceContext. See hwcontext.h for it.
+     */
+    AVHWDeviceContext p;
+
+    const HWContextType *hw_type;
+
+    /**
+     * For a derived device, a reference to the original device
+     * context it was derived from.
+     */
+    AVBufferRef *source_device;
+} FFHWDeviceContext;
+
 enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
 {
     int type;
@@ -126,26 +141,26 @@ static const AVClass hwdevice_ctx_class = {
 
 static void hwdevice_ctx_free(void *opaque, uint8_t *data)
 {
-    AVHWDeviceContext *ctx = (AVHWDeviceContext*)data;
+    FFHWDeviceContext *ctxi = (FFHWDeviceContext*)data;
+    AVHWDeviceContext *ctx  = &ctxi->p;
 
     /* uninit might still want access the hw context and the user
      * free() callback might destroy it, so uninit has to be called first */
-    if (ctx->internal->hw_type->device_uninit)
-        ctx->internal->hw_type->device_uninit(ctx);
+    if (ctxi->hw_type->device_uninit)
+        ctxi->hw_type->device_uninit(ctx);
 
     if (ctx->free)
         ctx->free(ctx);
 
-    av_buffer_unref(&ctx->internal->source_device);
+    av_buffer_unref(&ctxi->source_device);
 
     av_freep(&ctx->hwctx);
-    av_freep(&ctx->internal->priv);
-    av_freep(&ctx->internal);
     av_freep(&ctx);
 }
 
 AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
 {
+    FFHWDeviceContext *ctxi;
     AVHWDeviceContext *ctx;
     AVBufferRef *buf;
     const HWContextType *hw_type = NULL;
@@ -160,19 +175,10 @@ AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     if (!hw_type)
         return NULL;
 
-    ctx = av_mallocz(sizeof(*ctx));
-    if (!ctx)
+    ctxi = av_mallocz(sizeof(*ctxi));
+    if (!ctxi)
         return NULL;
-
-    ctx->internal = av_mallocz(sizeof(*ctx->internal));
-    if (!ctx->internal)
-        goto fail;
-
-    if (hw_type->device_priv_size) {
-        ctx->internal->priv = av_mallocz(hw_type->device_priv_size);
-        if (!ctx->internal->priv)
-            goto fail;
-    }
+    ctx = &ctxi->p;
 
     if (hw_type->device_hwctx_size) {
         ctx->hwctx = av_mallocz(hw_type->device_hwctx_size);
@@ -189,14 +195,11 @@ AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     ctx->type     = type;
     ctx->av_class = &hwdevice_ctx_class;
 
-    ctx->internal->hw_type = hw_type;
+    ctxi->hw_type = hw_type;
 
     return buf;
 
 fail:
-    if (ctx->internal)
-        av_freep(&ctx->internal->priv);
-    av_freep(&ctx->internal);
     av_freep(&ctx->hwctx);
     av_freep(&ctx);
     return NULL;
@@ -204,19 +207,13 @@ AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
 
 int av_hwdevice_ctx_init(AVBufferRef *ref)
 {
-    AVHWDeviceContext *ctx = (AVHWDeviceContext*)ref->data;
-    int ret;
+    FFHWDeviceContext *ctxi = (FFHWDeviceContext*)ref->data;
+    AVHWDeviceContext *ctx  = &ctxi->p;
+    int ret = 0;
 
-    if (ctx->internal->hw_type->device_init) {
-        ret = ctx->internal->hw_type->device_init(ctx);
-        if (ret < 0)
-            goto fail;
-    }
+    if (ctxi->hw_type->device_init)
+        ret = ctxi->hw_type->device_init(ctx);
 
-    return 0;
-fail:
-    if (ctx->internal->hw_type->device_uninit)
-        ctx->internal->hw_type->device_uninit(ctx);
     return ret;
 }
 
@@ -228,47 +225,38 @@ static const AVClass hwframe_ctx_class = {
 
 static void hwframe_ctx_free(void *opaque, uint8_t *data)
 {
-    AVHWFramesContext *ctx = (AVHWFramesContext*)data;
+    FFHWFramesContext *ctxi = (FFHWFramesContext*)data;
+    AVHWFramesContext *ctx  = &ctxi->p;
 
-    if (ctx->internal->pool_internal)
-        av_buffer_pool_uninit(&ctx->internal->pool_internal);
+    if (ctxi->pool_internal)
+        av_buffer_pool_uninit(&ctxi->pool_internal);
 
-    if (ctx->internal->hw_type->frames_uninit)
-        ctx->internal->hw_type->frames_uninit(ctx);
+    if (ctxi->hw_type->frames_uninit)
+        ctxi->hw_type->frames_uninit(ctx);
 
     if (ctx->free)
         ctx->free(ctx);
 
-    av_buffer_unref(&ctx->internal->source_frames);
+    av_buffer_unref(&ctxi->source_frames);
 
     av_buffer_unref(&ctx->device_ref);
 
     av_freep(&ctx->hwctx);
-    av_freep(&ctx->internal->priv);
-    av_freep(&ctx->internal);
     av_freep(&ctx);
 }
 
 AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ref_in)
 {
-    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)device_ref_in->data;
-    const HWContextType  *hw_type = device_ctx->internal->hw_type;
+    FFHWDeviceContext *device_ctx = (FFHWDeviceContext*)device_ref_in->data;
+    const HWContextType  *hw_type = device_ctx->hw_type;
+    FFHWFramesContext *ctxi;
     AVHWFramesContext *ctx;
     AVBufferRef *buf, *device_ref = NULL;
 
-    ctx = av_mallocz(sizeof(*ctx));
-    if (!ctx)
+    ctxi = av_mallocz(sizeof(*ctxi));
+    if (!ctxi)
         return NULL;
-
-    ctx->internal = av_mallocz(sizeof(*ctx->internal));
-    if (!ctx->internal)
-        goto fail;
-
-    if (hw_type->frames_priv_size) {
-        ctx->internal->priv = av_mallocz(hw_type->frames_priv_size);
-        if (!ctx->internal->priv)
-            goto fail;
-    }
+    ctx  = &ctxi->p;
 
     if (hw_type->frames_hwctx_size) {
         ctx->hwctx = av_mallocz(hw_type->frames_hwctx_size);
@@ -288,20 +276,16 @@ AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ref_in)
 
     ctx->av_class   = &hwframe_ctx_class;
     ctx->device_ref = device_ref;
-    ctx->device_ctx = device_ctx;
+    ctx->device_ctx = &device_ctx->p;
     ctx->format     = AV_PIX_FMT_NONE;
     ctx->sw_format  = AV_PIX_FMT_NONE;
 
-    ctx->internal->hw_type = hw_type;
+    ctxi->hw_type = hw_type;
 
     return buf;
 
 fail:
-    if (device_ref)
-        av_buffer_unref(&device_ref);
-    if (ctx->internal)
-        av_freep(&ctx->internal->priv);
-    av_freep(&ctx->internal);
+    av_buffer_unref(&device_ref);
     av_freep(&ctx->hwctx);
     av_freep(&ctx);
     return NULL;
@@ -337,24 +321,25 @@ static int hwframe_pool_prealloc(AVBufferRef *ref)
 
 int av_hwframe_ctx_init(AVBufferRef *ref)
 {
-    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;
+    FFHWFramesContext *ctxi = (FFHWFramesContext*)ref->data;
+    AVHWFramesContext *ctx  = &ctxi->p;
     const enum AVPixelFormat *pix_fmt;
     int ret;
 
-    if (ctx->internal->source_frames) {
+    if (ctxi->source_frames) {
         /* A derived frame context is already initialised. */
         return 0;
     }
 
     /* validate the pixel format */
-    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {
+    for (pix_fmt = ctxi->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {
         if (*pix_fmt == ctx->format)
             break;
     }
     if (*pix_fmt == AV_PIX_FMT_NONE) {
         av_log(ctx, AV_LOG_ERROR,
                "The hardware pixel format '%s' is not supported by the device type '%s'\n",
-               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);
+               av_get_pix_fmt_name(ctx->format), ctxi->hw_type->name);
         return AVERROR(ENOSYS);
     }
 
@@ -364,39 +349,35 @@ int av_hwframe_ctx_init(AVBufferRef *ref)
         return ret;
 
     /* format-specific init */
-    if (ctx->internal->hw_type->frames_init) {
-        ret = ctx->internal->hw_type->frames_init(ctx);
+    if (ctxi->hw_type->frames_init) {
+        ret = ctxi->hw_type->frames_init(ctx);
         if (ret < 0)
-            goto fail;
+            return ret;
     }
 
-    if (ctx->internal->pool_internal && !ctx->pool)
-        ctx->pool = ctx->internal->pool_internal;
+    if (ctxi->pool_internal && !ctx->pool)
+        ctx->pool = ctxi->pool_internal;
 
     /* preallocate the frames in the pool, if requested */
     if (ctx->initial_pool_size > 0) {
         ret = hwframe_pool_prealloc(ref);
         if (ret < 0)
-            goto fail;
+            return ret;
     }
 
     return 0;
-fail:
-    if (ctx->internal->hw_type->frames_uninit)
-        ctx->internal->hw_type->frames_uninit(ctx);
-    return ret;
 }
 
 int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ref,
                                     enum AVHWFrameTransferDirection dir,
                                     enum AVPixelFormat **formats, int flags)
 {
-    AVHWFramesContext *ctx = (AVHWFramesContext*)hwframe_ref->data;
+    FFHWFramesContext *ctxi = (FFHWFramesContext*)hwframe_ref->data;
 
-    if (!ctx->internal->hw_type->transfer_get_formats)
+    if (!ctxi->hw_type->transfer_get_formats)
         return AVERROR(ENOSYS);
 
-    return ctx->internal->hw_type->transfer_get_formats(ctx, dir, formats);
+    return ctxi->hw_type->transfer_get_formats(&ctxi->p, dir, formats);
 }
 
 static int transfer_data_alloc(AVFrame *dst, const AVFrame *src, int flags)
@@ -451,7 +432,6 @@ static int transfer_data_alloc(AVFrame *dst, const AVFrame *src, int flags)
 
 int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
 {
-    AVHWFramesContext *ctx;
     int ret;
 
     if (!dst->buf[0])
@@ -464,41 +444,41 @@ int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
      * the specific combination of hardware.
      */
     if (src->hw_frames_ctx && dst->hw_frames_ctx) {
-        AVHWFramesContext *src_ctx =
-            (AVHWFramesContext*)src->hw_frames_ctx->data;
-        AVHWFramesContext *dst_ctx =
-            (AVHWFramesContext*)dst->hw_frames_ctx->data;
+        FFHWFramesContext *src_ctx =
+            (FFHWFramesContext*)src->hw_frames_ctx->data;
+        FFHWFramesContext *dst_ctx =
+            (FFHWFramesContext*)dst->hw_frames_ctx->data;
 
-        if (src_ctx->internal->source_frames) {
+        if (src_ctx->source_frames) {
             av_log(src_ctx, AV_LOG_ERROR,
                    "A device with a derived frame context cannot be used as "
                    "the source of a HW -> HW transfer.");
             return AVERROR(ENOSYS);
         }
 
-        if (dst_ctx->internal->source_frames) {
+        if (dst_ctx->source_frames) {
             av_log(src_ctx, AV_LOG_ERROR,
                    "A device with a derived frame context cannot be used as "
                    "the destination of a HW -> HW transfer.");
             return AVERROR(ENOSYS);
         }
 
-        ret = src_ctx->internal->hw_type->transfer_data_from(src_ctx, dst, src);
+        ret = src_ctx->hw_type->transfer_data_from(&src_ctx->p, dst, src);
         if (ret == AVERROR(ENOSYS))
-            ret = dst_ctx->internal->hw_type->transfer_data_to(dst_ctx, dst, src);
+            ret = dst_ctx->hw_type->transfer_data_to(&dst_ctx->p, dst, src);
         if (ret < 0)
             return ret;
     } else {
         if (src->hw_frames_ctx) {
-            ctx = (AVHWFramesContext*)src->hw_frames_ctx->data;
+            FFHWFramesContext *ctx = (FFHWFramesContext*)src->hw_frames_ctx->data;
 
-            ret = ctx->internal->hw_type->transfer_data_from(ctx, dst, src);
+            ret = ctx->hw_type->transfer_data_from(&ctx->p, dst, src);
             if (ret < 0)
                 return ret;
         } else if (dst->hw_frames_ctx) {
-            ctx = (AVHWFramesContext*)dst->hw_frames_ctx->data;
+            FFHWFramesContext *ctx = (FFHWFramesContext*)dst->hw_frames_ctx->data;
 
-            ret = ctx->internal->hw_type->transfer_data_to(ctx, dst, src);
+            ret = ctx->hw_type->transfer_data_to(&ctx->p, dst, src);
             if (ret < 0)
                 return ret;
         } else {
@@ -510,10 +490,11 @@ int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
 
 int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
 {
-    AVHWFramesContext *ctx = (AVHWFramesContext*)hwframe_ref->data;
+    FFHWFramesContext *ctxi = (FFHWFramesContext*)hwframe_ref->data;
+    AVHWFramesContext *ctx  = &ctxi->p;
     int ret;
 
-    if (ctx->internal->source_frames) {
+    if (ctxi->source_frames) {
         // This is a derived frame context, so we allocate in the source
         // and map the frame immediately.
         AVFrame *src_frame;
@@ -527,7 +508,7 @@ int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
         if (!src_frame)
             return AVERROR(ENOMEM);
 
-        ret = av_hwframe_get_buffer(ctx->internal->source_frames,
+        ret = av_hwframe_get_buffer(ctxi->source_frames,
                                     src_frame, 0);
         if (ret < 0) {
             av_frame_free(&src_frame);
@@ -535,7 +516,7 @@ int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
         }
 
         ret = av_hwframe_map(frame, src_frame,
-                             ctx->internal->source_allocation_map_flags);
+                             ctxi->source_allocation_map_flags);
         if (ret) {
             av_log(ctx, AV_LOG_ERROR, "Failed to map frame into derived "
                    "frame context: %d.\n", ret);
@@ -550,7 +531,7 @@ int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
         return 0;
     }
 
-    if (!ctx->internal->hw_type->frames_get_buffer)
+    if (!ctxi->hw_type->frames_get_buffer)
         return AVERROR(ENOSYS);
 
     if (!ctx->pool)
@@ -560,7 +541,7 @@ int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
     if (!frame->hw_frames_ctx)
         return AVERROR(ENOMEM);
 
-    ret = ctx->internal->hw_type->frames_get_buffer(ctx, frame);
+    ret = ctxi->hw_type->frames_get_buffer(ctx, frame);
     if (ret < 0) {
         av_buffer_unref(&frame->hw_frames_ctx);
         return ret;
@@ -573,8 +554,8 @@ int av_hwframe_get_buffer(AVBufferRef *hwframe_ref, AVFrame *frame, int flags)
 
 void *av_hwdevice_hwconfig_alloc(AVBufferRef *ref)
 {
-    AVHWDeviceContext *ctx = (AVHWDeviceContext*)ref->data;
-    const HWContextType  *hw_type = ctx->internal->hw_type;
+    FFHWDeviceContext *ctx = (FFHWDeviceContext*)ref->data;
+    const HWContextType  *hw_type = ctx->hw_type;
 
     if (hw_type->device_hwconfig_size == 0)
         return NULL;
@@ -585,8 +566,8 @@ void *av_hwdevice_hwconfig_alloc(AVBufferRef *ref)
 AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref,
                                                            const void *hwconfig)
 {
-    AVHWDeviceContext *ctx = (AVHWDeviceContext*)ref->data;
-    const HWContextType  *hw_type = ctx->internal->hw_type;
+    FFHWDeviceContext *ctx = (FFHWDeviceContext*)ref->data;
+    const HWContextType  *hw_type = ctx->hw_type;
     AVHWFramesConstraints *constraints;
 
     if (!hw_type->frames_get_constraints)
@@ -599,7 +580,7 @@ AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref,
     constraints->min_width = constraints->min_height = 0;
     constraints->max_width = constraints->max_height = INT_MAX;
 
-    if (hw_type->frames_get_constraints(ctx, hwconfig, constraints) >= 0) {
+    if (hw_type->frames_get_constraints(&ctx->p, hwconfig, constraints) >= 0) {
         return constraints;
     } else {
         av_hwframe_constraints_free(&constraints);
@@ -620,7 +601,7 @@ int av_hwdevice_ctx_create(AVBufferRef **pdevice_ref, enum AVHWDeviceType type,
                            const char *device, AVDictionary *opts, int flags)
 {
     AVBufferRef *device_ref = NULL;
-    AVHWDeviceContext *device_ctx;
+    FFHWDeviceContext *device_ctx;
     int ret = 0;
 
     device_ref = av_hwdevice_ctx_alloc(type);
@@ -628,15 +609,15 @@ int av_hwdevice_ctx_create(AVBufferRef **pdevice_ref, enum AVHWDeviceType type,
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-    device_ctx = (AVHWDeviceContext*)device_ref->data;
+    device_ctx = (FFHWDeviceContext*)device_ref->data;
 
-    if (!device_ctx->internal->hw_type->device_create) {
+    if (!device_ctx->hw_type->device_create) {
         ret = AVERROR(ENOSYS);
         goto fail;
     }
 
-    ret = device_ctx->internal->hw_type->device_create(device_ctx, device,
-                                                       opts, flags);
+    ret = device_ctx->hw_type->device_create(&device_ctx->p, device,
+                                             opts, flags);
     if (ret < 0)
         goto fail;
 
@@ -658,13 +639,13 @@ int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ref_ptr,
                                         AVDictionary *options, int flags)
 {
     AVBufferRef *dst_ref = NULL, *tmp_ref;
-    AVHWDeviceContext *dst_ctx, *tmp_ctx;
+    FFHWDeviceContext *dst_ctx;
     int ret = 0;
 
     tmp_ref = src_ref;
     while (tmp_ref) {
-        tmp_ctx = (AVHWDeviceContext*)tmp_ref->data;
-        if (tmp_ctx->type == type) {
+        FFHWDeviceContext *tmp_ctx = (FFHWDeviceContext*)tmp_ref->data;
+        if (tmp_ctx->p.type == type) {
             dst_ref = av_buffer_ref(tmp_ref);
             if (!dst_ref) {
                 ret = AVERROR(ENOMEM);
@@ -672,7 +653,7 @@ int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ref_ptr,
             }
             goto done;
         }
-        tmp_ref = tmp_ctx->internal->source_device;
+        tmp_ref = tmp_ctx->source_device;
     }
 
     dst_ref = av_hwdevice_ctx_alloc(type);
@@ -680,19 +661,18 @@ int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ref_ptr,
         ret = AVERROR(ENOMEM);
         goto fail;
     }
-    dst_ctx = (AVHWDeviceContext*)dst_ref->data;
+    dst_ctx = (FFHWDeviceContext*)dst_ref->data;
 
     tmp_ref = src_ref;
     while (tmp_ref) {
-        tmp_ctx = (AVHWDeviceContext*)tmp_ref->data;
-        if (dst_ctx->internal->hw_type->device_derive) {
-            ret = dst_ctx->internal->hw_type->device_derive(dst_ctx,
-                                                            tmp_ctx,
-                                                            options,
-                                                            flags);
+        FFHWDeviceContext *tmp_ctx = (FFHWDeviceContext*)tmp_ref->data;
+        if (dst_ctx->hw_type->device_derive) {
+            ret = dst_ctx->hw_type->device_derive(&dst_ctx->p,
+                                                  &tmp_ctx->p,
+                                                  options, flags);
             if (ret == 0) {
-                dst_ctx->internal->source_device = av_buffer_ref(src_ref);
-                if (!dst_ctx->internal->source_device) {
+                dst_ctx->source_device = av_buffer_ref(src_ref);
+                if (!dst_ctx->source_device) {
                     ret = AVERROR(ENOMEM);
                     goto fail;
                 }
@@ -704,7 +684,7 @@ int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ref_ptr,
             if (ret != AVERROR(ENOSYS))
                 goto fail;
         }
-        tmp_ref = tmp_ctx->internal->source_device;
+        tmp_ref = tmp_ctx->source_device;
     }
 
     ret = AVERROR(ENOSYS);
@@ -799,19 +779,18 @@ int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
 {
     AVBufferRef    *orig_dst_frames = dst->hw_frames_ctx;
     enum AVPixelFormat orig_dst_fmt = dst->format;
-    AVHWFramesContext *src_frames, *dst_frames;
     HWMapDescriptor *hwmap;
     int ret;
 
     if (src->hw_frames_ctx && dst->hw_frames_ctx) {
-        src_frames = (AVHWFramesContext*)src->hw_frames_ctx->data;
-        dst_frames = (AVHWFramesContext*)dst->hw_frames_ctx->data;
+        FFHWFramesContext *src_frames = (FFHWFramesContext*)src->hw_frames_ctx->data;
+        FFHWFramesContext *dst_frames = (FFHWFramesContext*)dst->hw_frames_ctx->data;
 
         if ((src_frames == dst_frames &&
-             src->format == dst_frames->sw_format &&
-             dst->format == dst_frames->format) ||
-            (src_frames->internal->source_frames &&
-             src_frames->internal->source_frames->data ==
+             src->format == dst_frames->p.sw_format &&
+             dst->format == dst_frames->p.format) ||
+            (src_frames->source_frames &&
+             src_frames->source_frames->data ==
              (uint8_t*)dst_frames)) {
             // This is an unmap operation.  We don't need to directly
             // do anything here other than fill in the original frame,
@@ -828,12 +807,12 @@ int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     }
 
     if (src->hw_frames_ctx) {
-        src_frames = (AVHWFramesContext*)src->hw_frames_ctx->data;
+        FFHWFramesContext *src_frames = (FFHWFramesContext*)src->hw_frames_ctx->data;
 
-        if (src_frames->format == src->format &&
-            src_frames->internal->hw_type->map_from) {
-            ret = src_frames->internal->hw_type->map_from(src_frames,
-                                                          dst, src, flags);
+        if (src_frames->p.format == src->format &&
+            src_frames->hw_type->map_from) {
+            ret = src_frames->hw_type->map_from(&src_frames->p,
+                                                dst, src, flags);
             if (ret >= 0)
                 return ret;
             else if (ret != AVERROR(ENOSYS))
@@ -842,12 +821,12 @@ int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     }
 
     if (dst->hw_frames_ctx) {
-        dst_frames = (AVHWFramesContext*)dst->hw_frames_ctx->data;
+        FFHWFramesContext *dst_frames = (FFHWFramesContext*)dst->hw_frames_ctx->data;
 
-        if (dst_frames->format == dst->format &&
-            dst_frames->internal->hw_type->map_to) {
-            ret = dst_frames->internal->hw_type->map_to(dst_frames,
-                                                        dst, src, flags);
+        if (dst_frames->p.format == dst->format &&
+            dst_frames->hw_type->map_to) {
+            ret = dst_frames->hw_type->map_to(&dst_frames->p,
+                                              dst, src, flags);
             if (ret >= 0)
                 return ret;
             else if (ret != AVERROR(ENOSYS))
@@ -881,21 +860,21 @@ int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,
                                   int flags)
 {
     AVBufferRef   *dst_ref = NULL;
-    AVHWFramesContext *dst = NULL;
-    AVHWFramesContext *src = (AVHWFramesContext*)source_frame_ctx->data;
+    FFHWFramesContext *dsti = NULL;
+    FFHWFramesContext *srci = (FFHWFramesContext*)source_frame_ctx->data;
+    AVHWFramesContext *dst, *src = &srci->p;
     int ret;
 
-    if (src->internal->source_frames) {
+    if (srci->source_frames) {
         AVHWFramesContext *src_src =
-            (AVHWFramesContext*)src->internal->source_frames->data;
+            (AVHWFramesContext*)srci->source_frames->data;
         AVHWDeviceContext *dst_dev =
             (AVHWDeviceContext*)derived_device_ctx->data;
 
         if (src_src->device_ctx == dst_dev) {
             // This is actually an unmapping, so we just return a
             // reference to the source frame context.
-            *derived_frame_ctx =
-                av_buffer_ref(src->internal->source_frames);
+            *derived_frame_ctx = av_buffer_ref(srci->source_frames);
             if (!*derived_frame_ctx) {
                 ret = AVERROR(ENOMEM);
                 goto fail;
@@ -910,31 +889,32 @@ int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,
         goto fail;
     }
 
-    dst = (AVHWFramesContext*)dst_ref->data;
+    dsti = (FFHWFramesContext*)dst_ref->data;
+    dst  = &dsti->p;
 
     dst->format    = format;
     dst->sw_format = src->sw_format;
     dst->width     = src->width;
     dst->height    = src->height;
 
-    dst->internal->source_frames = av_buffer_ref(source_frame_ctx);
-    if (!dst->internal->source_frames) {
+    dsti->source_frames = av_buffer_ref(source_frame_ctx);
+    if (!dsti->source_frames) {
         ret = AVERROR(ENOMEM);
         goto fail;
     }
 
-    dst->internal->source_allocation_map_flags =
+    dsti->source_allocation_map_flags =
         flags & (AV_HWFRAME_MAP_READ      |
                  AV_HWFRAME_MAP_WRITE     |
                  AV_HWFRAME_MAP_OVERWRITE |
                  AV_HWFRAME_MAP_DIRECT);
 
     ret = AVERROR(ENOSYS);
-    if (src->internal->hw_type->frames_derive_from)
-        ret = src->internal->hw_type->frames_derive_from(dst, src, flags);
+    if (srci->hw_type->frames_derive_from)
+        ret = srci->hw_type->frames_derive_from(dst, src, flags);
     if (ret == AVERROR(ENOSYS) &&
-        dst->internal->hw_type->frames_derive_to)
-        ret = dst->internal->hw_type->frames_derive_to(dst, src, flags);
+        dsti->hw_type->frames_derive_to)
+        ret = dsti->hw_type->frames_derive_to(dst, src, flags);
     if (ret == AVERROR(ENOSYS))
         ret = 0;
     if (ret)
@@ -944,8 +924,8 @@ int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx,
     return 0;
 
 fail:
-    if (dst)
-        av_buffer_unref(&dst->internal->source_frames);
+    if (dsti)
+        av_buffer_unref(&dsti->source_frames);
     av_buffer_unref(&dst_ref);
     return ret;
 }
diff --git a/media/ffvpx/libavutil/hwcontext.h b/media/ffvpx/libavutil/hwcontext.h
index 2b33721a973ba..bac30debaed54 100644
--- a/media/ffvpx/libavutil/hwcontext.h
+++ b/media/ffvpx/libavutil/hwcontext.h
@@ -40,8 +40,6 @@ enum AVHWDeviceType {
     AV_HWDEVICE_TYPE_D3D12VA,
 };
 
-typedef struct AVHWDeviceInternal AVHWDeviceInternal;
-
 /**
  * This struct aggregates all the (hardware/vendor-specific) "high-level" state,
  * i.e. state that is not tied to a concrete processing configuration.
@@ -65,12 +63,6 @@ typedef struct AVHWDeviceContext {
      */
     const AVClass *av_class;
 
-    /**
-     * Private data used internally by libavutil. Must not be accessed in any
-     * way by the caller.
-     */
-    AVHWDeviceInternal *internal;
-
     /**
      * This field identifies the underlying API used for hardware access.
      *
@@ -110,8 +102,6 @@ typedef struct AVHWDeviceContext {
     void *user_opaque;
 } AVHWDeviceContext;
 
-typedef struct AVHWFramesInternal AVHWFramesInternal;
-
 /**
  * This struct describes a set or pool of "hardware" frames (i.e. those with
  * data not located in normal system memory). All the frames in the pool are
@@ -128,12 +118,6 @@ typedef struct AVHWFramesContext {
      */
     const AVClass *av_class;
 
-    /**
-     * Private data used internally by libavutil. Must not be accessed in any
-     * way by the caller.
-     */
-    AVHWFramesInternal *internal;
-
     /**
      * A reference to the parent AVHWDeviceContext. This reference is owned and
      * managed by the enclosing AVHWFramesContext, but the caller may derive
@@ -153,9 +137,12 @@ typedef struct AVHWFramesContext {
      * The format-specific data, allocated and freed automatically along with
      * this context.
      *
-     * Should be cast by the user to the format-specific context defined in the
-     * corresponding header (hwframe_*.h) and filled as described in the
-     * documentation before calling av_hwframe_ctx_init().
+     * The user shall ignore this field if the corresponding format-specific
+     * header (hwcontext_*.h) does not define a context to be used as
+     * AVHWFramesContext.hwctx.
+     *
+     * Otherwise, it should be cast by the user to said context and filled
+     * as described in the documentation before calling av_hwframe_ctx_init().
      *
      * After any frames using this context are created, the contents of this
      * struct should not be modified by the caller.
diff --git a/media/ffvpx/libavutil/hwcontext_internal.h b/media/ffvpx/libavutil/hwcontext_internal.h
index 4df516ee6a471..e32b786238160 100644
--- a/media/ffvpx/libavutil/hwcontext_internal.h
+++ b/media/ffvpx/libavutil/hwcontext_internal.h
@@ -41,11 +41,6 @@ typedef struct HWContextType {
      * i.e. AVHWDeviceContext.hwctx
      */
     size_t             device_hwctx_size;
-    /**
-     * size of the private data, i.e.
-     * AVHWDeviceInternal.priv
-     */
-    size_t             device_priv_size;
 
     /**
      * Size of the hardware-specific device configuration.
@@ -58,11 +53,6 @@ typedef struct HWContextType {
      * i.e. AVHWFramesContext.hwctx
      */
     size_t             frames_hwctx_size;
-    /**
-     * size of the private data, i.e.
-     * AVHWFramesInternal.priv
-     */
-    size_t             frames_priv_size;
 
     int              (*device_create)(AVHWDeviceContext *ctx, const char *device,
                                       AVDictionary *opts, int flags);
@@ -100,20 +90,13 @@ typedef struct HWContextType {
                                            AVHWFramesContext *src_ctx, int flags);
 } HWContextType;
 
-struct AVHWDeviceInternal {
-    const HWContextType *hw_type;
-    void                *priv;
-
+typedef struct FFHWFramesContext {
     /**
-     * For a derived device, a reference to the original device
-     * context it was derived from.
+     * The public AVHWFramesContext. See hwcontext.h for it.
      */
-    AVBufferRef *source_device;
-};
+    AVHWFramesContext p;
 
-struct AVHWFramesInternal {
     const HWContextType *hw_type;
-    void                *priv;
 
     AVBufferPool *pool_internal;
 
@@ -127,7 +110,12 @@ struct AVHWFramesInternal {
      * frame context when trying to allocate in the derived context.
      */
     int source_allocation_map_flags;
-};
+} FFHWFramesContext;
+
+static inline FFHWFramesContext *ffhwframesctx(AVHWFramesContext *ctx)
+{
+    return (FFHWFramesContext*)ctx;
+}
 
 typedef struct HWMapDescriptor {
     /**
diff --git a/media/ffvpx/libavutil/hwcontext_vaapi.c b/media/ffvpx/libavutil/hwcontext_vaapi.c
index 29fc8bd64831d..56d03aa4cdd3a 100644
--- a/media/ffvpx/libavutil/hwcontext_vaapi.c
+++ b/media/ffvpx/libavutil/hwcontext_vaapi.c
@@ -75,12 +75,22 @@ typedef struct VAAPISurfaceFormat {
 } VAAPISurfaceFormat;
 
 typedef struct VAAPIDeviceContext {
+    /**
+     * The public AVVAAPIDeviceContext. See hwcontext_vaapi.h for it.
+     */
+    AVVAAPIDeviceContext p;
+
     // Surface formats which can be used with this device.
     VAAPISurfaceFormat *formats;
     int              nb_formats;
 } VAAPIDeviceContext;
 
 typedef struct VAAPIFramesContext {
+    /**
+     * The public AVVAAPIFramesContext. See hwcontext_vaapi.h for it.
+     */
+    AVVAAPIFramesContext p;
+
     // Surface attributes set at create time.
     VASurfaceAttrib *attributes;
     int           nb_attributes;
@@ -207,7 +217,7 @@ static int vaapi_get_image_format(AVHWDeviceContext *hwdev,
                                   enum AVPixelFormat pix_fmt,
                                   VAImageFormat **image_format)
 {
-    VAAPIDeviceContext *ctx = hwdev->internal->priv;
+    VAAPIDeviceContext *ctx = hwdev->hwctx;
     int i;
 
     for (i = 0; i < ctx->nb_formats; i++) {
@@ -224,9 +234,9 @@ static int vaapi_frames_get_constraints(AVHWDeviceContext *hwdev,
                                         const void *hwconfig,
                                         AVHWFramesConstraints *constraints)
 {
-    AVVAAPIDeviceContext *hwctx = hwdev->hwctx;
+    VAAPIDeviceContext *ctx = hwdev->hwctx;
+    AVVAAPIDeviceContext *hwctx = &ctx->p;
     const AVVAAPIHWConfig *config = hwconfig;
-    VAAPIDeviceContext *ctx = hwdev->internal->priv;
     VASurfaceAttrib *attr_list = NULL;
     VAStatus vas;
     enum AVPixelFormat pix_fmt;
@@ -384,8 +394,8 @@ static const struct {
 
 static int vaapi_device_init(AVHWDeviceContext *hwdev)
 {
-    VAAPIDeviceContext *ctx = hwdev->internal->priv;
-    AVVAAPIDeviceContext *hwctx = hwdev->hwctx;
+    VAAPIDeviceContext *ctx = hwdev->hwctx;
+    AVVAAPIDeviceContext *hwctx = &ctx->p;
     VAImageFormat *image_list = NULL;
     VAStatus vas;
     const char *vendor_string;
@@ -474,7 +484,7 @@ static int vaapi_device_init(AVHWDeviceContext *hwdev)
 
 static void vaapi_device_uninit(AVHWDeviceContext *hwdev)
 {
-    VAAPIDeviceContext *ctx = hwdev->internal->priv;
+    VAAPIDeviceContext *ctx = hwdev->hwctx;
 
     av_freep(&ctx->formats);
 }
@@ -498,9 +508,9 @@ static void vaapi_buffer_free(void *opaque, uint8_t *data)
 static AVBufferRef *vaapi_pool_alloc(void *opaque, size_t size)
 {
     AVHWFramesContext     *hwfc = opaque;
-    VAAPIFramesContext     *ctx = hwfc->internal->priv;
+    VAAPIFramesContext     *ctx = hwfc->hwctx;
+    AVVAAPIFramesContext  *avfc = &ctx->p;
     AVVAAPIDeviceContext *hwctx = hwfc->device_ctx->hwctx;
-    AVVAAPIFramesContext  *avfc = hwfc->hwctx;
     VASurfaceID surface_id;
     VAStatus vas;
     AVBufferRef *ref;
@@ -541,8 +551,8 @@ static AVBufferRef *vaapi_pool_alloc(void *opaque, size_t size)
 
 static int vaapi_frames_init(AVHWFramesContext *hwfc)
 {
-    AVVAAPIFramesContext  *avfc = hwfc->hwctx;
-    VAAPIFramesContext     *ctx = hwfc->internal->priv;
+    VAAPIFramesContext     *ctx = hwfc->hwctx;
+    AVVAAPIFramesContext  *avfc = &ctx->p;
     AVVAAPIDeviceContext *hwctx = hwfc->device_ctx->hwctx;
     const VAAPIFormatDescriptor *desc;
     VAImageFormat *expected_format;
@@ -623,10 +633,10 @@ static int vaapi_frames_init(AVHWFramesContext *hwfc)
             avfc->surface_ids = NULL;
         }
 
-        hwfc->internal->pool_internal =
+        ffhwframesctx(hwfc)->pool_internal =
             av_buffer_pool_init2(sizeof(VASurfaceID), hwfc,
                                  &vaapi_pool_alloc, NULL);
-        if (!hwfc->internal->pool_internal) {
+        if (!ffhwframesctx(hwfc)->pool_internal) {
             av_log(hwfc, AV_LOG_ERROR, "Failed to create VAAPI surface pool.\n");
             err = AVERROR(ENOMEM);
             goto fail;
@@ -644,7 +654,7 @@ static int vaapi_frames_init(AVHWFramesContext *hwfc)
             goto fail;
         }
     } else {
-        test_surface = av_buffer_pool_get(hwfc->internal->pool_internal);
+        test_surface = av_buffer_pool_get(ffhwframesctx(hwfc)->pool_internal);
         if (!test_surface) {
             av_log(hwfc, AV_LOG_ERROR, "Unable to allocate a surface from "
                    "internal buffer pool.\n");
@@ -693,8 +703,8 @@ static int vaapi_frames_init(AVHWFramesContext *hwfc)
 
 static void vaapi_frames_uninit(AVHWFramesContext *hwfc)
 {
-    AVVAAPIFramesContext *avfc = hwfc->hwctx;
-    VAAPIFramesContext    *ctx = hwfc->internal->priv;
+    VAAPIFramesContext    *ctx = hwfc->hwctx;
+    AVVAAPIFramesContext *avfc = &ctx->p;
 
     av_freep(&avfc->surface_ids);
     av_freep(&ctx->attributes);
@@ -718,7 +728,7 @@ static int vaapi_transfer_get_formats(AVHWFramesContext *hwfc,
                                       enum AVHWFrameTransferDirection dir,
                                       enum AVPixelFormat **formats)
 {
-    VAAPIDeviceContext *ctx = hwfc->device_ctx->internal->priv;
+    VAAPIDeviceContext *ctx = hwfc->device_ctx->hwctx;
     enum AVPixelFormat *pix_fmts;
     int i, k, sw_format_available;
 
@@ -791,7 +801,7 @@ static int vaapi_map_frame(AVHWFramesContext *hwfc,
                            AVFrame *dst, const AVFrame *src, int flags)
 {
     AVVAAPIDeviceContext *hwctx = hwfc->device_ctx->hwctx;
-    VAAPIFramesContext *ctx = hwfc->internal->priv;
+    VAAPIFramesContext *ctx = hwfc->hwctx;
     VASurfaceID surface_id;
     const VAAPIFormatDescriptor *desc;
     VAImageFormat *image_format;
@@ -1070,7 +1080,7 @@ static int vaapi_map_from_drm(AVHWFramesContext *src_fc, AVFrame *dst,
                               const AVFrame *src, int flags)
 {
 #if VA_CHECK_VERSION(1, 1, 0)
-    VAAPIFramesContext     *src_vafc = src_fc->internal->priv;
+    VAAPIFramesContext    *src_vafc = src_fc->hwctx;
     int use_prime2;
 #else
     int k;
@@ -2007,11 +2017,9 @@ const HWContextType ff_hwcontext_type_vaapi = {
     .type                   = AV_HWDEVICE_TYPE_VAAPI,
     .name                   = "VAAPI",
 
-    .device_hwctx_size      = sizeof(AVVAAPIDeviceContext),
-    .device_priv_size       = sizeof(VAAPIDeviceContext),
+    .device_hwctx_size      = sizeof(VAAPIDeviceContext),
     .device_hwconfig_size   = sizeof(AVVAAPIHWConfig),
-    .frames_hwctx_size      = sizeof(AVVAAPIFramesContext),
-    .frames_priv_size       = sizeof(VAAPIFramesContext),
+    .frames_hwctx_size      = sizeof(VAAPIFramesContext),
 
     .device_create          = &vaapi_device_create,
     .device_derive          = &vaapi_device_derive,
diff --git a/media/ffvpx/libavutil/imgutils.c b/media/ffvpx/libavutil/imgutils.c
index 1e15f7c920a3c..d246381563797 100644
--- a/media/ffvpx/libavutil/imgutils.c
+++ b/media/ffvpx/libavutil/imgutils.c
@@ -25,10 +25,10 @@
 #include "common.h"
 #include "imgutils.h"
 #include "imgutils_internal.h"
-#include "internal.h"
 #include "intreadwrite.h"
 #include "log.h"
 #include "mathematics.h"
+#include "mem.h"
 #include "pixdesc.h"
 #include "rational.h"
 
diff --git a/media/ffvpx/libavutil/imgutils_internal.h b/media/ffvpx/libavutil/imgutils_internal.h
index d5158584133ba..3e47731a50958 100644
--- a/media/ffvpx/libavutil/imgutils_internal.h
+++ b/media/ffvpx/libavutil/imgutils_internal.h
@@ -22,6 +22,10 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "pixfmt.h"
+
+int avpriv_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt);
+
 int ff_image_copy_plane_uc_from_x86(uint8_t       *dst, ptrdiff_t dst_linesize,
                                     const uint8_t *src, ptrdiff_t src_linesize,
                                     ptrdiff_t bytewidth, int height);
diff --git a/media/ffvpx/libavutil/internal.h b/media/ffvpx/libavutil/internal.h
index 461c0df9ad432..ac1af367e9c83 100644
--- a/media/ffvpx/libavutil/internal.h
+++ b/media/ffvpx/libavutil/internal.h
@@ -40,8 +40,8 @@
 #include <stdio.h>
 #include "config.h"
 #include "attributes.h"
+#include "libm.h"
 #include "macros.h"
-#include "pixfmt.h"
 
 #ifndef attribute_align_arg
 #if ARCH_X86_32 && AV_GCC_VERSION_AT_LEAST(4,2)
@@ -74,16 +74,6 @@
 #endif
 
 
-#define FF_MEMORY_POISON 0x2a
-
-/* Check if the hard coded offset of a struct member still matches reality.
- * Induce a compilation failure if not.
- */
-#define AV_CHECK_OFFSET(s, m, o) struct check_##o {    \
-        int x_##o[offsetof(s, m) == o? 1: -1];         \
-    }
-
-
 #define FF_ALLOC_TYPED_ARRAY(p, nelem)  (p = av_malloc_array(nelem, sizeof(*p)))
 #define FF_ALLOCZ_TYPED_ARRAY(p, nelem) (p = av_calloc(nelem, sizeof(*p)))
 
@@ -94,8 +84,6 @@
  */
 #define FF_FIELD_AT(type, off, obj) (*(type *)((char *)&(obj) + (off)))
 
-#include "libm.h"
-
 /**
  * Return NULL if CONFIG_SMALL is true, otherwise the argument
  * without modification. Used to disable the definition of strings.
@@ -163,8 +151,6 @@ void avpriv_request_sample(void *avc,
 #define SUINT32 uint32_t
 #endif
 
-int avpriv_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt);
-
 static av_always_inline av_const int avpriv_mirror(int x, int w)
 {
     if (!w)
diff --git a/media/ffvpx/libavutil/intreadwrite.h b/media/ffvpx/libavutil/intreadwrite.h
index 21df7887f36e4..d0a5773b54866 100644
--- a/media/ffvpx/libavutil/intreadwrite.h
+++ b/media/ffvpx/libavutil/intreadwrite.h
@@ -583,9 +583,7 @@ union unaligned_16 { uint16_t l; } __attribute__((packed)) av_alias;
 #endif
 
 /* Parameters for AV_COPY*, AV_SWAP*, AV_ZERO* must be
- * naturally aligned. They may be implemented using MMX,
- * so emms_c() must be called before using any float code
- * afterwards.
+ * naturally aligned.
  */
 
 #define AV_COPY(n, d, s) \
diff --git a/media/ffvpx/libavutil/mem.c b/media/ffvpx/libavutil/mem.c
index 36b8940a0cf5c..b205d3fb25649 100644
--- a/media/ffvpx/libavutil/mem.c
+++ b/media/ffvpx/libavutil/mem.c
@@ -62,14 +62,16 @@ void  free(void *ptr);
 
 #endif /* MALLOC_PREFIX */
 
-#define ALIGN (HAVE_AVX512 ? 64 : (HAVE_AVX ? 32 : 16))
+#define ALIGN (HAVE_SIMD_ALIGN_64 ? 64 : (HAVE_SIMD_ALIGN_32 ? 32 : 16))
+
+#define FF_MEMORY_POISON 0x2a
 
 /* NOTE: if you want to override these functions with your own
  * implementations (not recommended) you have to link libav* as
  * dynamic libraries and remove -Wl,-Bsymbolic from the linker flags.
  * Note that this will cost performance. */
 
-static atomic_size_t max_alloc_size = ATOMIC_VAR_INIT(INT_MAX);
+static atomic_size_t max_alloc_size = INT_MAX;
 
 void av_max_alloc(size_t max){
     atomic_store_explicit(&max_alloc_size, max, memory_order_relaxed);
diff --git a/media/ffvpx/libavutil/mem.h b/media/ffvpx/libavutil/mem.h
index be697408a2206..ab7648ac5705f 100644
--- a/media/ffvpx/libavutil/mem.h
+++ b/media/ffvpx/libavutil/mem.h
@@ -116,7 +116,7 @@
  *         be allocated
  * @see av_mallocz()
  */
-void *av_malloc(size_t size) av_malloc_attrib av_alloc_size(1) __attribute__((visibility("default")));
+void *av_malloc(size_t size) av_malloc_attrib av_alloc_size(1);
 
 /**
  * Allocate a memory block with alignment suitable for all memory accesses
diff --git a/media/ffvpx/libavutil/mem_internal.h b/media/ffvpx/libavutil/mem_internal.h
index 2448c606f193d..20f9b3e3f239d 100644
--- a/media/ffvpx/libavutil/mem_internal.h
+++ b/media/ffvpx/libavutil/mem_internal.h
@@ -27,8 +27,6 @@
 
 #include "attributes.h"
 #include "macros.h"
-#include "mem.h"
-#include "version.h"
 
 /**
  * @def DECLARE_ALIGNED(n,t,v)
@@ -76,27 +74,50 @@
  */
 
 #if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1110 || defined(__SUNPRO_C)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
+    #define DECLARE_ALIGNED_T(n,t,v)    t __attribute__ ((aligned (n))) v
     #define DECLARE_ASM_ALIGNED(n,t,v)  t __attribute__ ((aligned (n))) v
     #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
 #elif defined(__DJGPP__)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (FFMIN(n, 16)))) v
+    #define DECLARE_ALIGNED_T(n,t,v)    t __attribute__ ((aligned (FFMIN(n, 16)))) v
     #define DECLARE_ASM_ALIGNED(n,t,v)  t av_used __attribute__ ((aligned (FFMIN(n, 16)))) v
     #define DECLARE_ASM_CONST(n,t,v)    static const t av_used __attribute__ ((aligned (FFMIN(n, 16)))) v
 #elif defined(__GNUC__) || defined(__clang__)
-    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
+    #define DECLARE_ALIGNED_T(n,t,v)    t __attribute__ ((aligned (n))) v
     #define DECLARE_ASM_ALIGNED(n,t,v)  t av_used __attribute__ ((aligned (n))) v
     #define DECLARE_ASM_CONST(n,t,v)    static const t av_used __attribute__ ((aligned (n))) v
 #elif defined(_MSC_VER)
-    #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+    #define DECLARE_ALIGNED_T(n,t,v)    __declspec(align(n)) t v
     #define DECLARE_ASM_ALIGNED(n,t,v)  __declspec(align(n)) t v
     #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
 #else
-    #define DECLARE_ALIGNED(n,t,v)      t v
+    #define DECLARE_ALIGNED_T(n,t,v)    t v
     #define DECLARE_ASM_ALIGNED(n,t,v)  t v
     #define DECLARE_ASM_CONST(n,t,v)    static const t v
 #endif
 
+#if HAVE_SIMD_ALIGN_64
+    #define ALIGN_64 64
+    #define ALIGN_32 32
+#elif HAVE_SIMD_ALIGN_32
+    #define ALIGN_64 32
+    #define ALIGN_32 32
+#else
+    #define ALIGN_64 16
+    #define ALIGN_32 16
+#endif
+
+#define DECLARE_ALIGNED(n,t,v) DECLARE_ALIGNED_V(n,t,v)
+
+// Macro needs to be double-wrapped in order to expand
+// possible other macros being passed for n.
+#define DECLARE_ALIGNED_V(n,t,v) DECLARE_ALIGNED_##n(t,v)
+
+#define DECLARE_ALIGNED_4(t,v)  DECLARE_ALIGNED_T(       4, t, v)
+#define DECLARE_ALIGNED_8(t,v)  DECLARE_ALIGNED_T(       8, t, v)
+#define DECLARE_ALIGNED_16(t,v) DECLARE_ALIGNED_T(      16, t, v)
+#define DECLARE_ALIGNED_32(t,v) DECLARE_ALIGNED_T(ALIGN_32, t, v)
+#define DECLARE_ALIGNED_64(t,v) DECLARE_ALIGNED_T(ALIGN_64, t, v)
+
 // Some broken preprocessors need a second expansion
 // to be forced to tokenize __VA_ARGS__
 #define E1(x) x
diff --git a/media/ffvpx/libavutil/moz.build b/media/ffvpx/libavutil/moz.build
index 4839375c103b7..c3b3a21fbee5f 100644
--- a/media/ffvpx/libavutil/moz.build
+++ b/media/ffvpx/libavutil/moz.build
@@ -35,6 +35,7 @@ SOURCES += [
     'imgutils.c',
     'log.c',
     'log2_tab.c',
+    'mastering_display_metadata.c',
     'mathematics.c',
     'mem.c',
     'opt.c',
@@ -56,13 +57,11 @@ if not CONFIG['MOZ_FFVPX_AUDIOONLY']:
     SOURCES += [
         'adler32.c',
         'base64.c',
-        'color_utils.c',
         'film_grain_params.c',
         'hdr_dynamic_metadata.c',
         'integer.c',
         'intmath.c',
         'lls.c',
-        'mastering_display_metadata.c',
         'pixelutils.c',
         'threadmessage.c',
         'timecode.c',
@@ -79,6 +78,11 @@ EXPORTS.ffvpx = [
     "tx.h"
 ]
 
+c11_flags = ["-std=gnu11"]
+if CONFIG["CC_TYPE"] == "clang-cl":
+    c11_flags.insert(0, "-Xclang")
+CFLAGS += c11_flags
+
 SYMBOLS_FILE =  'avutil.symbols'
 NoVisibilityFlags()
 
diff --git a/media/ffvpx/libavutil/opt.c b/media/ffvpx/libavutil/opt.c
index 0908751752ea6..d11e9d2ac5739 100644
--- a/media/ffvpx/libavutil/opt.c
+++ b/media/ffvpx/libavutil/opt.c
@@ -29,10 +29,10 @@
 #include "avassert.h"
 #include "avstring.h"
 #include "channel_layout.h"
-#include "common.h"
 #include "dict.h"
 #include "eval.h"
 #include "log.h"
+#include "mem.h"
 #include "parseutils.h"
 #include "pixdesc.h"
 #include "mathematics.h"
@@ -43,6 +43,8 @@
 
 #include <float.h>
 
+#define TYPE_BASE(type) ((type) & ~AV_OPT_TYPE_FLAG_ARRAY)
+
 const AVOption *av_opt_next(const void *obj, const AVOption *last)
 {
     const AVClass *class;
@@ -56,6 +58,98 @@ const AVOption *av_opt_next(const void *obj, const AVOption *last)
     return NULL;
 }
 
+static const size_t opt_elem_size[] = {
+    [AV_OPT_TYPE_FLAGS]         = sizeof(unsigned),
+    [AV_OPT_TYPE_INT]           = sizeof(int),
+    [AV_OPT_TYPE_INT64]         = sizeof(int64_t),
+    [AV_OPT_TYPE_UINT64]        = sizeof(uint64_t),
+    [AV_OPT_TYPE_DOUBLE]        = sizeof(double),
+    [AV_OPT_TYPE_FLOAT]         = sizeof(float),
+    [AV_OPT_TYPE_STRING]        = sizeof(char *),
+    [AV_OPT_TYPE_RATIONAL]      = sizeof(AVRational),
+    [AV_OPT_TYPE_BINARY]        = sizeof(uint8_t *),
+    [AV_OPT_TYPE_DICT]          = sizeof(AVDictionary *),
+    [AV_OPT_TYPE_IMAGE_SIZE]    = sizeof(int[2]),
+    [AV_OPT_TYPE_VIDEO_RATE]    = sizeof(AVRational),
+    [AV_OPT_TYPE_PIXEL_FMT]     = sizeof(int),
+    [AV_OPT_TYPE_SAMPLE_FMT]    = sizeof(int),
+    [AV_OPT_TYPE_DURATION]      = sizeof(int64_t),
+    [AV_OPT_TYPE_COLOR]         = sizeof(uint8_t[4]),
+    [AV_OPT_TYPE_CHLAYOUT]      = sizeof(AVChannelLayout),
+    [AV_OPT_TYPE_BOOL]          = sizeof(int),
+};
+
+// option is plain old data
+static int opt_is_pod(enum AVOptionType type)
+{
+    switch (type) {
+    case AV_OPT_TYPE_FLAGS:
+    case AV_OPT_TYPE_INT:
+    case AV_OPT_TYPE_INT64:
+    case AV_OPT_TYPE_DOUBLE:
+    case AV_OPT_TYPE_FLOAT:
+    case AV_OPT_TYPE_RATIONAL:
+    case AV_OPT_TYPE_UINT64:
+    case AV_OPT_TYPE_IMAGE_SIZE:
+    case AV_OPT_TYPE_PIXEL_FMT:
+    case AV_OPT_TYPE_SAMPLE_FMT:
+    case AV_OPT_TYPE_VIDEO_RATE:
+    case AV_OPT_TYPE_DURATION:
+    case AV_OPT_TYPE_COLOR:
+    case AV_OPT_TYPE_BOOL:
+        return 1;
+    }
+    return 0;
+}
+
+static uint8_t opt_array_sep(const AVOption *o)
+{
+    const AVOptionArrayDef *d = o->default_val.arr;
+    av_assert1(o->type & AV_OPT_TYPE_FLAG_ARRAY);
+    return (d && d->sep) ? d->sep : ',';
+}
+
+static void *opt_array_pelem(const AVOption *o, void *array, unsigned idx)
+{
+    av_assert1(o->type & AV_OPT_TYPE_FLAG_ARRAY);
+    return (uint8_t *)array + idx * opt_elem_size[TYPE_BASE(o->type)];
+}
+
+static unsigned *opt_array_pcount(const void *parray)
+{
+    return (unsigned *)((const void * const *)parray + 1);
+}
+
+static void opt_free_elem(const AVOption *o, void *ptr)
+{
+    switch (TYPE_BASE(o->type)) {
+    case AV_OPT_TYPE_STRING:
+    case AV_OPT_TYPE_BINARY:
+        av_freep(ptr);
+        break;
+
+    case AV_OPT_TYPE_DICT:
+        av_dict_free((AVDictionary **)ptr);
+        break;
+
+    case AV_OPT_TYPE_CHLAYOUT:
+        av_channel_layout_uninit((AVChannelLayout *)ptr);
+        break;
+
+    default:
+        break;
+    }
+}
+
+static void opt_free_array(const AVOption *o, void *parray, unsigned *count)
+{
+    for (unsigned i = 0; i < *count; i++)
+        opt_free_elem(o, opt_array_pelem(o, *(void **)parray, i));
+
+    av_freep(parray);
+    *count = 0;
+}
+
 static int read_number(const AVOption *o, const void *dst, double *num, int *den, int64_t *intnum)
 {
     switch (o->type) {
@@ -72,11 +166,6 @@ static int read_number(const AVOption *o, const void *dst, double *num, int *den
     case AV_OPT_TYPE_INT:
         *intnum = *(int *)dst;
         return 0;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_INT64:
     case AV_OPT_TYPE_UINT64:
@@ -93,7 +182,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
         *den    = ((AVRational *)dst)->den;
         return 0;
     case AV_OPT_TYPE_CONST:
-        *num = o->default_val.dbl;
+        *intnum = o->default_val.i64;
         return 0;
     }
     return AVERROR(EINVAL);
@@ -101,14 +190,16 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
 static int write_number(void *obj, const AVOption *o, void *dst, double num, int den, int64_t intnum)
 {
-    if (o->type != AV_OPT_TYPE_FLAGS &&
+    const enum AVOptionType type = TYPE_BASE(o->type);
+
+    if (type != AV_OPT_TYPE_FLAGS &&
         (!den || o->max * den < num * intnum || o->min * den > num * intnum)) {
         num = den ? num * intnum / den : (num && intnum ? INFINITY : NAN);
         av_log(obj, AV_LOG_ERROR, "Value %f for parameter '%s' out of range [%g - %g]\n",
                num, o->name, o->min, o->max);
         return AVERROR(ERANGE);
     }
-    if (o->type == AV_OPT_TYPE_FLAGS) {
+    if (type == AV_OPT_TYPE_FLAGS) {
         double d = num*intnum/den;
         if (d < -1.5 || d > 0xFFFFFFFF+0.5 || (llrint(d*256) & 255)) {
             av_log(obj, AV_LOG_ERROR,
@@ -118,7 +209,7 @@ static int write_number(void *obj, const AVOption *o, void *dst, double num, int
         }
     }
 
-    switch (o->type) {
+    switch (type) {
     case AV_OPT_TYPE_PIXEL_FMT:
         *(enum AVPixelFormat *)dst = llrint(num / den) * intnum;
         break;
@@ -131,11 +222,6 @@ static int write_number(void *obj, const AVOption *o, void *dst, double num, int
         *(int *)dst = llrint(num / den) * intnum;
         break;
     case AV_OPT_TYPE_DURATION:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     case AV_OPT_TYPE_INT64:{
         double d = num / den;
         if (intnum == 1 && d == (double)INT64_MAX) {
@@ -223,6 +309,8 @@ static int set_string_binary(void *obj, const AVOption *o, const char *val, uint
 static int set_string(void *obj, const AVOption *o, const char *val, uint8_t **dst)
 {
     av_freep(dst);
+    if (!val)
+        return 0;
     *dst = av_strdup(val);
     return *dst ? 0 : AVERROR(ENOMEM);
 }
@@ -237,9 +325,10 @@ static int set_string(void *obj, const AVOption *o, const char *val, uint8_t **d
 
 static int set_string_number(void *obj, void *target_obj, const AVOption *o, const char *val, void *dst)
 {
+    const enum AVOptionType type = TYPE_BASE(o->type);
     int ret = 0;
 
-    if (o->type == AV_OPT_TYPE_RATIONAL || o->type == AV_OPT_TYPE_VIDEO_RATE) {
+    if (type == AV_OPT_TYPE_RATIONAL || type == AV_OPT_TYPE_VIDEO_RATE) {
         int num, den;
         char c;
         if (sscanf(val, "%d%*1[:/]%d%c", &num, &den, &c) == 2) {
@@ -256,7 +345,7 @@ static int set_string_number(void *obj, void *target_obj, const AVOption *o, con
         double d;
         int64_t intnum = 1;
 
-        if (o->type == AV_OPT_TYPE_FLAGS) {
+        if (type == AV_OPT_TYPE_FLAGS) {
             if (*val == '+' || *val == '-')
                 cmd = *(val++);
             for (; i < sizeof(buf) - 1 && val[i] && val[i] != '+' && val[i] != '-'; i++)
@@ -312,8 +401,8 @@ static int set_string_number(void *obj, void *target_obj, const AVOption *o, con
                 }
             }
         }
-        if (o->type == AV_OPT_TYPE_FLAGS) {
-            read_number(o, dst, NULL, NULL, &intnum);
+        if (type == AV_OPT_TYPE_FLAGS) {
+            intnum = *(unsigned int*)dst;
             if (cmd == '+')
                 d = intnum | (int64_t)d;
             else if (cmd == '-')
@@ -444,16 +533,26 @@ static int set_string_fmt(void *obj, const AVOption *o, const char *val, uint8_t
     return 0;
 }
 
+static int get_pix_fmt(const char *name)
+{
+    return av_get_pix_fmt(name);
+}
+
 static int set_string_pixel_fmt(void *obj, const AVOption *o, const char *val, uint8_t *dst)
 {
     return set_string_fmt(obj, o, val, dst,
-                          AV_PIX_FMT_NB, av_get_pix_fmt, "pixel format");
+                          AV_PIX_FMT_NB, get_pix_fmt, "pixel format");
+}
+
+static int get_sample_fmt(const char *name)
+{
+    return av_get_sample_fmt(name);
 }
 
 static int set_string_sample_fmt(void *obj, const AVOption *o, const char *val, uint8_t *dst)
 {
     return set_string_fmt(obj, o, val, dst,
-                          AV_SAMPLE_FMT_NB, av_get_sample_fmt, "sample format");
+                          AV_SAMPLE_FMT_NB, get_sample_fmt, "sample format");
 }
 
 static int set_string_dict(void *obj, const AVOption *o, const char *val, uint8_t **dst)
@@ -484,33 +583,20 @@ static int set_string_channel_layout(void *obj, const AVOption *o,
     return av_channel_layout_from_string(channel_layout, val);
 }
 
-int av_opt_set(void *obj, const char *name, const char *val, int search_flags)
+static int opt_set_elem(void *obj, void *target_obj, const AVOption *o,
+                        const char *val, void *dst)
 {
-    int ret = 0;
-    void *dst, *target_obj;
-    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
-    if (!o || !target_obj)
-        return AVERROR_OPTION_NOT_FOUND;
-FF_DISABLE_DEPRECATION_WARNINGS
-    if (!val && (o->type != AV_OPT_TYPE_STRING &&
-                 o->type != AV_OPT_TYPE_PIXEL_FMT && o->type != AV_OPT_TYPE_SAMPLE_FMT &&
-                 o->type != AV_OPT_TYPE_IMAGE_SIZE &&
-                 o->type != AV_OPT_TYPE_DURATION && o->type != AV_OPT_TYPE_COLOR &&
-#if FF_API_OLD_CHANNEL_LAYOUT
-                 o->type != AV_OPT_TYPE_CHANNEL_LAYOUT &&
-#endif
-                 o->type != AV_OPT_TYPE_BOOL))
-        return AVERROR(EINVAL);
-FF_ENABLE_DEPRECATION_WARNINGS
+    const enum AVOptionType type = TYPE_BASE(o->type);
+    int ret;
 
-    if (o->flags & AV_OPT_FLAG_READONLY)
+    if (!val && (type != AV_OPT_TYPE_STRING &&
+                 type != AV_OPT_TYPE_PIXEL_FMT && type != AV_OPT_TYPE_SAMPLE_FMT &&
+                 type != AV_OPT_TYPE_IMAGE_SIZE &&
+                 type != AV_OPT_TYPE_DURATION && type != AV_OPT_TYPE_COLOR &&
+                 type != AV_OPT_TYPE_BOOL))
         return AVERROR(EINVAL);
 
-    if (o->flags & AV_OPT_FLAG_DEPRECATED)
-        av_log(obj, AV_LOG_WARNING, "The \"%s\" option is deprecated: %s\n", name, o->help);
-
-    dst = ((uint8_t *)target_obj) + o->offset;
-    switch (o->type) {
+    switch (type) {
     case AV_OPT_TYPE_BOOL:
         return set_string_bool(obj, o, val, dst);
     case AV_OPT_TYPE_STRING:
@@ -557,23 +643,6 @@ FF_ENABLE_DEPRECATION_WARNINGS
         }
     case AV_OPT_TYPE_COLOR:
         return set_string_color(obj, o, val, dst);
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-        if (!val || !strcmp(val, "none")) {
-            *(int64_t *)dst = 0;
-        } else {
-            int64_t cl = av_get_channel_layout(val);
-            if (!cl) {
-                av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\" as channel layout\n", val);
-                ret = AVERROR(EINVAL);
-            }
-            *(int64_t *)dst = cl;
-            return ret;
-        }
-        break;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     case AV_OPT_TYPE_CHLAYOUT:
         ret = set_string_channel_layout(obj, o, val, dst);
         if (ret < 0) {
@@ -589,6 +658,104 @@ FF_ENABLE_DEPRECATION_WARNINGS
     return AVERROR(EINVAL);
 }
 
+static int opt_set_array(void *obj, void *target_obj, const AVOption *o,
+                         const char *val, void *dst)
+{
+    const AVOptionArrayDef *arr = o->default_val.arr;
+    const size_t      elem_size = opt_elem_size[TYPE_BASE(o->type)];
+    const uint8_t           sep = opt_array_sep(o);
+    uint8_t                *str = NULL;
+
+    void       *elems = NULL;
+    unsigned nb_elems = 0;
+    int ret;
+
+    if (val && *val) {
+        str = av_malloc(strlen(val) + 1);
+        if (!str)
+            return AVERROR(ENOMEM);
+    }
+
+    // split and unescape the string
+    while (val && *val) {
+        uint8_t *p = str;
+        void *tmp;
+
+        if (arr && arr->size_max && nb_elems >= arr->size_max) {
+            av_log(obj, AV_LOG_ERROR,
+                   "Cannot assign more than %u elements to array option %s\n",
+                   arr->size_max, o->name);
+            ret = AVERROR(EINVAL);
+            goto fail;
+        }
+
+        for (; *val; val++, p++) {
+            if (*val == '\\' && val[1])
+                val++;
+            else if (*val == sep) {
+                val++;
+                break;
+            }
+            *p = *val;
+        }
+        *p = 0;
+
+        tmp = av_realloc_array(elems, nb_elems + 1, elem_size);
+        if (!tmp) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        elems = tmp;
+
+        tmp = opt_array_pelem(o, elems, nb_elems);
+        memset(tmp, 0, elem_size);
+
+        ret = opt_set_elem(obj, target_obj, o, str, tmp);
+        if (ret < 0)
+            goto fail;
+        nb_elems++;
+    }
+    av_freep(&str);
+
+    opt_free_array(o, dst, opt_array_pcount(dst));
+
+    if (arr && nb_elems < arr->size_min) {
+        av_log(obj, AV_LOG_ERROR,
+               "Cannot assign fewer than %u elements to array option %s\n",
+               arr->size_min, o->name);
+        ret = AVERROR(EINVAL);
+        goto fail;
+    }
+
+    *((void **)dst)        = elems;
+    *opt_array_pcount(dst) = nb_elems;
+
+    return 0;
+fail:
+    av_freep(&str);
+    opt_free_array(o, &elems, &nb_elems);
+    return ret;
+}
+
+int av_opt_set(void *obj, const char *name, const char *val, int search_flags)
+{
+    void *dst, *target_obj;
+    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
+    if (!o || !target_obj)
+        return AVERROR_OPTION_NOT_FOUND;
+
+    if (o->flags & AV_OPT_FLAG_READONLY)
+        return AVERROR(EINVAL);
+
+    if (o->flags & AV_OPT_FLAG_DEPRECATED)
+        av_log(obj, AV_LOG_WARNING, "The \"%s\" option is deprecated: %s\n", name, o->help);
+
+    dst = ((uint8_t *)target_obj) + o->offset;
+
+    return ((o->type & AV_OPT_TYPE_FLAG_ARRAY) ?
+            opt_set_array : opt_set_elem)(obj, target_obj, o, val, dst);
+}
+
 #define OPT_EVAL_NUMBER(name, opttype, vartype)                         \
 int av_opt_eval_ ## name(void *obj, const AVOption *o,                  \
                          const char *val, vartype *name ## _out)        \
@@ -614,7 +781,7 @@ static int set_number(void *obj, const char *name, double num, int den, int64_t
     if (!o || !target_obj)
         return AVERROR_OPTION_NOT_FOUND;
 
-    if (o->flags & AV_OPT_FLAG_READONLY)
+    if ((o->flags & AV_OPT_FLAG_READONLY) || (o->type & AV_OPT_TYPE_FLAG_ARRAY))
         return AVERROR(EINVAL);
 
     dst = ((uint8_t *)target_obj) + o->offset;
@@ -697,7 +864,8 @@ int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int searc
         return AVERROR_OPTION_NOT_FOUND;
     if (o->type != AV_OPT_TYPE_VIDEO_RATE) {
         av_log(obj, AV_LOG_ERROR,
-               "The value set by option '%s' is not a video rate.\n", o->name);
+               "The value set by option '%s' is not a video rate.\n",
+               o->name);
         return AVERROR(EINVAL);
     }
     if (val.num <= 0 || val.den <= 0)
@@ -744,26 +912,6 @@ int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt,
     return set_format(obj, name, fmt, search_flags, AV_OPT_TYPE_SAMPLE_FMT, "sample", AV_SAMPLE_FMT_NB);
 }
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-int av_opt_set_channel_layout(void *obj, const char *name, int64_t cl, int search_flags)
-{
-    void *target_obj;
-    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
-
-    if (!o || !target_obj)
-        return AVERROR_OPTION_NOT_FOUND;
-    if (o->type != AV_OPT_TYPE_CHANNEL_LAYOUT) {
-        av_log(obj, AV_LOG_ERROR,
-               "The value set by option '%s' is not a channel layout.\n", o->name);
-        return AVERROR(EINVAL);
-    }
-    *(int64_t *)(((uint8_t *)target_obj) + o->offset) = cl;
-    return 0;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 int av_opt_set_dict_val(void *obj, const char *name, const AVDictionary *val,
                         int search_flags)
 {
@@ -834,145 +982,224 @@ static void format_duration(char *buf, size_t size, int64_t d)
         *(--e) = 0;
 }
 
-int av_opt_get(void *obj, const char *name, int search_flags, uint8_t **out_val)
+static int opt_get_elem(const AVOption *o, uint8_t **pbuf, size_t buf_len,
+                        void *dst, int search_flags)
 {
-    void *dst, *target_obj;
-    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
-    uint8_t *bin, buf[128];
-    int len, i, ret;
-    int64_t i64;
-
-    if (!o || !target_obj || (o->offset<=0 && o->type != AV_OPT_TYPE_CONST))
-        return AVERROR_OPTION_NOT_FOUND;
-
-    if (o->flags & AV_OPT_FLAG_DEPRECATED)
-        av_log(obj, AV_LOG_WARNING, "The \"%s\" option is deprecated: %s\n", name, o->help);
-
-    dst = (uint8_t *)target_obj + o->offset;
+    int ret;
 
-    buf[0] = 0;
-    switch (o->type) {
+    switch (TYPE_BASE(o->type)) {
     case AV_OPT_TYPE_BOOL:
-        ret = snprintf(buf, sizeof(buf), "%s", (char *)av_x_if_null(get_bool_name(*(int *)dst), "invalid"));
+        ret = snprintf(*pbuf, buf_len, "%s", get_bool_name(*(int *)dst));
         break;
     case AV_OPT_TYPE_FLAGS:
-        ret = snprintf(buf, sizeof(buf), "0x%08X", *(int *)dst);
+        ret = snprintf(*pbuf, buf_len, "0x%08X", *(int *)dst);
         break;
     case AV_OPT_TYPE_INT:
-        ret = snprintf(buf, sizeof(buf), "%d", *(int *)dst);
+        ret = snprintf(*pbuf, buf_len, "%d", *(int *)dst);
         break;
     case AV_OPT_TYPE_INT64:
-        ret = snprintf(buf, sizeof(buf), "%"PRId64, *(int64_t *)dst);
+        ret = snprintf(*pbuf, buf_len, "%"PRId64, *(int64_t *)dst);
         break;
     case AV_OPT_TYPE_UINT64:
-        ret = snprintf(buf, sizeof(buf), "%"PRIu64, *(uint64_t *)dst);
+        ret = snprintf(*pbuf, buf_len, "%"PRIu64, *(uint64_t *)dst);
         break;
     case AV_OPT_TYPE_FLOAT:
-        ret = snprintf(buf, sizeof(buf), "%f", *(float *)dst);
+        ret = snprintf(*pbuf, buf_len, "%f", *(float *)dst);
         break;
     case AV_OPT_TYPE_DOUBLE:
-        ret = snprintf(buf, sizeof(buf), "%f", *(double *)dst);
+        ret = snprintf(*pbuf, buf_len, "%f", *(double *)dst);
         break;
     case AV_OPT_TYPE_VIDEO_RATE:
     case AV_OPT_TYPE_RATIONAL:
-        ret = snprintf(buf, sizeof(buf), "%d/%d", ((AVRational *)dst)->num, ((AVRational *)dst)->den);
+        ret = snprintf(*pbuf, buf_len, "%d/%d", ((AVRational *)dst)->num, ((AVRational *)dst)->den);
         break;
     case AV_OPT_TYPE_CONST:
-        ret = snprintf(buf, sizeof(buf), "%f", o->default_val.dbl);
+        ret = snprintf(*pbuf, buf_len, "%"PRId64, o->default_val.i64);
         break;
     case AV_OPT_TYPE_STRING:
         if (*(uint8_t **)dst) {
-            *out_val = av_strdup(*(uint8_t **)dst);
+            *pbuf = av_strdup(*(uint8_t **)dst);
         } else if (search_flags & AV_OPT_ALLOW_NULL) {
-            *out_val = NULL;
+            *pbuf = NULL;
             return 0;
         } else {
-            *out_val = av_strdup("");
+            *pbuf = av_strdup("");
         }
-        return *out_val ? 0 : AVERROR(ENOMEM);
-    case AV_OPT_TYPE_BINARY:
+        return *pbuf ? 0 : AVERROR(ENOMEM);
+    case AV_OPT_TYPE_BINARY: {
+        const uint8_t *bin;
+        int len;
+
         if (!*(uint8_t **)dst && (search_flags & AV_OPT_ALLOW_NULL)) {
-            *out_val = NULL;
+            *pbuf = NULL;
             return 0;
         }
         len = *(int *)(((uint8_t *)dst) + sizeof(uint8_t *));
         if ((uint64_t)len * 2 + 1 > INT_MAX)
             return AVERROR(EINVAL);
-        if (!(*out_val = av_malloc(len * 2 + 1)))
+        if (!(*pbuf = av_malloc(len * 2 + 1)))
             return AVERROR(ENOMEM);
         if (!len) {
-            *out_val[0] = '\0';
+            *pbuf[0] = '\0';
             return 0;
         }
         bin = *(uint8_t **)dst;
-        for (i = 0; i < len; i++)
-            snprintf(*out_val + i * 2, 3, "%02X", bin[i]);
+        for (int i = 0; i < len; i++)
+            snprintf(*pbuf + i * 2, 3, "%02X", bin[i]);
         return 0;
+    }
     case AV_OPT_TYPE_IMAGE_SIZE:
-        ret = snprintf(buf, sizeof(buf), "%dx%d", ((int *)dst)[0], ((int *)dst)[1]);
+        ret = snprintf(*pbuf, buf_len, "%dx%d", ((int *)dst)[0], ((int *)dst)[1]);
         break;
     case AV_OPT_TYPE_PIXEL_FMT:
-        ret = snprintf(buf, sizeof(buf), "%s", (char *)av_x_if_null(av_get_pix_fmt_name(*(enum AVPixelFormat *)dst), "none"));
+        ret = snprintf(*pbuf, buf_len, "%s", (char *)av_x_if_null(av_get_pix_fmt_name(*(enum AVPixelFormat *)dst), "none"));
         break;
     case AV_OPT_TYPE_SAMPLE_FMT:
-        ret = snprintf(buf, sizeof(buf), "%s", (char *)av_x_if_null(av_get_sample_fmt_name(*(enum AVSampleFormat *)dst), "none"));
+        ret = snprintf(*pbuf, buf_len, "%s", (char *)av_x_if_null(av_get_sample_fmt_name(*(enum AVSampleFormat *)dst), "none"));
         break;
-    case AV_OPT_TYPE_DURATION:
-        i64 = *(int64_t *)dst;
-        format_duration(buf, sizeof(buf), i64);
-        ret = strlen(buf); // no overflow possible, checked by an assert
+    case AV_OPT_TYPE_DURATION: {
+        int64_t i64 = *(int64_t *)dst;
+        format_duration(*pbuf, buf_len, i64);
+        ret = strlen(*pbuf); // no overflow possible, checked by an assert
         break;
+    }
     case AV_OPT_TYPE_COLOR:
-        ret = snprintf(buf, sizeof(buf), "0x%02x%02x%02x%02x",
+        ret = snprintf(*pbuf, buf_len, "0x%02x%02x%02x%02x",
                        (int)((uint8_t *)dst)[0], (int)((uint8_t *)dst)[1],
                        (int)((uint8_t *)dst)[2], (int)((uint8_t *)dst)[3]);
         break;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-
-        i64 = *(int64_t *)dst;
-        ret = snprintf(buf, sizeof(buf), "0x%"PRIx64, i64);
-        break;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     case AV_OPT_TYPE_CHLAYOUT:
-        ret = av_channel_layout_describe(dst, buf, sizeof(buf));
+        ret = av_channel_layout_describe(dst, *pbuf, buf_len);
         break;
     case AV_OPT_TYPE_DICT:
         if (!*(AVDictionary **)dst && (search_flags & AV_OPT_ALLOW_NULL)) {
-            *out_val = NULL;
+            *pbuf = NULL;
             return 0;
         }
-        return av_dict_get_string(*(AVDictionary **)dst, (char **)out_val, '=', ':');
+        return av_dict_get_string(*(AVDictionary **)dst, (char **)pbuf, '=', ':');
     default:
         return AVERROR(EINVAL);
     }
 
+    return ret;
+}
+
+static int opt_get_array(const AVOption *o, void *dst, uint8_t **out_val)
+{
+    const unsigned count = *opt_array_pcount(dst);
+    const uint8_t    sep = opt_array_sep(o);
+
+    uint8_t *str     = NULL;
+    size_t   str_len = 0;
+    int ret;
+
+    *out_val = NULL;
+
+    for (unsigned i = 0; i < count; i++) {
+        uint8_t buf[128], *out = buf;
+        size_t out_len;
+
+        ret = opt_get_elem(o, &out, sizeof(buf),
+                           opt_array_pelem(o, *(void **)dst, i), 0);
+        if (ret < 0)
+            goto fail;
+
+        out_len = strlen(out);
+        if (out_len > SIZE_MAX / 2 - !!i ||
+            !!i + out_len * 2 > SIZE_MAX - str_len - 1) {
+            ret = AVERROR(ERANGE);
+            goto fail;
+        }
+
+        //                         terminator     escaping  separator
+        //                                                  
+        ret = av_reallocp(&str, str_len + 1 + out_len * 2 + !!i);
+        if (ret < 0)
+            goto fail;
+
+        // add separator if needed
+        if (i)
+            str[str_len++] = sep;
+
+        // escape the element
+        for (unsigned j = 0; j < out_len; j++) {
+            uint8_t val = out[j];
+            if (val == sep || val == '\\')
+                str[str_len++] = '\\';
+            str[str_len++] = val;
+        }
+        str[str_len] = 0;
+
+fail:
+        if (out != buf)
+            av_freep(&out);
+        if (ret < 0) {
+            av_freep(&str);
+            return ret;
+        }
+    }
+
+    *out_val = str;
+
+    return 0;
+}
+
+int av_opt_get(void *obj, const char *name, int search_flags, uint8_t **out_val)
+{
+    void *dst, *target_obj;
+    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
+    uint8_t *out, buf[128];
+    int ret;
+
+    if (!o || !target_obj || (o->offset<=0 && o->type != AV_OPT_TYPE_CONST))
+        return AVERROR_OPTION_NOT_FOUND;
+
+    if (o->flags & AV_OPT_FLAG_DEPRECATED)
+        av_log(obj, AV_LOG_WARNING, "The \"%s\" option is deprecated: %s\n", name, o->help);
+
+    dst = (uint8_t *)target_obj + o->offset;
+
+    if (o->type & AV_OPT_TYPE_FLAG_ARRAY) {
+        ret = opt_get_array(o, dst, out_val);
+        if (ret < 0)
+            return ret;
+        if (!*out_val && !(search_flags & AV_OPT_ALLOW_NULL)) {
+            *out_val = av_strdup("");
+            if (!*out_val)
+               return AVERROR(ENOMEM);
+        }
+        return 0;
+    }
+
+    buf[0] = 0;
+    out = buf;
+    ret = opt_get_elem(o, &out, sizeof(buf), dst, search_flags);
+    if (ret < 0)
+        return ret;
+    if (out != buf) {
+        *out_val = out;
+        return 0;
+    }
+
     if (ret >= sizeof(buf))
         return AVERROR(EINVAL);
-    *out_val = av_strdup(buf);
+    *out_val = av_strdup(out);
     return *out_val ? 0 : AVERROR(ENOMEM);
 }
 
-static int get_number(void *obj, const char *name, const AVOption **o_out, double *num, int *den, int64_t *intnum,
+static int get_number(void *obj, const char *name, double *num, int *den, int64_t *intnum,
                       int search_flags)
 {
     void *dst, *target_obj;
     const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
     if (!o || !target_obj)
-        goto error;
+        return AVERROR_OPTION_NOT_FOUND;
+    if (o->type & AV_OPT_TYPE_FLAG_ARRAY)
+        return AVERROR(EINVAL);
 
     dst = ((uint8_t *)target_obj) + o->offset;
 
-    if (o_out) *o_out= o;
-
     return read_number(o, dst, num, den, intnum);
-
-error:
-    *den    =
-    *intnum = 0;
-    return -1;
 }
 
 int av_opt_get_int(void *obj, const char *name, int search_flags, int64_t *out_val)
@@ -981,7 +1208,7 @@ int av_opt_get_int(void *obj, const char *name, int search_flags, int64_t *out_v
     double num = 1;
     int ret, den = 1;
 
-    if ((ret = get_number(obj, name, NULL, &num, &den, &intnum, search_flags)) < 0)
+    if ((ret = get_number(obj, name, &num, &den, &intnum, search_flags)) < 0)
         return ret;
     if (num == den)
         *out_val = intnum;
@@ -996,7 +1223,7 @@ int av_opt_get_double(void *obj, const char *name, int search_flags, double *out
     double num = 1;
     int ret, den = 1;
 
-    if ((ret = get_number(obj, name, NULL, &num, &den, &intnum, search_flags)) < 0)
+    if ((ret = get_number(obj, name, &num, &den, &intnum, search_flags)) < 0)
         return ret;
     *out_val = num * intnum / den;
     return 0;
@@ -1008,7 +1235,7 @@ int av_opt_get_q(void *obj, const char *name, int search_flags, AVRational *out_
     double num = 1;
     int ret, den = 1;
 
-    if ((ret = get_number(obj, name, NULL, &num, &den, &intnum, search_flags)) < 0)
+    if ((ret = get_number(obj, name, &num, &den, &intnum, search_flags)) < 0)
         return ret;
 
     if (num == 1.0 && (int)intnum == intnum)
@@ -1026,7 +1253,7 @@ int av_opt_get_image_size(void *obj, const char *name, int search_flags, int *w_
         return AVERROR_OPTION_NOT_FOUND;
     if (o->type != AV_OPT_TYPE_IMAGE_SIZE) {
         av_log(obj, AV_LOG_ERROR,
-               "The value for option '%s' is not an image size.\n", name);
+               "The value for option '%s' is not a image size.\n", name);
         return AVERROR(EINVAL);
     }
 
@@ -1042,7 +1269,7 @@ int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRatio
     double     num = 1;
     int   ret, den = 1;
 
-    if ((ret = get_number(obj, name, NULL, &num, &den, &intnum, search_flags)) < 0)
+    if ((ret = get_number(obj, name, &num, &den, &intnum, search_flags)) < 0)
         return ret;
 
     if (num == 1.0 && (int)intnum == intnum)
@@ -1080,27 +1307,6 @@ int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AV
     return get_format(obj, name, search_flags, out_fmt, AV_OPT_TYPE_SAMPLE_FMT, "sample");
 }
 
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *cl)
-{
-    void *dst, *target_obj;
-    const AVOption *o = av_opt_find2(obj, name, NULL, 0, search_flags, &target_obj);
-    if (!o || !target_obj)
-        return AVERROR_OPTION_NOT_FOUND;
-    if (o->type != AV_OPT_TYPE_CHANNEL_LAYOUT) {
-        av_log(obj, AV_LOG_ERROR,
-               "The value for option '%s' is not a channel layout.\n", name);
-        return AVERROR(EINVAL);
-    }
-
-    dst = ((uint8_t*)target_obj) + o->offset;
-    *cl = *(int64_t *)dst;
-    return 0;
-}
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-
 int av_opt_get_chlayout(void *obj, const char *name, int search_flags, AVChannelLayout *cl)
 {
     void *dst, *target_obj;
@@ -1231,6 +1437,120 @@ static char *get_opt_flags_string(void *obj, const char *unit, int64_t value)
     return NULL;
 }
 
+static void log_type(void *av_log_obj, const AVOption *o,
+                     enum AVOptionType parent_type)
+{
+    const char *desc[] = {
+        [AV_OPT_TYPE_FLAGS]         = "<flags>",
+        [AV_OPT_TYPE_INT]           = "<int>",
+        [AV_OPT_TYPE_INT64]         = "<int64>",
+        [AV_OPT_TYPE_UINT64]        = "<uint64>",
+        [AV_OPT_TYPE_DOUBLE]        = "<double>",
+        [AV_OPT_TYPE_FLOAT]         = "<float>",
+        [AV_OPT_TYPE_STRING]        = "<string>",
+        [AV_OPT_TYPE_RATIONAL]      = "<rational>",
+        [AV_OPT_TYPE_BINARY]        = "<binary>",
+        [AV_OPT_TYPE_DICT]          = "<dictionary>",
+        [AV_OPT_TYPE_IMAGE_SIZE]    = "<image_size>",
+        [AV_OPT_TYPE_VIDEO_RATE]    = "<video_rate>",
+        [AV_OPT_TYPE_PIXEL_FMT]     = "<pix_fmt>",
+        [AV_OPT_TYPE_SAMPLE_FMT]    = "<sample_fmt>",
+        [AV_OPT_TYPE_DURATION]      = "<duration>",
+        [AV_OPT_TYPE_COLOR]         = "<color>",
+        [AV_OPT_TYPE_CHLAYOUT]      = "<channel_layout>",
+        [AV_OPT_TYPE_BOOL]          = "<boolean>",
+    };
+    const enum AVOptionType type = TYPE_BASE(o->type);
+
+    if (o->type == AV_OPT_TYPE_CONST && TYPE_BASE(parent_type) == AV_OPT_TYPE_INT)
+        av_log(av_log_obj, AV_LOG_INFO, "%-12"PRId64" ", o->default_val.i64);
+    else if (type < FF_ARRAY_ELEMS(desc) && desc[type]) {
+        if (o->type & AV_OPT_TYPE_FLAG_ARRAY)
+            av_log(av_log_obj, AV_LOG_INFO, "[%-10s]", desc[type]);
+        else
+            av_log(av_log_obj, AV_LOG_INFO, "%-12s ", desc[type]);
+    }
+    else
+        av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "");
+}
+
+static void log_default(void *obj, void *av_log_obj, const AVOption *opt)
+{
+    if (opt->type == AV_OPT_TYPE_CONST || opt->type == AV_OPT_TYPE_BINARY)
+        return;
+    if ((opt->type == AV_OPT_TYPE_COLOR      ||
+         opt->type == AV_OPT_TYPE_IMAGE_SIZE ||
+         opt->type == AV_OPT_TYPE_STRING     ||
+         opt->type == AV_OPT_TYPE_DICT       ||
+         opt->type == AV_OPT_TYPE_CHLAYOUT   ||
+         opt->type == AV_OPT_TYPE_VIDEO_RATE) &&
+        !opt->default_val.str)
+        return;
+
+    if (opt->type & AV_OPT_TYPE_FLAG_ARRAY) {
+        const AVOptionArrayDef *arr = opt->default_val.arr;
+        if (arr && arr->def)
+            av_log(av_log_obj, AV_LOG_INFO, " (default %s)", arr->def);
+        return;
+    }
+
+    av_log(av_log_obj, AV_LOG_INFO, " (default ");
+    switch (opt->type) {
+    case AV_OPT_TYPE_BOOL:
+        av_log(av_log_obj, AV_LOG_INFO, "%s", get_bool_name(opt->default_val.i64));
+        break;
+    case AV_OPT_TYPE_FLAGS: {
+        char *def_flags = get_opt_flags_string(obj, opt->unit, opt->default_val.i64);
+        if (def_flags) {
+            av_log(av_log_obj, AV_LOG_INFO, "%s", def_flags);
+            av_freep(&def_flags);
+        } else {
+            av_log(av_log_obj, AV_LOG_INFO, "%"PRIX64, opt->default_val.i64);
+        }
+        break;
+    }
+    case AV_OPT_TYPE_DURATION: {
+        char buf[25];
+        format_duration(buf, sizeof(buf), opt->default_val.i64);
+        av_log(av_log_obj, AV_LOG_INFO, "%s", buf);
+        break;
+    }
+    case AV_OPT_TYPE_INT:
+    case AV_OPT_TYPE_UINT64:
+    case AV_OPT_TYPE_INT64: {
+        const char *def_const = get_opt_const_name(obj, opt->unit, opt->default_val.i64);
+        if (def_const)
+            av_log(av_log_obj, AV_LOG_INFO, "%s", def_const);
+        else
+            log_int_value(av_log_obj, AV_LOG_INFO, opt->default_val.i64);
+        break;
+    }
+    case AV_OPT_TYPE_DOUBLE:
+    case AV_OPT_TYPE_FLOAT:
+        log_value(av_log_obj, AV_LOG_INFO, opt->default_val.dbl);
+        break;
+    case AV_OPT_TYPE_RATIONAL: {
+        AVRational q = av_d2q(opt->default_val.dbl, INT_MAX);
+        av_log(av_log_obj, AV_LOG_INFO, "%d/%d", q.num, q.den); }
+        break;
+    case AV_OPT_TYPE_PIXEL_FMT:
+        av_log(av_log_obj, AV_LOG_INFO, "%s", (char *)av_x_if_null(av_get_pix_fmt_name(opt->default_val.i64), "none"));
+        break;
+    case AV_OPT_TYPE_SAMPLE_FMT:
+        av_log(av_log_obj, AV_LOG_INFO, "%s", (char *)av_x_if_null(av_get_sample_fmt_name(opt->default_val.i64), "none"));
+        break;
+    case AV_OPT_TYPE_COLOR:
+    case AV_OPT_TYPE_IMAGE_SIZE:
+    case AV_OPT_TYPE_STRING:
+    case AV_OPT_TYPE_DICT:
+    case AV_OPT_TYPE_VIDEO_RATE:
+    case AV_OPT_TYPE_CHLAYOUT:
+        av_log(av_log_obj, AV_LOG_INFO, "\"%s\"", opt->default_val.str);
+        break;
+    }
+    av_log(av_log_obj, AV_LOG_INFO, ")");
+}
+
 static void opt_list(void *obj, void *av_log_obj, const char *unit,
                      int req_flags, int rej_flags, enum AVOptionType parent_type)
 {
@@ -1259,76 +1579,8 @@ static void opt_list(void *obj, void *av_log_obj, const char *unit,
                    (opt->flags & AV_OPT_FLAG_FILTERING_PARAM) ? " " : "-",
                    opt->name);
 
-        switch (opt->type) {
-            case AV_OPT_TYPE_FLAGS:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<flags>");
-                break;
-            case AV_OPT_TYPE_INT:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<int>");
-                break;
-            case AV_OPT_TYPE_INT64:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<int64>");
-                break;
-            case AV_OPT_TYPE_UINT64:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<uint64>");
-                break;
-            case AV_OPT_TYPE_DOUBLE:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<double>");
-                break;
-            case AV_OPT_TYPE_FLOAT:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<float>");
-                break;
-            case AV_OPT_TYPE_STRING:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<string>");
-                break;
-            case AV_OPT_TYPE_RATIONAL:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<rational>");
-                break;
-            case AV_OPT_TYPE_BINARY:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<binary>");
-                break;
-            case AV_OPT_TYPE_DICT:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<dictionary>");
-                break;
-            case AV_OPT_TYPE_IMAGE_SIZE:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<image_size>");
-                break;
-            case AV_OPT_TYPE_VIDEO_RATE:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<video_rate>");
-                break;
-            case AV_OPT_TYPE_PIXEL_FMT:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<pix_fmt>");
-                break;
-            case AV_OPT_TYPE_SAMPLE_FMT:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<sample_fmt>");
-                break;
-            case AV_OPT_TYPE_DURATION:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<duration>");
-                break;
-            case AV_OPT_TYPE_COLOR:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<color>");
-                break;
-            case AV_OPT_TYPE_CHLAYOUT:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-            case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<channel_layout>");
-                break;
-            case AV_OPT_TYPE_BOOL:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "<boolean>");
-                break;
-            case AV_OPT_TYPE_CONST:
-                if (parent_type == AV_OPT_TYPE_INT)
-                    av_log(av_log_obj, AV_LOG_INFO, "%-12"PRId64" ", opt->default_val.i64);
-                else
-                    av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "");
-                break;
-            default:
-                av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "");
-                break;
-        }
+        log_type(av_log_obj, opt, parent_type);
+
         av_log(av_log_obj, AV_LOG_INFO, "%c%c%c%c%c%c%c%c%c%c%c",
                (opt->flags & AV_OPT_FLAG_ENCODING_PARAM)  ? 'E' : '.',
                (opt->flags & AV_OPT_FLAG_DECODING_PARAM)  ? 'D' : '.',
@@ -1365,78 +1617,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
             av_opt_freep_ranges(&r);
         }
 
-        if (opt->type != AV_OPT_TYPE_CONST  &&
-            opt->type != AV_OPT_TYPE_BINARY &&
-                !((opt->type == AV_OPT_TYPE_COLOR      ||
-                   opt->type == AV_OPT_TYPE_IMAGE_SIZE ||
-                   opt->type == AV_OPT_TYPE_STRING     ||
-                   opt->type == AV_OPT_TYPE_DICT       ||
-                   opt->type == AV_OPT_TYPE_CHLAYOUT   ||
-                   opt->type == AV_OPT_TYPE_VIDEO_RATE) &&
-                  !opt->default_val.str)) {
-            av_log(av_log_obj, AV_LOG_INFO, " (default ");
-            switch (opt->type) {
-            case AV_OPT_TYPE_BOOL:
-                av_log(av_log_obj, AV_LOG_INFO, "%s", (char *)av_x_if_null(get_bool_name(opt->default_val.i64), "invalid"));
-                break;
-            case AV_OPT_TYPE_FLAGS: {
-                char *def_flags = get_opt_flags_string(obj, opt->unit, opt->default_val.i64);
-                if (def_flags) {
-                    av_log(av_log_obj, AV_LOG_INFO, "%s", def_flags);
-                    av_freep(&def_flags);
-                } else {
-                    av_log(av_log_obj, AV_LOG_INFO, "%"PRIX64, opt->default_val.i64);
-                }
-                break;
-            }
-            case AV_OPT_TYPE_DURATION: {
-                char buf[25];
-                format_duration(buf, sizeof(buf), opt->default_val.i64);
-                av_log(av_log_obj, AV_LOG_INFO, "%s", buf);
-                break;
-            }
-            case AV_OPT_TYPE_INT:
-            case AV_OPT_TYPE_UINT64:
-            case AV_OPT_TYPE_INT64: {
-                const char *def_const = get_opt_const_name(obj, opt->unit, opt->default_val.i64);
-                if (def_const)
-                    av_log(av_log_obj, AV_LOG_INFO, "%s", def_const);
-                else
-                    log_int_value(av_log_obj, AV_LOG_INFO, opt->default_val.i64);
-                break;
-            }
-            case AV_OPT_TYPE_DOUBLE:
-            case AV_OPT_TYPE_FLOAT:
-                log_value(av_log_obj, AV_LOG_INFO, opt->default_val.dbl);
-                break;
-            case AV_OPT_TYPE_RATIONAL: {
-                AVRational q = av_d2q(opt->default_val.dbl, INT_MAX);
-                av_log(av_log_obj, AV_LOG_INFO, "%d/%d", q.num, q.den); }
-                break;
-            case AV_OPT_TYPE_PIXEL_FMT:
-                av_log(av_log_obj, AV_LOG_INFO, "%s", (char *)av_x_if_null(av_get_pix_fmt_name(opt->default_val.i64), "none"));
-                break;
-            case AV_OPT_TYPE_SAMPLE_FMT:
-                av_log(av_log_obj, AV_LOG_INFO, "%s", (char *)av_x_if_null(av_get_sample_fmt_name(opt->default_val.i64), "none"));
-                break;
-            case AV_OPT_TYPE_COLOR:
-            case AV_OPT_TYPE_IMAGE_SIZE:
-            case AV_OPT_TYPE_STRING:
-            case AV_OPT_TYPE_DICT:
-            case AV_OPT_TYPE_VIDEO_RATE:
-            case AV_OPT_TYPE_CHLAYOUT:
-                av_log(av_log_obj, AV_LOG_INFO, "\"%s\"", opt->default_val.str);
-                break;
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-            case AV_OPT_TYPE_CHANNEL_LAYOUT:
-                av_log(av_log_obj, AV_LOG_INFO, "0x%"PRIx64, opt->default_val.i64);
-                break;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-            }
-            av_log(av_log_obj, AV_LOG_INFO, ")");
-        }
+        log_default(obj, av_log_obj, opt);
 
         av_log(av_log_obj, AV_LOG_INFO, "\n");
         if (opt->unit && opt->type != AV_OPT_TYPE_CONST)
@@ -1473,6 +1654,21 @@ void av_opt_set_defaults2(void *s, int mask, int flags)
         if (opt->flags & AV_OPT_FLAG_READONLY)
             continue;
 
+        if (opt->type & AV_OPT_TYPE_FLAG_ARRAY) {
+            const AVOptionArrayDef *arr = opt->default_val.arr;
+            const char              sep = opt_array_sep(opt);
+
+            av_assert0(sep && sep != '\\' &&
+                       (sep < 'a' || sep > 'z') &&
+                       (sep < 'A' || sep > 'Z') &&
+                       (sep < '0' || sep > '9'));
+
+            if (arr && arr->def)
+                opt_set_array(s, s, opt, arr->def, dst);
+
+            continue;
+        }
+
         switch (opt->type) {
             case AV_OPT_TYPE_CONST:
                 /* Nothing to be done here */
@@ -1483,11 +1679,6 @@ void av_opt_set_defaults2(void *s, int mask, int flags)
             case AV_OPT_TYPE_INT64:
             case AV_OPT_TYPE_UINT64:
             case AV_OPT_TYPE_DURATION:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-            case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
             case AV_OPT_TYPE_PIXEL_FMT:
             case AV_OPT_TYPE_SAMPLE_FMT:
                 write_number(s, opt, dst, 1, 1, opt->default_val.i64);
@@ -1670,7 +1861,6 @@ int av_opt_set_from_string(void *ctx, const char *opts,
 {
     int ret, count = 0;
     const char *dummy_shorthand = NULL;
-    char *av_uninit(parsed_key), *av_uninit(value);
     const char *key;
 
     if (!opts)
@@ -1679,6 +1869,7 @@ int av_opt_set_from_string(void *ctx, const char *opts,
         shorthand = &dummy_shorthand;
 
     while (*opts) {
+        char *parsed_key, *value;
         ret = av_opt_get_key_value(&opts, key_val_sep, pairs_sep,
                                    *shorthand ? AV_OPT_FLAG_IMPLICIT_KEY : 0,
                                    &parsed_key, &value);
@@ -1720,23 +1911,12 @@ void av_opt_free(void *obj)
 {
     const AVOption *o = NULL;
     while ((o = av_opt_next(obj, o))) {
-        switch (o->type) {
-        case AV_OPT_TYPE_STRING:
-        case AV_OPT_TYPE_BINARY:
-            av_freep((uint8_t *)obj + o->offset);
-            break;
-
-        case AV_OPT_TYPE_DICT:
-            av_dict_free((AVDictionary **)(((uint8_t *)obj) + o->offset));
-            break;
+        void *pitem = (uint8_t *)obj + o->offset;
 
-        case AV_OPT_TYPE_CHLAYOUT:
-            av_channel_layout_uninit((AVChannelLayout *)(((uint8_t *)obj) + o->offset));
-            break;
-
-        default:
-            break;
-        }
+        if (o->type & AV_OPT_TYPE_FLAG_ARRAY)
+            opt_free_array(o, pitem, opt_array_pcount(pitem));
+        else
+            opt_free_elem(o, pitem);
     }
 }
 
@@ -1838,48 +2018,93 @@ const AVClass *av_opt_child_class_iterate(const AVClass *parent, void **iter)
 void *av_opt_ptr(const AVClass *class, void *obj, const char *name)
 {
     const AVOption *opt= av_opt_find2(&class, name, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ, NULL);
-    if(!opt)
+
+    // no direct access to array-type options
+    if (!opt || (opt->type & AV_OPT_TYPE_FLAG_ARRAY))
         return NULL;
     return (uint8_t*)obj + opt->offset;
 }
 
-static int opt_size(enum AVOptionType type)
+static int opt_copy_elem(void *logctx, enum AVOptionType type,
+                         void *dst, const void *src)
 {
-    switch(type) {
-    case AV_OPT_TYPE_BOOL:
-    case AV_OPT_TYPE_INT:
-    case AV_OPT_TYPE_FLAGS:
-        return sizeof(int);
-    case AV_OPT_TYPE_DURATION:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
-    case AV_OPT_TYPE_INT64:
-    case AV_OPT_TYPE_UINT64:
-        return sizeof(int64_t);
-    case AV_OPT_TYPE_DOUBLE:
-        return sizeof(double);
-    case AV_OPT_TYPE_FLOAT:
-        return sizeof(float);
-    case AV_OPT_TYPE_STRING:
-        return sizeof(uint8_t*);
-    case AV_OPT_TYPE_VIDEO_RATE:
-    case AV_OPT_TYPE_RATIONAL:
-        return sizeof(AVRational);
-    case AV_OPT_TYPE_BINARY:
-        return sizeof(uint8_t*) + sizeof(int);
-    case AV_OPT_TYPE_IMAGE_SIZE:
-        return sizeof(int[2]);
-    case AV_OPT_TYPE_PIXEL_FMT:
-        return sizeof(enum AVPixelFormat);
-    case AV_OPT_TYPE_SAMPLE_FMT:
-        return sizeof(enum AVSampleFormat);
-    case AV_OPT_TYPE_COLOR:
-        return 4;
+    if (type == AV_OPT_TYPE_STRING) {
+        const char *src_str = *(const char *const *)src;
+        char         **dstp =  (char **)dst;
+        if (*dstp != src_str)
+            av_freep(dstp);
+        if (src_str) {
+            *dstp = av_strdup(src_str);
+            if (!*dstp)
+                return AVERROR(ENOMEM);
+        }
+    } else if (type == AV_OPT_TYPE_BINARY) {
+        const uint8_t *const *src8 = (const uint8_t *const *)src;
+        uint8_t             **dst8 = (uint8_t **)dst;
+        int len = *(const int *)(src8 + 1);
+        if (*dst8 != *src8)
+            av_freep(dst8);
+        *dst8 = av_memdup(*src8, len);
+        if (len && !*dst8) {
+            *(int *)(dst8 + 1) = 0;
+            return AVERROR(ENOMEM);
+        }
+        *(int *)(dst8 + 1) = len;
+    } else if (type == AV_OPT_TYPE_CONST) {
+        // do nothing
+    } else if (type == AV_OPT_TYPE_DICT) {
+        const AVDictionary *sdict = *(const AVDictionary * const *)src;
+        AVDictionary     **ddictp = (AVDictionary **)dst;
+        if (sdict != *ddictp)
+            av_dict_free(ddictp);
+        *ddictp = NULL;
+        return av_dict_copy(ddictp, sdict, 0);
+    } else if (type == AV_OPT_TYPE_CHLAYOUT) {
+        if (dst != src)
+            return av_channel_layout_copy(dst, src);
+    } else if (opt_is_pod(type)) {
+        size_t size = opt_elem_size[type];
+        memcpy(dst, src, size);
+    } else {
+        av_log(logctx, AV_LOG_ERROR, "Unhandled option type: %d\n", type);
+        return AVERROR(EINVAL);
     }
-    return AVERROR(EINVAL);
+
+    return 0;
+}
+
+static int opt_copy_array(void *logctx, const AVOption *o,
+                          void **pdst, const void * const *psrc)
+{
+    unsigned nb_elems = *opt_array_pcount(psrc);
+    void         *dst = NULL;
+    int ret;
+
+    if (*pdst == *psrc) {
+        *pdst                   = NULL;
+        *opt_array_pcount(pdst) = 0;
+    }
+
+    opt_free_array(o, pdst, opt_array_pcount(pdst));
+
+    dst = av_calloc(nb_elems, opt_elem_size[TYPE_BASE(o->type)]);
+    if (!dst)
+        return AVERROR(ENOMEM);
+
+    for (unsigned i = 0; i < nb_elems; i++) {
+        ret = opt_copy_elem(logctx, TYPE_BASE(o->type),
+                            opt_array_pelem(o, dst, i),
+                            opt_array_pelem(o, *(void**)psrc, i));
+        if (ret < 0) {
+            opt_free_array(o, &dst, &nb_elems);
+            return ret;
+        }
+    }
+
+    *pdst                   = dst;
+    *opt_array_pcount(pdst) = nb_elems;
+
+    return 0;
 }
 
 int av_opt_copy(void *dst, const void *src)
@@ -1898,47 +2123,12 @@ int av_opt_copy(void *dst, const void *src)
     while ((o = av_opt_next(src, o))) {
         void *field_dst = (uint8_t *)dst + o->offset;
         void *field_src = (uint8_t *)src + o->offset;
-        uint8_t **field_dst8 = (uint8_t **)field_dst;
-        uint8_t **field_src8 = (uint8_t **)field_src;
-
-        if (o->type == AV_OPT_TYPE_STRING) {
-            if (*field_dst8 != *field_src8)
-                av_freep(field_dst8);
-            *field_dst8 = av_strdup(*field_src8);
-            if (*field_src8 && !*field_dst8)
-                ret = AVERROR(ENOMEM);
-        } else if (o->type == AV_OPT_TYPE_BINARY) {
-            int len = *(int *)(field_src8 + 1);
-            if (*field_dst8 != *field_src8)
-                av_freep(field_dst8);
-            *field_dst8 = av_memdup(*field_src8, len);
-            if (len && !*field_dst8) {
-                ret = AVERROR(ENOMEM);
-                len = 0;
-            }
-            *(int *)(field_dst8 + 1) = len;
-        } else if (o->type == AV_OPT_TYPE_CONST) {
-            // do nothing
-        } else if (o->type == AV_OPT_TYPE_DICT) {
-            AVDictionary **sdict = (AVDictionary **) field_src;
-            AVDictionary **ddict = (AVDictionary **) field_dst;
-            int ret2;
-            if (*sdict != *ddict)
-                av_dict_free(ddict);
-            *ddict = NULL;
-            ret2 = av_dict_copy(ddict, *sdict, 0);
-            if (ret2 < 0)
-                ret = ret2;
-        } else if (o->type == AV_OPT_TYPE_CHLAYOUT) {
-            if (field_dst != field_src)
-                ret = av_channel_layout_copy(field_dst, field_src);
-        } else {
-            int size = opt_size(o->type);
-            if (size < 0)
-                ret = size;
-            else
-                memcpy(field_dst, field_src, size);
-        }
+
+        int err = (o->type & AV_OPT_TYPE_FLAG_ARRAY)                 ?
+                  opt_copy_array(dst, o,       field_dst, field_src) :
+                  opt_copy_elem (dst, o->type, field_dst, field_src);
+        if (err < 0)
+            ret = err;
     }
     return ret;
 }
@@ -1995,11 +2185,6 @@ int av_opt_query_ranges_default(AVOptionRanges **ranges_arg, void *obj, const ch
     case AV_OPT_TYPE_DOUBLE:
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_COLOR:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
         break;
     case AV_OPT_TYPE_STRING:
         range->component_min = 0;
@@ -2059,8 +2244,7 @@ void av_opt_freep_ranges(AVOptionRanges **rangesp)
 int av_opt_is_set_to_default(void *obj, const AVOption *o)
 {
     int64_t i64;
-    double d, d2;
-    float f;
+    double d;
     AVRational q;
     int ret, w, h;
     char *str;
@@ -2071,6 +2255,24 @@ int av_opt_is_set_to_default(void *obj, const AVOption *o)
 
     dst = ((uint8_t*)obj) + o->offset;
 
+    if (o->type & AV_OPT_TYPE_FLAG_ARRAY) {
+        const char *def = o->default_val.arr ? o->default_val.arr->def : NULL;
+        uint8_t *val;
+
+        ret = opt_get_array(o, dst, &val);
+        if (ret < 0)
+            return ret;
+
+        if (!!val != !!def)
+            ret = 0;
+        else if (val)
+            ret = !strcmp(val, def);
+
+        av_freep(&val);
+
+        return ret;
+    }
+
     switch (o->type) {
     case AV_OPT_TYPE_CONST:
         return 1;
@@ -2079,11 +2281,6 @@ int av_opt_is_set_to_default(void *obj, const AVOption *o)
     case AV_OPT_TYPE_PIXEL_FMT:
     case AV_OPT_TYPE_SAMPLE_FMT:
     case AV_OPT_TYPE_INT:
-#if FF_API_OLD_CHANNEL_LAYOUT
-FF_DISABLE_DEPRECATION_WARNINGS
-    case AV_OPT_TYPE_CHANNEL_LAYOUT:
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     case AV_OPT_TYPE_DURATION:
     case AV_OPT_TYPE_INT64:
     case AV_OPT_TYPE_UINT64:
@@ -2105,13 +2302,11 @@ FF_ENABLE_DEPRECATION_WARNINGS
             return 0;
         return !strcmp(str, o->default_val.str);
     case AV_OPT_TYPE_DOUBLE:
-        read_number(o, dst, &d, NULL, NULL);
+        d = *(double *)dst;
         return o->default_val.dbl == d;
     case AV_OPT_TYPE_FLOAT:
-        read_number(o, dst, &d, NULL, NULL);
-        f = o->default_val.dbl;
-        d2 = f;
-        return d2 == d;
+        d = *(float *)dst;
+        return (float)o->default_val.dbl == d;
     case AV_OPT_TYPE_RATIONAL:
         q = av_d2q(o->default_val.dbl, INT_MAX);
         return !av_cmp_q(*(AVRational*)dst, q);
diff --git a/media/ffvpx/libavutil/opt.h b/media/ffvpx/libavutil/opt.h
index 461b5d3b6bb2a..e6013662f6cac 100644
--- a/media/ffvpx/libavutil/opt.h
+++ b/media/ffvpx/libavutil/opt.h
@@ -43,6 +43,16 @@
  * ("objects"). An option can have a help text, a type and a range of possible
  * values. Options may then be enumerated, read and written to.
  *
+ * There are two modes of access to members of AVOption and its child structs.
+ * One is called 'native access', and refers to access from the code that
+ * declares the AVOption in question.  The other is 'foreign access', and refers
+ * to access from other code.
+ *
+ * Certain struct members in this header are documented as 'native access only'
+ * or similar - it means that only the code that declared the AVOption in
+ * question is allowed to access the field. This allows us to extend the
+ * semantics of those fields without breaking API compatibility.
+ *
  * @section avoptions_implement Implementing AVOptions
  * This section describes how to add AVOptions capabilities to a struct.
  *
@@ -221,7 +231,7 @@
  */
 
 enum AVOptionType{
-    AV_OPT_TYPE_FLAGS,
+    AV_OPT_TYPE_FLAGS = 1,
     AV_OPT_TYPE_INT,
     AV_OPT_TYPE_INT64,
     AV_OPT_TYPE_DOUBLE,
@@ -238,13 +248,98 @@ enum AVOptionType{
     AV_OPT_TYPE_VIDEO_RATE, ///< offset must point to AVRational
     AV_OPT_TYPE_DURATION,
     AV_OPT_TYPE_COLOR,
-#if FF_API_OLD_CHANNEL_LAYOUT
-    AV_OPT_TYPE_CHANNEL_LAYOUT,
-#endif
     AV_OPT_TYPE_BOOL,
     AV_OPT_TYPE_CHLAYOUT,
+
+    /**
+     * May be combined with another regular option type to declare an array
+     * option.
+     *
+     * For array options, @ref AVOption.offset should refer to a pointer
+     * corresponding to the option type. The pointer should be immediately
+     * followed by an unsigned int that will store the number of elements in the
+     * array.
+     */
+    AV_OPT_TYPE_FLAG_ARRAY = (1 << 16),
 };
 
+/**
+ * A generic parameter which can be set by the user for muxing or encoding.
+ */
+#define AV_OPT_FLAG_ENCODING_PARAM  (1 << 0)
+/**
+ * A generic parameter which can be set by the user for demuxing or decoding.
+ */
+#define AV_OPT_FLAG_DECODING_PARAM  (1 << 1)
+#define AV_OPT_FLAG_AUDIO_PARAM     (1 << 3)
+#define AV_OPT_FLAG_VIDEO_PARAM     (1 << 4)
+#define AV_OPT_FLAG_SUBTITLE_PARAM  (1 << 5)
+/**
+ * The option is intended for exporting values to the caller.
+ */
+#define AV_OPT_FLAG_EXPORT          (1 << 6)
+/**
+ * The option may not be set through the AVOptions API, only read.
+ * This flag only makes sense when AV_OPT_FLAG_EXPORT is also set.
+ */
+#define AV_OPT_FLAG_READONLY        (1 << 7)
+/**
+ * A generic parameter which can be set by the user for bit stream filtering.
+ */
+#define AV_OPT_FLAG_BSF_PARAM       (1 << 8)
+
+/**
+ * A generic parameter which can be set by the user at runtime.
+ */
+#define AV_OPT_FLAG_RUNTIME_PARAM   (1 << 15)
+/**
+ * A generic parameter which can be set by the user for filtering.
+ */
+#define AV_OPT_FLAG_FILTERING_PARAM (1 << 16)
+/**
+ * Set if option is deprecated, users should refer to AVOption.help text for
+ * more information.
+ */
+#define AV_OPT_FLAG_DEPRECATED      (1 << 17)
+/**
+ * Set if option constants can also reside in child objects.
+ */
+#define AV_OPT_FLAG_CHILD_CONSTS    (1 << 18)
+
+/**
+ * May be set as default_val for AV_OPT_TYPE_FLAG_ARRAY options.
+ */
+typedef struct AVOptionArrayDef {
+    /**
+     * Native access only.
+     *
+     * Default value of the option, as would be serialized by av_opt_get() (i.e.
+     * using the value of sep as the separator).
+     */
+    const char         *def;
+
+    /**
+     * Minimum number of elements in the array. When this field is non-zero, def
+     * must be non-NULL and contain at least this number of elements.
+     */
+    unsigned            size_min;
+    /**
+     * Maximum number of elements in the array, 0 when unlimited.
+     */
+    unsigned            size_max;
+
+    /**
+     * Separator between array elements in string representations of this
+     * option, used by av_opt_set() and av_opt_get(). It must be a printable
+     * ASCII character, excluding alphanumeric and the backslash. A comma is
+     * used when sep=0.
+     *
+     * The separator and the backslash must be backslash-escaped in order to
+     * appear in string representations of the option value.
+     */
+    char                sep;
+} AVOptionArrayDef;
+
 /**
  * AVOption
  */
@@ -258,6 +353,8 @@ typedef struct AVOption {
     const char *help;
 
     /**
+     * Native access only.
+     *
      * The offset relative to the context structure where the option
      * value is stored. It should be 0 for named constants.
      */
@@ -265,6 +362,7 @@ typedef struct AVOption {
     enum AVOptionType type;
 
     /**
+     * Native access only, except when documented otherwise.
      * the default value for scalar options
      */
     union {
@@ -273,31 +371,22 @@ typedef struct AVOption {
         const char *str;
         /* TODO those are unused now */
         AVRational q;
+
+        /**
+         * Used for AV_OPT_TYPE_FLAG_ARRAY options. May be NULL.
+         *
+         * Foreign access to some members allowed, as noted in AVOptionArrayDef
+         * documentation.
+         */
+        const AVOptionArrayDef *arr;
     } default_val;
     double min;                 ///< minimum valid value for the option
     double max;                 ///< maximum valid value for the option
 
+    /**
+     * A combination of AV_OPT_FLAG_*.
+     */
     int flags;
-#define AV_OPT_FLAG_ENCODING_PARAM  1   ///< a generic parameter which can be set by the user for muxing or encoding
-#define AV_OPT_FLAG_DECODING_PARAM  2   ///< a generic parameter which can be set by the user for demuxing or decoding
-#define AV_OPT_FLAG_AUDIO_PARAM     8
-#define AV_OPT_FLAG_VIDEO_PARAM     16
-#define AV_OPT_FLAG_SUBTITLE_PARAM  32
-/**
- * The option is intended for exporting values to the caller.
- */
-#define AV_OPT_FLAG_EXPORT          64
-/**
- * The option may not be set through the AVOptions API, only read.
- * This flag only makes sense when AV_OPT_FLAG_EXPORT is also set.
- */
-#define AV_OPT_FLAG_READONLY        128
-#define AV_OPT_FLAG_BSF_PARAM       (1<<8) ///< a generic parameter which can be set by the user for bit stream filtering
-#define AV_OPT_FLAG_RUNTIME_PARAM   (1<<15) ///< a generic parameter which can be set by the user at runtime
-#define AV_OPT_FLAG_FILTERING_PARAM (1<<16) ///< a generic parameter which can be set by the user for filtering
-#define AV_OPT_FLAG_DEPRECATED      (1<<17) ///< set if option is deprecated, users should refer to AVOption.help text for more information
-#define AV_OPT_FLAG_CHILD_CONSTS    (1<<18) ///< set if option constants can also reside in child objects
-//FIXME think about enc-audio, ... style flags
 
     /**
      * The logical unit to which the option belongs. Non-constant
@@ -376,15 +465,9 @@ typedef struct AVOptionRanges {
 } AVOptionRanges;
 
 /**
- * Show the obj options.
- *
- * @param req_flags requested flags for the options to show. Show only the
- * options for which it is opt->flags & req_flags.
- * @param rej_flags rejected flags for the options to show. Show only the
- * options for which it is !(opt->flags & req_flags).
- * @param av_log_obj log context to use for showing the options
+ * @defgroup opt_mng AVOption (un)initialization and inspection.
+ * @{
  */
-int av_opt_show2(void *obj, void *av_log_obj, int req_flags, int rej_flags);
 
 /**
  * Set the values of all AVOption fields to their default values.
@@ -404,161 +487,37 @@ void av_opt_set_defaults(void *s);
  */
 void av_opt_set_defaults2(void *s, int mask, int flags);
 
-/**
- * Parse the key/value pairs list in opts. For each key/value pair
- * found, stores the value in the field in ctx that is named like the
- * key. ctx must be an AVClass context, storing is done using
- * AVOptions.
- *
- * @param opts options string to parse, may be NULL
- * @param key_val_sep a 0-terminated list of characters used to
- * separate key from value
- * @param pairs_sep a 0-terminated list of characters used to separate
- * two pairs from each other
- * @return the number of successfully set key/value pairs, or a negative
- * value corresponding to an AVERROR code in case of error:
- * AVERROR(EINVAL) if opts cannot be parsed,
- * the error code issued by av_opt_set() if a key/value pair
- * cannot be set
- */
-int av_set_options_string(void *ctx, const char *opts,
-                          const char *key_val_sep, const char *pairs_sep);
-
-/**
- * Parse the key-value pairs list in opts. For each key=value pair found,
- * set the value of the corresponding option in ctx.
- *
- * @param ctx          the AVClass object to set options on
- * @param opts         the options string, key-value pairs separated by a
- *                     delimiter
- * @param shorthand    a NULL-terminated array of options names for shorthand
- *                     notation: if the first field in opts has no key part,
- *                     the key is taken from the first element of shorthand;
- *                     then again for the second, etc., until either opts is
- *                     finished, shorthand is finished or a named option is
- *                     found; after that, all options must be named
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @return  the number of successfully set key=value pairs, or a negative
- *          value corresponding to an AVERROR code in case of error:
- *          AVERROR(EINVAL) if opts cannot be parsed,
- *          the error code issued by av_set_string3() if a key/value pair
- *          cannot be set
- *
- * Options names must use only the following characters: a-z A-Z 0-9 - . / _
- * Separators must use characters distinct from option names and from each
- * other.
- */
-int av_opt_set_from_string(void *ctx, const char *opts,
-                           const char *const *shorthand,
-                           const char *key_val_sep, const char *pairs_sep);
 /**
  * Free all allocated objects in obj.
  */
 void av_opt_free(void *obj);
 
 /**
- * Check whether a particular flag is set in a flags field.
- *
- * @param field_name the name of the flag field option
- * @param flag_name the name of the flag to check
- * @return non-zero if the flag is set, zero if the flag isn't set,
- *         isn't of the right type, or the flags field doesn't exist.
- */
-int av_opt_flag_is_set(void *obj, const char *field_name, const char *flag_name);
-
-/**
- * Set all the options from a given dictionary on an object.
- *
- * @param obj a struct whose first element is a pointer to AVClass
- * @param options options to process. This dictionary will be freed and replaced
- *                by a new one containing all options not found in obj.
- *                Of course this new dictionary needs to be freed by caller
- *                with av_dict_free().
- *
- * @return 0 on success, a negative AVERROR if some option was found in obj,
- *         but could not be set.
- *
- * @see av_dict_copy()
- */
-int av_opt_set_dict(void *obj, struct AVDictionary **options);
-
-
-/**
- * Set all the options from a given dictionary on an object.
- *
- * @param obj a struct whose first element is a pointer to AVClass
- * @param options options to process. This dictionary will be freed and replaced
- *                by a new one containing all options not found in obj.
- *                Of course this new dictionary needs to be freed by caller
- *                with av_dict_free().
- * @param search_flags A combination of AV_OPT_SEARCH_*.
- *
- * @return 0 on success, a negative AVERROR if some option was found in obj,
- *         but could not be set.
+ * Iterate over all AVOptions belonging to obj.
  *
- * @see av_dict_copy()
+ * @param obj an AVOptions-enabled struct or a double pointer to an
+ *            AVClass describing it.
+ * @param prev result of the previous call to av_opt_next() on this object
+ *             or NULL
+ * @return next AVOption or NULL
  */
-int av_opt_set_dict2(void *obj, struct AVDictionary **options, int search_flags);
+const AVOption *av_opt_next(const void *obj, const AVOption *prev);
 
 /**
- * Extract a key-value pair from the beginning of a string.
- *
- * @param ropts        pointer to the options string, will be updated to
- *                     point to the rest of the string (one of the pairs_sep
- *                     or the final NUL)
- * @param key_val_sep  a 0-terminated list of characters used to separate
- *                     key from value, for example '='
- * @param pairs_sep    a 0-terminated list of characters used to separate
- *                     two pairs from each other, for example ':' or ','
- * @param flags        flags; see the AV_OPT_FLAG_* values below
- * @param rkey         parsed key; must be freed using av_free()
- * @param rval         parsed value; must be freed using av_free()
- *
- * @return  >=0 for success, or a negative value corresponding to an
- *          AVERROR code in case of error; in particular:
- *          AVERROR(EINVAL) if no key is present
+ * Iterate over AVOptions-enabled children of obj.
  *
+ * @param prev result of a previous call to this function or NULL
+ * @return next AVOptions-enabled child or NULL
  */
-int av_opt_get_key_value(const char **ropts,
-                         const char *key_val_sep, const char *pairs_sep,
-                         unsigned flags,
-                         char **rkey, char **rval);
-
-enum {
-
-    /**
-     * Accept to parse a value without a key; the key will then be returned
-     * as NULL.
-     */
-    AV_OPT_FLAG_IMPLICIT_KEY = 1,
-};
+void *av_opt_child_next(void *obj, void *prev);
 
 /**
- * @defgroup opt_eval_funcs Evaluating option strings
- * @{
- * This group of functions can be used to evaluate option strings
- * and get numbers out of them. They do the same thing as av_opt_set(),
- * except the result is written into the caller-supplied pointer.
- *
- * @param obj a struct whose first element is a pointer to AVClass.
- * @param o an option for which the string is to be evaluated.
- * @param val string to be evaluated.
- * @param *_out value of the string will be written here.
+ * Iterate over potential AVOptions-enabled children of parent.
  *
- * @return 0 on success, a negative number on failure.
- */
-int av_opt_eval_flags (void *obj, const AVOption *o, const char *val, int        *flags_out);
-int av_opt_eval_int   (void *obj, const AVOption *o, const char *val, int        *int_out);
-int av_opt_eval_int64 (void *obj, const AVOption *o, const char *val, int64_t    *int64_out);
-int av_opt_eval_float (void *obj, const AVOption *o, const char *val, float      *float_out);
-int av_opt_eval_double(void *obj, const AVOption *o, const char *val, double     *double_out);
-int av_opt_eval_q     (void *obj, const AVOption *o, const char *val, AVRational *q_out);
-/**
- * @}
+ * @param iter a pointer where iteration state is stored.
+ * @return AVClass corresponding to next potential child or NULL
  */
+const AVClass *av_opt_child_class_iterate(const AVClass *parent, void **iter);
 
 #define AV_OPT_SEARCH_CHILDREN   (1 << 0) /**< Search in possible children of the
                                                given object first. */
@@ -633,31 +592,161 @@ const AVOption *av_opt_find2(void *obj, const char *name, const char *unit,
                              int opt_flags, int search_flags, void **target_obj);
 
 /**
- * Iterate over all AVOptions belonging to obj.
+ * Show the obj options.
  *
- * @param obj an AVOptions-enabled struct or a double pointer to an
- *            AVClass describing it.
- * @param prev result of the previous call to av_opt_next() on this object
- *             or NULL
- * @return next AVOption or NULL
+ * @param req_flags requested flags for the options to show. Show only the
+ * options for which it is opt->flags & req_flags.
+ * @param rej_flags rejected flags for the options to show. Show only the
+ * options for which it is !(opt->flags & req_flags).
+ * @param av_log_obj log context to use for showing the options
  */
-const AVOption *av_opt_next(const void *obj, const AVOption *prev);
+int av_opt_show2(void *obj, void *av_log_obj, int req_flags, int rej_flags);
 
 /**
- * Iterate over AVOptions-enabled children of obj.
+ * Extract a key-value pair from the beginning of a string.
+ *
+ * @param ropts        pointer to the options string, will be updated to
+ *                     point to the rest of the string (one of the pairs_sep
+ *                     or the final NUL)
+ * @param key_val_sep  a 0-terminated list of characters used to separate
+ *                     key from value, for example '='
+ * @param pairs_sep    a 0-terminated list of characters used to separate
+ *                     two pairs from each other, for example ':' or ','
+ * @param flags        flags; see the AV_OPT_FLAG_* values below
+ * @param rkey         parsed key; must be freed using av_free()
+ * @param rval         parsed value; must be freed using av_free()
+ *
+ * @return  >=0 for success, or a negative value corresponding to an
+ *          AVERROR code in case of error; in particular:
+ *          AVERROR(EINVAL) if no key is present
  *
- * @param prev result of a previous call to this function or NULL
- * @return next AVOptions-enabled child or NULL
  */
-void *av_opt_child_next(void *obj, void *prev);
+int av_opt_get_key_value(const char **ropts,
+                         const char *key_val_sep, const char *pairs_sep,
+                         unsigned flags,
+                         char **rkey, char **rval);
+
+enum {
+
+    /**
+     * Accept to parse a value without a key; the key will then be returned
+     * as NULL.
+     */
+    AV_OPT_FLAG_IMPLICIT_KEY = 1,
+};
 
 /**
- * Iterate over potential AVOptions-enabled children of parent.
+ * @}
+ */
+
+/**
+ * @defgroup opt_write Setting and modifying option values
+ * @{
+ */
+
+/**
+ * Parse the key/value pairs list in opts. For each key/value pair
+ * found, stores the value in the field in ctx that is named like the
+ * key. ctx must be an AVClass context, storing is done using
+ * AVOptions.
  *
- * @param iter a pointer where iteration state is stored.
- * @return AVClass corresponding to next potential child or NULL
+ * @param opts options string to parse, may be NULL
+ * @param key_val_sep a 0-terminated list of characters used to
+ * separate key from value
+ * @param pairs_sep a 0-terminated list of characters used to separate
+ * two pairs from each other
+ * @return the number of successfully set key/value pairs, or a negative
+ * value corresponding to an AVERROR code in case of error:
+ * AVERROR(EINVAL) if opts cannot be parsed,
+ * the error code issued by av_opt_set() if a key/value pair
+ * cannot be set
  */
-const AVClass *av_opt_child_class_iterate(const AVClass *parent, void **iter);
+int av_set_options_string(void *ctx, const char *opts,
+                          const char *key_val_sep, const char *pairs_sep);
+
+/**
+ * Parse the key-value pairs list in opts. For each key=value pair found,
+ * set the value of the corresponding option in ctx.
+ *
+ * @param ctx          the AVClass object to set options on
+ * @param opts         the options string, key-value pairs separated by a
+ *                     delimiter
+ * @param shorthand    a NULL-terminated array of options names for shorthand
+ *                     notation: if the first field in opts has no key part,
+ *                     the key is taken from the first element of shorthand;
+ *                     then again for the second, etc., until either opts is
+ *                     finished, shorthand is finished or a named option is
+ *                     found; after that, all options must be named
+ * @param key_val_sep  a 0-terminated list of characters used to separate
+ *                     key from value, for example '='
+ * @param pairs_sep    a 0-terminated list of characters used to separate
+ *                     two pairs from each other, for example ':' or ','
+ * @return  the number of successfully set key=value pairs, or a negative
+ *          value corresponding to an AVERROR code in case of error:
+ *          AVERROR(EINVAL) if opts cannot be parsed,
+ *          the error code issued by av_set_string3() if a key/value pair
+ *          cannot be set
+ *
+ * Options names must use only the following characters: a-z A-Z 0-9 - . / _
+ * Separators must use characters distinct from option names and from each
+ * other.
+ */
+int av_opt_set_from_string(void *ctx, const char *opts,
+                           const char *const *shorthand,
+                           const char *key_val_sep, const char *pairs_sep);
+
+/**
+ * Set all the options from a given dictionary on an object.
+ *
+ * @param obj a struct whose first element is a pointer to AVClass
+ * @param options options to process. This dictionary will be freed and replaced
+ *                by a new one containing all options not found in obj.
+ *                Of course this new dictionary needs to be freed by caller
+ *                with av_dict_free().
+ *
+ * @return 0 on success, a negative AVERROR if some option was found in obj,
+ *         but could not be set.
+ *
+ * @see av_dict_copy()
+ */
+int av_opt_set_dict(void *obj, struct AVDictionary **options);
+
+
+/**
+ * Set all the options from a given dictionary on an object.
+ *
+ * @param obj a struct whose first element is a pointer to AVClass
+ * @param options options to process. This dictionary will be freed and replaced
+ *                by a new one containing all options not found in obj.
+ *                Of course this new dictionary needs to be freed by caller
+ *                with av_dict_free().
+ * @param search_flags A combination of AV_OPT_SEARCH_*.
+ *
+ * @return 0 on success, a negative AVERROR if some option was found in obj,
+ *         but could not be set.
+ *
+ * @see av_dict_copy()
+ */
+int av_opt_set_dict2(void *obj, struct AVDictionary **options, int search_flags);
+
+/**
+ * Copy options from src object into dest object.
+ *
+ * The underlying AVClass of both src and dest must coincide. The guarantee
+ * below does not apply if this is not fulfilled.
+ *
+ * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
+ * Original memory allocated for such options is freed unless both src and dest options points to the same memory.
+ *
+ * Even on error it is guaranteed that allocated options from src and dest
+ * no longer alias each other afterwards; in particular calling av_opt_free()
+ * on both src and dest is safe afterwards if dest has been memdup'ed from src.
+ *
+ * @param dest Object to copy from
+ * @param src  Object to copy into
+ * @return 0 on success, negative on error
+ */
+int av_opt_copy(void *dest, const void *src);
 
 /**
  * @defgroup opt_set_funcs Option setting functions
@@ -697,10 +786,6 @@ int av_opt_set_image_size(void *obj, const char *name, int w, int h, int search_
 int av_opt_set_pixel_fmt (void *obj, const char *name, enum AVPixelFormat fmt, int search_flags);
 int av_opt_set_sample_fmt(void *obj, const char *name, enum AVSampleFormat fmt, int search_flags);
 int av_opt_set_video_rate(void *obj, const char *name, AVRational val, int search_flags);
-#if FF_API_OLD_CHANNEL_LAYOUT
-attribute_deprecated
-int av_opt_set_channel_layout(void *obj, const char *name, int64_t ch_layout, int search_flags);
-#endif
 int av_opt_set_chlayout(void *obj, const char *name, const AVChannelLayout *layout, int search_flags);
 /**
  * @note Any old dictionary present is discarded and replaced with a copy of the new one. The
@@ -726,6 +811,12 @@ int av_opt_set_dict_val(void *obj, const char *name, const AVDictionary *val, in
 
 /**
  * @}
+ * @}
+ */
+
+/**
+ * @defgroup opt_read Reading option values
+ * @{
  */
 
 /**
@@ -756,10 +847,6 @@ int av_opt_get_image_size(void *obj, const char *name, int search_flags, int *w_
 int av_opt_get_pixel_fmt (void *obj, const char *name, int search_flags, enum AVPixelFormat *out_fmt);
 int av_opt_get_sample_fmt(void *obj, const char *name, int search_flags, enum AVSampleFormat *out_fmt);
 int av_opt_get_video_rate(void *obj, const char *name, int search_flags, AVRational *out_val);
-#if FF_API_OLD_CHANNEL_LAYOUT
-attribute_deprecated
-int av_opt_get_channel_layout(void *obj, const char *name, int search_flags, int64_t *ch_layout);
-#endif
 int av_opt_get_chlayout(void *obj, const char *name, int search_flags, AVChannelLayout *layout);
 /**
  * @param[out] out_val The returned dictionary is a copy of the actual value and must
@@ -769,70 +856,40 @@ int av_opt_get_dict_val(void *obj, const char *name, int search_flags, AVDiction
 /**
  * @}
  */
-/**
- * Gets a pointer to the requested field in a struct.
- * This function allows accessing a struct even when its fields are moved or
- * renamed since the application making the access has been compiled,
- *
- * @returns a pointer to the field, it can be cast to the correct type and read
- *          or written to.
- */
-void *av_opt_ptr(const AVClass *avclass, void *obj, const char *name);
-
-/**
- * Free an AVOptionRanges struct and set it to NULL.
- */
-void av_opt_freep_ranges(AVOptionRanges **ranges);
 
 /**
- * Get a list of allowed ranges for the given option.
- *
- * The returned list may depend on other fields in obj like for example profile.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
+ * @defgroup opt_eval_funcs Evaluating option strings
+ * @{
+ * This group of functions can be used to evaluate option strings
+ * and get numbers out of them. They do the same thing as av_opt_set(),
+ * except the result is written into the caller-supplied pointer.
  *
- * The result must be freed with av_opt_freep_ranges.
+ * @param obj a struct whose first element is a pointer to AVClass.
+ * @param o an option for which the string is to be evaluated.
+ * @param val string to be evaluated.
+ * @param *_out value of the string will be written here.
  *
- * @return number of compontents returned on success, a negative errro code otherwise
+ * @return 0 on success, a negative number on failure.
  */
-int av_opt_query_ranges(AVOptionRanges **, void *obj, const char *key, int flags);
-
+int av_opt_eval_flags (void *obj, const AVOption *o, const char *val, int        *flags_out);
+int av_opt_eval_int   (void *obj, const AVOption *o, const char *val, int        *int_out);
+int av_opt_eval_int64 (void *obj, const AVOption *o, const char *val, int64_t    *int64_out);
+int av_opt_eval_float (void *obj, const AVOption *o, const char *val, float      *float_out);
+int av_opt_eval_double(void *obj, const AVOption *o, const char *val, double     *double_out);
+int av_opt_eval_q     (void *obj, const AVOption *o, const char *val, AVRational *q_out);
 /**
- * Copy options from src object into dest object.
- *
- * The underlying AVClass of both src and dest must coincide. The guarantee
- * below does not apply if this is not fulfilled.
- *
- * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
- * Original memory allocated for such options is freed unless both src and dest options points to the same memory.
- *
- * Even on error it is guaranteed that allocated options from src and dest
- * no longer alias each other afterwards; in particular calling av_opt_free()
- * on both src and dest is safe afterwards if dest has been memdup'ed from src.
- *
- * @param dest Object to copy from
- * @param src  Object to copy into
- * @return 0 on success, negative on error
+ * @}
  */
-int av_opt_copy(void *dest, const void *src);
 
 /**
- * Get a default list of allowed ranges for the given option.
- *
- * This list is constructed without using the AVClass.query_ranges() callback
- * and can be used as fallback from within the callback.
- *
- * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
- *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
- *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
- *
- * The result must be freed with av_opt_free_ranges.
+ * Gets a pointer to the requested field in a struct.
+ * This function allows accessing a struct even when its fields are moved or
+ * renamed since the application making the access has been compiled,
  *
- * @return number of compontents returned on success, a negative errro code otherwise
+ * @returns a pointer to the field, it can be cast to the correct type and read
+ *          or written to.
  */
-int av_opt_query_ranges_default(AVOptionRanges **, void *obj, const char *key, int flags);
+void *av_opt_ptr(const AVClass *avclass, void *obj, const char *name);
 
 /**
  * Check if given option is set to its default value.
@@ -860,6 +917,15 @@ int av_opt_is_set_to_default(void *obj, const AVOption *o);
  */
 int av_opt_is_set_to_default_by_name(void *obj, const char *name, int search_flags);
 
+/**
+ * Check whether a particular flag is set in a flags field.
+ *
+ * @param field_name the name of the flag field option
+ * @param flag_name the name of the flag to check
+ * @return non-zero if the flag is set, zero if the flag isn't set,
+ *         isn't of the right type, or the flags field doesn't exist.
+ */
+int av_opt_flag_is_set(void *obj, const char *field_name, const char *flag_name);
 
 #define AV_OPT_SERIALIZE_SKIP_DEFAULTS              0x00000001  ///< Serialize options that are not set to default values only.
 #define AV_OPT_SERIALIZE_OPT_FLAGS_EXACT            0x00000002  ///< Serialize options that exactly match opt_flags only.
@@ -884,6 +950,47 @@ int av_opt_is_set_to_default_by_name(void *obj, const char *name, int search_fla
  */
 int av_opt_serialize(void *obj, int opt_flags, int flags, char **buffer,
                      const char key_val_sep, const char pairs_sep);
+
+/**
+ * @}
+ */
+
+/**
+ * Free an AVOptionRanges struct and set it to NULL.
+ */
+void av_opt_freep_ranges(AVOptionRanges **ranges);
+
+/**
+ * Get a list of allowed ranges for the given option.
+ *
+ * The returned list may depend on other fields in obj like for example profile.
+ *
+ * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
+ *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
+ *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
+ *
+ * The result must be freed with av_opt_freep_ranges.
+ *
+ * @return number of compontents returned on success, a negative errro code otherwise
+ */
+int av_opt_query_ranges(AVOptionRanges **, void *obj, const char *key, int flags);
+
+/**
+ * Get a default list of allowed ranges for the given option.
+ *
+ * This list is constructed without using the AVClass.query_ranges() callback
+ * and can be used as fallback from within the callback.
+ *
+ * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
+ *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
+ *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
+ *
+ * The result must be freed with av_opt_free_ranges.
+ *
+ * @return number of compontents returned on success, a negative errro code otherwise
+ */
+int av_opt_query_ranges_default(AVOptionRanges **, void *obj, const char *key, int flags);
+
 /**
  * @}
  */
diff --git a/media/ffvpx/libavutil/pixdesc.c b/media/ffvpx/libavutil/pixdesc.c
index f6d4d01460f96..1c0bcf2232be7 100644
--- a/media/ffvpx/libavutil/pixdesc.c
+++ b/media/ffvpx/libavutil/pixdesc.c
@@ -460,12 +460,6 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
-#if FF_API_XVMC
-    [AV_PIX_FMT_XVMC] = {
-        .name = "xvmc",
-        .flags = AV_PIX_FMT_FLAG_HWACCEL,
-    },
-#endif
     [AV_PIX_FMT_UYVY422] = {
         .name = "uyvy422",
         .nb_components = 3,
@@ -2860,6 +2854,9 @@ static const char * const color_space_names[] = {
     [AVCOL_SPC_CHROMA_DERIVED_NCL] = "chroma-derived-nc",
     [AVCOL_SPC_CHROMA_DERIVED_CL] = "chroma-derived-c",
     [AVCOL_SPC_ICTCP] = "ictcp",
+    [AVCOL_SPC_IPT_C2] = "ipt-c2",
+    [AVCOL_SPC_YCGCO_RE] = "ycgco-re",
+    [AVCOL_SPC_YCGCO_RO] = "ycgco-ro",
 };
 
 static const char * const chroma_location_names[] = {
diff --git a/media/ffvpx/libavutil/pixfmt.h b/media/ffvpx/libavutil/pixfmt.h
index 9c87571f49e8b..a7f50e1690382 100644
--- a/media/ffvpx/libavutil/pixfmt.h
+++ b/media/ffvpx/libavutil/pixfmt.h
@@ -32,6 +32,13 @@
 #define AVPALETTE_SIZE 1024
 #define AVPALETTE_COUNT 256
 
+/**
+ * Maximum number of planes in any pixel format.
+ * This should be used when a maximum is needed, but code should not
+ * be written to require a maximum for no good reason.
+ */
+#define AV_VIDEO_MAX_PLANES 4
+
 /**
  * Pixel format.
  *
@@ -288,10 +295,6 @@ enum AVPixelFormat {
     AV_PIX_FMT_BAYER_GRBG16LE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian
     AV_PIX_FMT_BAYER_GRBG16BE, ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian
 
-#if FF_API_XVMC
-    AV_PIX_FMT_XVMC,///< XVideo Motion Acceleration via common packet passing
-#endif
-
     AV_PIX_FMT_YUV440P10LE, ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
     AV_PIX_FMT_YUV440P10BE, ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
     AV_PIX_FMT_YUV440P12LE, ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
@@ -620,6 +623,9 @@ enum AVColorSpace {
     AVCOL_SPC_CHROMA_DERIVED_NCL = 12, ///< Chromaticity-derived non-constant luminance system
     AVCOL_SPC_CHROMA_DERIVED_CL = 13, ///< Chromaticity-derived constant luminance system
     AVCOL_SPC_ICTCP       = 14, ///< ITU-R BT.2100-0, ICtCp
+    AVCOL_SPC_IPT_C2      = 15, ///< SMPTE ST 2128, IPT-C2
+    AVCOL_SPC_YCGCO_RE    = 16, ///< YCgCo-R, even addition of bits
+    AVCOL_SPC_YCGCO_RO    = 17, ///< YCgCo-R, odd addition of bits
     AVCOL_SPC_NB                ///< Not part of ABI
 };
 
diff --git a/media/ffvpx/libavutil/rational.c b/media/ffvpx/libavutil/rational.c
index eb148ddb12cc3..329fbf33028c3 100644
--- a/media/ffvpx/libavutil/rational.c
+++ b/media/ffvpx/libavutil/rational.c
@@ -114,7 +114,7 @@ AVRational av_d2q(double d, int max)
         return (AVRational) { d < 0 ? -1 : 1, 0 };
     frexp(d, &exponent);
     exponent = FFMAX(exponent-1, 0);
-    den = 1LL << (61 - exponent);
+    den = 1LL << (62 - exponent);
     // (int64_t)rint() and llrint() do not work with gcc on ia64 and sparc64,
     // see Ticket2713 for affected gcc/glibc versions
     av_reduce(&a.num, &a.den, floor(d * den + 0.5), den, max);
diff --git a/media/ffvpx/libavutil/rational.h b/media/ffvpx/libavutil/rational.h
index 8cbfc8e066983..849f47f38d569 100644
--- a/media/ffvpx/libavutil/rational.h
+++ b/media/ffvpx/libavutil/rational.h
@@ -168,6 +168,10 @@ static av_always_inline AVRational av_inv_q(AVRational q)
  * In case of infinity, the returned value is expressed as `{1, 0}` or
  * `{-1, 0}` depending on the sign.
  *
+ * In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26
+ * can be recovered exactly from their double representation.
+ * (no exceptions were found within 1B random ones)
+ *
  * @param d   `double` to convert
  * @param max Maximum allowed numerator and denominator
  * @return `d` in AVRational form
diff --git a/media/ffvpx/libavutil/thread.h b/media/ffvpx/libavutil/thread.h
index 2ded498c8991b..2c00c7cc35ada 100644
--- a/media/ffvpx/libavutil/thread.h
+++ b/media/ffvpx/libavutil/thread.h
@@ -26,6 +26,8 @@
 
 #if HAVE_PRCTL
 #include <sys/prctl.h>
+#elif (HAVE_PTHREAD_SETNAME_NP || HAVE_PTHREAD_SET_NAME_NP) && HAVE_PTHREAD_NP_H
+#include <pthread_np.h>
 #endif
 
 #include "error.h"
@@ -213,11 +215,25 @@ static inline int ff_thread_once(char *control, void (*routine)(void))
 
 static inline int ff_thread_setname(const char *name)
 {
+    int ret = 0;
+
 #if HAVE_PRCTL
-    return AVERROR(prctl(PR_SET_NAME, name));
+    ret = AVERROR(prctl(PR_SET_NAME, name));
+#elif HAVE_PTHREAD_SETNAME_NP
+#if defined(__APPLE__)
+    ret = AVERROR(pthread_setname_np(name));
+#elif defined(__NetBSD__)
+    ret = AVERROR(pthread_setname_np(pthread_self(), "%s", name));
+#else
+    ret = AVERROR(pthread_setname_np(pthread_self(), name));
+#endif
+#elif HAVE_PTHREAD_SET_NAME_NP
+    pthread_set_name_np(pthread_self(), name);
+#else
+    ret = AVERROR(ENOSYS);
 #endif
 
-    return AVERROR(ENOSYS);
+    return ret;
 }
 
 #endif /* AVUTIL_THREAD_H */
diff --git a/media/ffvpx/libavutil/timecode.c b/media/ffvpx/libavutil/timecode.c
index b93f05b4b8255..bd879bd3cc042 100644
--- a/media/ffvpx/libavutil/timecode.c
+++ b/media/ffvpx/libavutil/timecode.c
@@ -210,7 +210,7 @@ static int fps_from_frame_rate(AVRational rate)
 {
     if (!rate.den || !rate.num)
         return -1;
-    return (rate.num + rate.den/2) / rate.den;
+    return (rate.num + rate.den/2LL) / rate.den;
 }
 
 int av_timecode_check_frame_rate(AVRational rate)
diff --git a/media/ffvpx/libavutil/timestamp.h b/media/ffvpx/libavutil/timestamp.h
index 9ae64da8a1c0e..fa53a46b98767 100644
--- a/media/ffvpx/libavutil/timestamp.h
+++ b/media/ffvpx/libavutil/timestamp.h
@@ -62,11 +62,18 @@ static inline char *av_ts_make_string(char *buf, int64_t ts)
  * @param tb the timebase of the timestamp
  * @return the buffer in input
  */
-static inline char *av_ts_make_time_string(char *buf, int64_t ts, AVRational *tb)
+char *av_ts_make_time_string2(char *buf, int64_t ts, AVRational tb);
+
+/**
+ * Fill the provided buffer with a string containing a timestamp
+ * representation.
+ *
+ * @see av_ts_make_time_string2
+ */
+static inline char *av_ts_make_time_string(char *buf, int64_t ts,
+                                           const AVRational *tb)
 {
-    if (ts == AV_NOPTS_VALUE) snprintf(buf, AV_TS_MAX_STRING_SIZE, "NOPTS");
-    else                      snprintf(buf, AV_TS_MAX_STRING_SIZE, "%.6g", av_q2d(*tb) * ts);
-    return buf;
+    return av_ts_make_time_string2(buf, ts, *tb);
 }
 
 /**
diff --git a/media/ffvpx/libavutil/tx.c b/media/ffvpx/libavutil/tx.c
index a1f767039bde8..426303d1f34a4 100644
--- a/media/ffvpx/libavutil/tx.c
+++ b/media/ffvpx/libavutil/tx.c
@@ -19,6 +19,7 @@
 #include "avassert.h"
 #include "intmath.h"
 #include "cpu.h"
+#include "mem.h"
 #include "qsort.h"
 #include "bprint.h"
 
@@ -593,7 +594,8 @@ static void print_type(AVBPrint *bp, enum AVTXType type)
                "unknown");
 }
 
-static void print_cd_info(const FFTXCodelet *cd, int prio, int len, int print_prio)
+static void print_cd_info(const FFTXCodelet *cd, int prio, int len, int print_prio,
+                          int log_level)
 {
     AVBPrint bp;
     av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);
@@ -643,7 +645,7 @@ static void print_cd_info(const FFTXCodelet *cd, int prio, int len, int print_pr
     if (print_prio)
         av_bprintf(&bp, ", prio: %i", prio);
 
-    av_log(NULL, AV_LOG_DEBUG, "%s\n", bp.str);
+    av_log(NULL, log_level, "%s\n", bp.str);
 }
 
 static void print_tx_structure(AVTXContext *s, int depth)
@@ -653,7 +655,7 @@ static void print_tx_structure(AVTXContext *s, int depth)
     for (int i = 0; i <= depth; i++)
         av_log(NULL, AV_LOG_DEBUG, "    ");
 
-    print_cd_info(cd, cd->prio, s->len, 0);
+    print_cd_info(cd, cd->prio, s->len, 0, AV_LOG_DEBUG);
 
     for (int i = 0; i < s->nb_sub; i++)
         print_tx_structure(&s->sub[i], depth + 1);
@@ -816,11 +818,11 @@ av_cold int ff_tx_init_subtx(AVTXContext *s, enum AVTXType type,
     AV_QSORT(cd_matches, nb_cd_matches, TXCodeletMatch, cmp_matches);
 
 #if !CONFIG_SMALL
-    av_log(NULL, AV_LOG_DEBUG, "%s\n", bp.str);
+    av_log(NULL, AV_LOG_TRACE, "%s\n", bp.str);
 
     for (int i = 0; i < nb_cd_matches; i++) {
-        av_log(NULL, AV_LOG_DEBUG, "    %i: ", i + 1);
-        print_cd_info(cd_matches[i].cd, cd_matches[i].prio, 0, 1);
+        av_log(NULL, AV_LOG_TRACE, "    %i: ", i + 1);
+        print_cd_info(cd_matches[i].cd, cd_matches[i].prio, 0, 1, AV_LOG_TRACE);
     }
 #endif
 
@@ -914,10 +916,12 @@ av_cold int av_tx_init(AVTXContext **ctx, av_tx_fn *tx, enum AVTXType type,
     if (!(flags & AV_TX_INPLACE))
         flags |= FF_TX_OUT_OF_PLACE;
 
-    if (!scale && ((type == AV_TX_FLOAT_MDCT) || (type == AV_TX_INT32_MDCT)))
-        scale = &default_scale_f;
-    else if (!scale && (type == AV_TX_DOUBLE_MDCT))
+    if (!scale && ((type == AV_TX_DOUBLE_MDCT) || (type == AV_TX_DOUBLE_DCT) ||
+                   (type == AV_TX_DOUBLE_DCT_I) || (type == AV_TX_DOUBLE_DST_I) ||
+                   (type == AV_TX_DOUBLE_RDFT)))
         scale = &default_scale_d;
+    else if (!scale && !TYPE_IS(FFT, type))
+        scale = &default_scale_f;
 
     ret = ff_tx_init_subtx(&tmp, type, flags, NULL, len, inv, scale);
     if (ret < 0)
diff --git a/media/ffvpx/libavutil/tx_template.c b/media/ffvpx/libavutil/tx_template.c
index a2c27465cbcab..701ef0d6de7cc 100644
--- a/media/ffvpx/libavutil/tx_template.c
+++ b/media/ffvpx/libavutil/tx_template.c
@@ -24,6 +24,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "mem.h"
+
 #define TABLE_DEF(name, size) \
     DECLARE_ALIGNED(32, TXSample, TX_TAB(ff_tx_tab_ ##name))[size]
 
diff --git a/media/ffvpx/libavutil/version.h b/media/ffvpx/libavutil/version.h
index 772c4e209c2d9..da1a83325539f 100644
--- a/media/ffvpx/libavutil/version.h
+++ b/media/ffvpx/libavutil/version.h
@@ -78,9 +78,9 @@
  * @{
  */
 
-#define LIBAVUTIL_VERSION_MAJOR  58
-#define LIBAVUTIL_VERSION_MINOR  36
-#define LIBAVUTIL_VERSION_MICRO 101
+#define LIBAVUTIL_VERSION_MAJOR  59
+#define LIBAVUTIL_VERSION_MINOR  13
+#define LIBAVUTIL_VERSION_MICRO 100
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
                                                LIBAVUTIL_VERSION_MINOR, \
@@ -105,20 +105,13 @@
  * @{
  */
 
-#define FF_API_FIFO_PEEK2               (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_FIFO_OLD_API             (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_XVMC                     (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_OLD_CHANNEL_LAYOUT       (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_AV_FOPEN_UTF8            (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_PKT_DURATION             (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_REORDERED_OPAQUE         (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_FRAME_PICTURE_NUMBER     (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_HDR_VIVID_THREE_SPLINE   (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_FRAME_PKT                (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_INTERLACED_FRAME         (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_FRAME_KEY                (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_PALETTE_HAS_CHANGED      (LIBAVUTIL_VERSION_MAJOR < 59)
-#define FF_API_VULKAN_CONTIGUOUS_MEMORY (LIBAVUTIL_VERSION_MAJOR < 59)
+#define FF_API_HDR_VIVID_THREE_SPLINE   (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_FRAME_PKT                (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_INTERLACED_FRAME         (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_FRAME_KEY                (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_PALETTE_HAS_CHANGED      (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_VULKAN_CONTIGUOUS_MEMORY (LIBAVUTIL_VERSION_MAJOR < 60)
+#define FF_API_H274_FILM_GRAIN_VCS      (LIBAVUTIL_VERSION_MAJOR < 60)
 
 /**
  * @}
diff --git a/media/ffvpx/libavutil/x86/emms.h b/media/ffvpx/libavutil/x86/emms.h
deleted file mode 100644
index 8ceec110cf65f..0000000000000
--- a/media/ffvpx/libavutil/x86/emms.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#ifndef AVUTIL_X86_EMMS_H
-#define AVUTIL_X86_EMMS_H
-
-#include "config.h"
-#include "libavutil/attributes.h"
-
-void avpriv_emms_asm(void);
-
-#if HAVE_MMX_INLINE
-#ifndef __MMX__
-#include "libavutil/cpu.h"
-#endif
-
-#   define emms_c emms_c
-/**
- * Empty mmx state.
- * this must be called between any dsp function and float/double code.
- * for example sin(); dsp->idct_put(); emms_c(); cos()
- * Note, *alloc() and *free() also use float code in some libc implementations
- * thus this also applies to them or any function using them.
- */
-static av_always_inline void emms_c(void)
-{
-/* Some inlined functions may also use mmx instructions regardless of
- * runtime cpuflags. With that in mind, we unconditionally empty the
- * mmx state if the target cpu chosen at configure time supports it.
- */
-#if !defined(__MMX__)
-    if(av_get_cpu_flags() & AV_CPU_FLAG_MMX)
-#endif
-        __asm__ volatile ("emms" ::: "memory");
-}
-#elif HAVE_MMX && HAVE_MM_EMPTY
-#   include <mmintrin.h>
-#   define emms_c _mm_empty
-#elif HAVE_MMX_EXTERNAL
-#   define emms_c avpriv_emms_asm
-#endif /* HAVE_MMX_INLINE */
-
-#endif /* AVUTIL_X86_EMMS_H */
diff --git a/media/ffvpx/libavutil/x86/fixed_dsp_init.c b/media/ffvpx/libavutil/x86/fixed_dsp_init.c
index d3f4b2e325e38..3dd508a4f4292 100644
--- a/media/ffvpx/libavutil/x86/fixed_dsp_init.c
+++ b/media/ffvpx/libavutil/x86/fixed_dsp_init.c
@@ -16,14 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config.h"
-
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
 #include "libavutil/fixed_dsp.h"
 #include "cpu.h"
 
-void ff_butterflies_fixed_sse2(int *av_restrict src0, int *av_restrict src1, int len);
+void ff_butterflies_fixed_sse2(int *restrict src0, int *restrict src1, int len);
 
 av_cold void ff_fixed_dsp_init_x86(AVFixedDSPContext *fdsp)
 {
diff --git a/media/ffvpx/libavutil/x86/float_dsp_init.c b/media/ffvpx/libavutil/x86/float_dsp_init.c
index ad6b50625904d..093bce9b94e40 100644
--- a/media/ffvpx/libavutil/x86/float_dsp_init.c
+++ b/media/ffvpx/libavutil/x86/float_dsp_init.c
@@ -16,13 +16,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config.h"
-
 #include "libavutil/attributes.h"
 #include "libavutil/cpu.h"
 #include "libavutil/float_dsp.h"
 #include "cpu.h"
-#include "asm.h"
 
 void ff_vector_fmul_sse(float *dst, const float *src0, const float *src1,
                         int len);
@@ -76,7 +73,7 @@ void ff_vector_fmul_reverse_avx2(float *dst, const float *src0,
 float ff_scalarproduct_float_sse(const float *v1, const float *v2, int order);
 float ff_scalarproduct_float_fma3(const float *v1, const float *v2, int order);
 
-void ff_butterflies_float_sse(float *av_restrict src0, float *av_restrict src1, int len);
+void ff_butterflies_float_sse(float *restrict src0, float *restrict src1, int len);
 
 av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)
 {
diff --git a/media/ffvpx/libavutil/x86/intreadwrite.h b/media/ffvpx/libavutil/x86/intreadwrite.h
index 40f375b01310d..5e57d6a8cddb4 100644
--- a/media/ffvpx/libavutil/x86/intreadwrite.h
+++ b/media/ffvpx/libavutil/x86/intreadwrite.h
@@ -27,42 +27,6 @@
 
 #if HAVE_MMX
 
-#if !HAVE_FAST_64BIT && defined(__MMX__)
-
-#define FF_COPY_SWAP_ZERO_USES_MMX
-
-#define AV_COPY64 AV_COPY64
-static av_always_inline void AV_COPY64(void *d, const void *s)
-{
-    __asm__("movq   %1, %%mm0  \n\t"
-            "movq   %%mm0, %0  \n\t"
-            : "=m"(*(uint64_t*)d)
-            : "m" (*(const uint64_t*)s)
-            : "mm0");
-}
-
-#define AV_SWAP64 AV_SWAP64
-static av_always_inline void AV_SWAP64(void *a, void *b)
-{
-    __asm__("movq   %1, %%mm0  \n\t"
-            "movq   %0, %%mm1  \n\t"
-            "movq   %%mm0, %0  \n\t"
-            "movq   %%mm1, %1  \n\t"
-            : "+m"(*(uint64_t*)a), "+m"(*(uint64_t*)b)
-            ::"mm0", "mm1");
-}
-
-#define AV_ZERO64 AV_ZERO64
-static av_always_inline void AV_ZERO64(void *d)
-{
-    __asm__("pxor %%mm0, %%mm0  \n\t"
-            "movq %%mm0, %0     \n\t"
-            : "=m"(*(uint64_t*)d)
-            :: "mm0");
-}
-
-#endif /* !HAVE_FAST_64BIT && defined(__MMX__) */
-
 #ifdef __SSE__
 
 #define AV_COPY128 AV_COPY128
diff --git a/media/ffvpx/libavutil/x86/moz.build b/media/ffvpx/libavutil/x86/moz.build
index df33768f6613f..9a730c57467b4 100644
--- a/media/ffvpx/libavutil/x86/moz.build
+++ b/media/ffvpx/libavutil/x86/moz.build
@@ -16,6 +16,8 @@ SOURCES += [
     'imgutils_init.c',
     'lls.asm',
     'lls_init.c',
+    'pixelutils.asm',
+    'pixelutils_init.c',
     'tx_float.asm',
     'tx_float_init.c',
 ]
diff --git a/media/ffvpx/libavutil/x86/tx_float.asm b/media/ffvpx/libavutil/x86/tx_float.asm
index e1533a85954d9..42006848f1280 100644
--- a/media/ffvpx/libavutil/x86/tx_float.asm
+++ b/media/ffvpx/libavutil/x86/tx_float.asm
@@ -46,7 +46,7 @@
 %endif
 
 %assign i 16
-%rep 14
+%rep 18
 cextern tab_ %+ i %+ _float ; ff_tab_i_float...
 %assign i (i << 1)
 %endrep
@@ -1385,7 +1385,11 @@ FFT_SPLIT_RADIX_DEF 8192,  .16384pt
 FFT_SPLIT_RADIX_DEF 16384, .32768pt
 FFT_SPLIT_RADIX_DEF 32768, .65536pt
 FFT_SPLIT_RADIX_DEF 65536, .131072pt
-FFT_SPLIT_RADIX_DEF 131072
+FFT_SPLIT_RADIX_DEF 131072, .262144pt
+FFT_SPLIT_RADIX_DEF 262144, .524288pt
+FFT_SPLIT_RADIX_DEF 524288, .1048576pt
+FFT_SPLIT_RADIX_DEF 1048576, .2097152pt
+FFT_SPLIT_RADIX_DEF 2097152
 
 ;===============================================================================
 ; Final synthesis + deinterleaving code
diff --git a/media/ffvpx/libavutil/x86/tx_float_init.c b/media/ffvpx/libavutil/x86/tx_float_init.c
index d3c0beb50fca8..36da9325e5c43 100644
--- a/media/ffvpx/libavutil/x86/tx_float_init.c
+++ b/media/ffvpx/libavutil/x86/tx_float_init.c
@@ -19,6 +19,7 @@
 #define TX_FLOAT
 #include "libavutil/tx_priv.h"
 #include "libavutil/attributes.h"
+#include "libavutil/mem.h"
 #include "libavutil/x86/cpu.h"
 
 #include "config.h"
@@ -270,15 +271,15 @@ const FFTXCodelet * const ff_tx_codelet_list_float_x86[] = {
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
     TX_DEF(fft32_ns, FFT, 32, 32, 2, 0, 352, b8_i2, fma3, FMA3, AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 256, b8_i2, avx, AVX,  0, AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr_asm, FFT, 64, 131072, 2, 0, 320, b8_i2, avx, AVX,
+    TX_DEF(fft_sr,    FFT, 64, 2097152, 2, 0, 256, b8_i2, avx, AVX,  0, AV_CPU_FLAG_AVXSLOW),
+    TX_DEF(fft_sr_asm, FFT, 64, 2097152, 2, 0, 320, b8_i2, avx, AVX,
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 320, b8_i2, avx, AVX,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
+    TX_DEF(fft_sr_ns, FFT, 64, 2097152, 2, 0, 320, b8_i2, avx, AVX,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 288, b8_i2, fma3,  FMA3,  0, AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr_asm, FFT, 64, 131072, 2, 0, 352, b8_i2, fma3,  FMA3,
+    TX_DEF(fft_sr,    FFT, 64, 2097152, 2, 0, 288, b8_i2, fma3,  FMA3,  0, AV_CPU_FLAG_AVXSLOW),
+    TX_DEF(fft_sr_asm, FFT, 64, 2097152, 2, 0, 352, b8_i2, fma3,  FMA3,
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW),
-    TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 352, b8_i2, fma3,  FMA3,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
+    TX_DEF(fft_sr_ns, FFT, 64, 2097152, 2, 0, 352, b8_i2, fma3,  FMA3,  AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW),
 
 #if HAVE_AVX2_EXTERNAL
@@ -287,11 +288,11 @@ const FFTXCodelet * const ff_tx_codelet_list_float_x86[] = {
     TX_DEF(fft15_ns, FFT, 15, 15, 15, 0, 384, factor_init, avx2, AVX2,
            AV_TX_INPLACE | FF_TX_PRESHUFFLE, AV_CPU_FLAG_AVXSLOW),
 
-    TX_DEF(fft_sr,    FFT, 64, 131072, 2, 0, 320, b8_i2, avx2, AVX2, 0,
+    TX_DEF(fft_sr,    FFT, 64, 2097152, 2, 0, 320, b8_i2, avx2, AVX2, 0,
            AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
-    TX_DEF(fft_sr_asm, FFT, 64, 131072, 2, 0, 384, b8_i2, avx2, AVX2,
+    TX_DEF(fft_sr_asm, FFT, 64, 2097152, 2, 0, 384, b8_i2, avx2, AVX2,
            AV_TX_INPLACE | FF_TX_PRESHUFFLE | FF_TX_ASM_CALL, AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
-    TX_DEF(fft_sr_ns, FFT, 64, 131072, 2, 0, 384, b8_i2, avx2, AVX2, AV_TX_INPLACE | FF_TX_PRESHUFFLE,
+    TX_DEF(fft_sr_ns, FFT, 64, 2097152, 2, 0, 384, b8_i2, avx2, AVX2, AV_TX_INPLACE | FF_TX_PRESHUFFLE,
            AV_CPU_FLAG_AVXSLOW | AV_CPU_FLAG_SLOW_GATHER),
 
     TX_DEF(fft_pfa_15xM, FFT, 60, TX_LEN_UNLIMITED, 15, 2, 320, fft_pfa_init, avx2, AVX2,
diff --git a/media/ffvpx/libavutil/x86/x86inc.asm b/media/ffvpx/libavutil/x86/x86inc.asm
index e099ee4b10de1..e61d924bc1016 100644
--- a/media/ffvpx/libavutil/x86/x86inc.asm
+++ b/media/ffvpx/libavutil/x86/x86inc.asm
@@ -1,7 +1,7 @@
 ;*****************************************************************************
-;* x86inc.asm: x264asm abstraction layer
+;* x86inc.asm: x86 abstraction layer
 ;*****************************************************************************
-;* Copyright (C) 2005-2018 x264 project
+;* Copyright (C) 2005-2024 x264 project
 ;*
 ;* Authors: Loren Merritt <lorenm@u.washington.edu>
 ;*          Henrik Gramner <henrik@gramner.com>
@@ -21,21 +21,14 @@
 ;* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 ;*****************************************************************************
 
-; This is a header file for the x264ASM assembly language, which uses
+; This is a header file for the x86inc.asm assembly language, which uses
 ; NASM/YASM syntax combined with a large number of macros to provide easy
 ; abstraction between different calling conventions (x86_32, win64, linux64).
 ; It also has various other useful features to simplify writing the kind of
-; DSP functions that are most often used in x264.
-
-; Unlike the rest of x264, this file is available under an ISC license, as it
-; has significant usefulness outside of x264 and we want it to be available
-; to the largest audience possible.  Of course, if you modify it for your own
-; purposes to add a new feature, we strongly encourage contributing a patch
-; as this feature might be useful for others as well.  Send patches or ideas
-; to x264-devel@videolan.org .
+; DSP functions that are most often used.
 
 %ifndef private_prefix
-    %define private_prefix x264
+    %error private_prefix not defined
 %endif
 
 %ifndef public_prefix
@@ -68,12 +61,19 @@
 %endif
 
 %define FORMAT_ELF 0
+%define FORMAT_MACHO 0
 %ifidn __OUTPUT_FORMAT__,elf
     %define FORMAT_ELF 1
 %elifidn __OUTPUT_FORMAT__,elf32
     %define FORMAT_ELF 1
 %elifidn __OUTPUT_FORMAT__,elf64
     %define FORMAT_ELF 1
+%elifidn __OUTPUT_FORMAT__,macho
+    %define FORMAT_MACHO 1
+%elifidn __OUTPUT_FORMAT__,macho32
+    %define FORMAT_MACHO 1
+%elifidn __OUTPUT_FORMAT__,macho64
+    %define FORMAT_MACHO 1
 %endif
 
 %ifdef PREFIX
@@ -82,6 +82,11 @@
     %define mangle(x) x
 %endif
 
+; Use VEX-encoding even in non-AVX functions
+%ifndef FORCE_VEX_ENCODING
+    %define FORCE_VEX_ENCODING 0
+%endif
+
 ; aout does not support align=
 ; NOTE: This section is out of sync with x264, in order to
 ; keep supporting OS/2.
@@ -99,28 +104,27 @@
     %endif
 %endmacro
 
-%if WIN64
-    %define PIC
-%elif ARCH_X86_64 == 0
-; x86_32 doesn't require PIC.
-; Some distros prefer shared objects to be PIC, but nothing breaks if
-; the code contains a few textrels, so we'll skip that complexity.
-    %undef PIC
-%endif
-%ifdef PIC
+%if ARCH_X86_64
+    %define PIC 1 ; always use PIC on x86-64
     default rel
+%elifidn __OUTPUT_FORMAT__,win32
+    %define PIC 0 ; PIC isn't used on 32-bit Windows
+%elifndef PIC
+    %define PIC 0
 %endif
 
-%macro CPUNOP 1
-    %if HAVE_CPUNOP
-        CPU %1
+%define HAVE_PRIVATE_EXTERN 1
+%ifdef __NASM_VERSION_ID__
+    %use smartalign
+    %if __NASM_VERSION_ID__ < 0x020e0000 ; 2.14
+        %define HAVE_PRIVATE_EXTERN 0
     %endif
-%endmacro
+%endif
 
 ; Macros to eliminate most code duplication between x86_32 and x86_64:
 ; Currently this works only for leaf functions which load all their arguments
 ; into registers at the start, and make no other use of the stack. Luckily that
-; covers most of x264's asm.
+; covers most use cases.
 
 ; PROLOGUE:
 ; %1 = number of arguments. loads them from stack if needed.
@@ -232,6 +236,18 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
     %define gprsize 4
 %endif
 
+%macro LEA 2
+%if ARCH_X86_64
+    lea %1, [%2]
+%elif PIC
+    call $+5 ; special-cased to not affect the RSB on most CPU:s
+    pop %1
+    add %1, (%2)-$+1
+%else
+    mov %1, %2
+%endif
+%endmacro
+
 ; Repeats an instruction/operation for multiple arguments.
 ; Example usage: "REPX {psrlw x, 8}, m0, m1, m2, m3"
 %macro REPX 2-* ; operation, args
@@ -303,6 +319,10 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
     %endif
 %endmacro
 
+%if ARCH_X86_64 == 0
+    %define movsxd movifnidn
+%endif
+
 %macro movsxdifnidn 2
     %ifnidn %1, %2
         movsxd %1, %2
@@ -354,7 +374,46 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
 %define vzeroupper_required (mmsize > 16 && (ARCH_X86_64 == 0 || xmm_regs_used > 16 || notcpuflag(avx512)))
 %define high_mm_regs (16*cpuflag(avx512))
 
-%macro ALLOC_STACK 1-2 0 ; stack_size, n_xmm_regs (for win64 only)
+; Large stack allocations on Windows need to use stack probing in order
+; to guarantee that all stack memory is committed before accessing it.
+; This is done by ensuring that the guard page(s) at the end of the
+; currently committed pages are touched prior to any pages beyond that.
+%if WIN64
+    %assign STACK_PROBE_SIZE 8192
+%elifidn __OUTPUT_FORMAT__, win32
+    %assign STACK_PROBE_SIZE 4096
+%else
+    %assign STACK_PROBE_SIZE 0
+%endif
+
+%macro PROBE_STACK 1 ; stack_size
+    %if STACK_PROBE_SIZE
+        %assign %%i STACK_PROBE_SIZE
+        %rep %1 / STACK_PROBE_SIZE
+            mov eax, [rsp-%%i]
+            %assign %%i %%i+STACK_PROBE_SIZE
+        %endrep
+    %endif
+%endmacro
+
+%macro RESET_STACK_STATE 0
+    %ifidn rstk, rsp
+        %assign stack_offset stack_offset - stack_size_padded
+    %else
+        %xdefine rstk rsp
+    %endif
+    %assign stack_size 0
+    %assign stack_size_padded 0
+    %assign xmm_regs_used 0
+%endmacro
+
+%macro ALLOC_STACK 0-2 0, 0 ; stack_size, n_xmm_regs
+    RESET_STACK_STATE
+    %ifnum %2
+        %if mmsize != 8
+            %assign xmm_regs_used %2
+        %endif
+    %endif
     %ifnum %1
         %if %1 != 0
             %assign %%pad 0
@@ -364,16 +423,14 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
             %endif
             %if WIN64
                 %assign %%pad %%pad + 32 ; shadow space
-                %if mmsize != 8
-                    %assign xmm_regs_used %2
-                    %if xmm_regs_used > 8
-                        %assign %%pad %%pad + (xmm_regs_used-8)*16 ; callee-saved xmm registers
-                    %endif
+                %if xmm_regs_used > 8
+                    %assign %%pad %%pad + (xmm_regs_used-8)*16 ; callee-saved xmm registers
                 %endif
             %endif
             %if required_stack_alignment <= STACK_ALIGNMENT
                 ; maintain the current stack alignment
                 %assign stack_size_padded stack_size + %%pad + ((-%%pad-stack_offset-gprsize) & (STACK_ALIGNMENT-1))
+                PROBE_STACK stack_size_padded
                 SUB rsp, stack_size_padded
             %else
                 %assign %%reg_num (regs_used - 1)
@@ -389,6 +446,7 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
                     %xdefine rstkm rstk
                 %endif
                 %assign stack_size_padded stack_size + ((%%pad + required_stack_alignment-1) & ~(required_stack_alignment-1))
+                PROBE_STACK stack_size_padded
                 mov rstk, rsp
                 and rsp, ~(required_stack_alignment-1)
                 sub rsp, stack_size_padded
@@ -399,7 +457,7 @@ DECLARE_REG_TMP_SIZE 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
     %endif
 %endmacro
 
-%macro SETUP_STACK_POINTER 1
+%macro SETUP_STACK_POINTER 0-1 0
     %ifnum %1
         %if %1 != 0 && required_stack_alignment > STACK_ALIGNMENT
             %if %1 > 0
@@ -462,35 +520,62 @@ DECLARE_REG 14, R13, 120
     %endif
 %endmacro
 
-%macro WIN64_PUSH_XMM 0
-    ; Use the shadow space to store XMM6 and XMM7, the rest needs stack space allocated.
-    %if xmm_regs_used > 6 + high_mm_regs
-        movaps [rstk + stack_offset +  8], xmm6
-    %endif
-    %if xmm_regs_used > 7 + high_mm_regs
-        movaps [rstk + stack_offset + 24], xmm7
-    %endif
-    %assign %%xmm_regs_on_stack xmm_regs_used - high_mm_regs - 8
-    %if %%xmm_regs_on_stack > 0
-        %assign %%i 8
-        %rep %%xmm_regs_on_stack
-            movaps [rsp + (%%i-8)*16 + stack_size + 32], xmm %+ %%i
-            %assign %%i %%i+1
-        %endrep
+; Push XMM registers to the stack. If no argument is specified all used register
+; will be pushed, otherwise only push previously unpushed registers.
+%macro WIN64_PUSH_XMM 0-2 ; new_xmm_regs_used, xmm_regs_pushed
+    %if mmsize != 8
+        %if %0 == 2
+            %assign %%pushed %2
+            %assign xmm_regs_used %1
+        %elif %0 == 1
+            %assign %%pushed xmm_regs_used
+            %assign xmm_regs_used %1
+        %else
+            %assign %%pushed 0
+        %endif
+        ; Use the shadow space to store XMM6 and XMM7, the rest needs stack space allocated.
+        %if %%pushed <= 6 + high_mm_regs && xmm_regs_used > 6 + high_mm_regs
+            movaps [rstk + stack_offset +  8], xmm6
+        %endif
+        %if %%pushed <= 7 + high_mm_regs && xmm_regs_used > 7 + high_mm_regs
+            movaps [rstk + stack_offset + 24], xmm7
+        %endif
+        %assign %%pushed %%pushed - high_mm_regs - 8
+        %if %%pushed < 0
+            %assign %%pushed 0
+        %endif
+        %assign %%regs_to_push xmm_regs_used - %%pushed - high_mm_regs - 8
+        %if %%regs_to_push > 0
+            ASSERT (%%regs_to_push + %%pushed) * 16 <= stack_size_padded - stack_size - 32
+            %assign %%i %%pushed + 8
+            %rep %%regs_to_push
+                movaps [rsp + (%%i-8)*16 + stack_size + 32], xmm %+ %%i
+                %assign %%i %%i+1
+            %endrep
+        %endif
     %endif
 %endmacro
 
-%macro WIN64_SPILL_XMM 1
-    %assign xmm_regs_used %1
-    ASSERT xmm_regs_used <= 16 + high_mm_regs
-    %assign %%xmm_regs_on_stack xmm_regs_used - high_mm_regs - 8
-    %if %%xmm_regs_on_stack > 0
-        ; Allocate stack space for callee-saved xmm registers plus shadow space and align the stack.
-        %assign %%pad %%xmm_regs_on_stack*16 + 32
-        %assign stack_size_padded %%pad + ((-%%pad-stack_offset-gprsize) & (STACK_ALIGNMENT-1))
-        SUB rsp, stack_size_padded
+; Allocated stack space for XMM registers and push all, or a subset, of those
+%macro WIN64_SPILL_XMM 1-2 ; xmm_regs_used, xmm_regs_reserved
+    RESET_STACK_STATE
+    %if mmsize != 8
+        %assign xmm_regs_used %1
+        ASSERT xmm_regs_used <= 16 + high_mm_regs
+        %if %0 == 2
+            ASSERT %2 >= %1
+            %assign %%xmm_regs_on_stack %2 - high_mm_regs - 8
+        %else
+            %assign %%xmm_regs_on_stack %1 - high_mm_regs - 8
+        %endif
+        %if %%xmm_regs_on_stack > 0
+            ; Allocate stack space for callee-saved xmm registers plus shadow space and align the stack.
+            %assign %%pad %%xmm_regs_on_stack*16 + 32
+            %assign stack_size_padded %%pad + ((-%%pad-stack_offset-gprsize) & (STACK_ALIGNMENT-1))
+            SUB rsp, stack_size_padded
+        %endif
+        WIN64_PUSH_XMM
     %endif
-    WIN64_PUSH_XMM
 %endmacro
 
 %macro WIN64_RESTORE_XMM_INTERNAL 0
@@ -521,9 +606,7 @@ DECLARE_REG 14, R13, 120
 
 %macro WIN64_RESTORE_XMM 0
     WIN64_RESTORE_XMM_INTERNAL
-    %assign stack_offset (stack_offset-stack_size_padded)
-    %assign stack_size_padded 0
-    %assign xmm_regs_used 0
+    RESET_STACK_STATE
 %endmacro
 
 %define has_epilogue regs_used > 7 || stack_size > 0 || vzeroupper_required || xmm_regs_used > 6+high_mm_regs
@@ -558,12 +641,11 @@ DECLARE_REG 14, R13, 72
 %macro PROLOGUE 2-5+ 0, 0 ; #args, #regs, #xmm_regs, [stack_size,] arg_names...
     %assign num_args %1
     %assign regs_used %2
-    %assign xmm_regs_used %3
     ASSERT regs_used >= num_args
     SETUP_STACK_POINTER %4
     ASSERT regs_used <= 15
     PUSH_IF_USED 9, 10, 11, 12, 13, 14
-    ALLOC_STACK %4
+    ALLOC_STACK %4, %3
     LOAD_IF_USED 6, 7, 8, 9, 10, 11, 12, 13, 14
     %if %0 > 4
         %ifnum %4
@@ -627,7 +709,7 @@ DECLARE_ARG 7, 8, 9, 10, 11, 12, 13, 14
     SETUP_STACK_POINTER %4
     ASSERT regs_used <= 7
     PUSH_IF_USED 3, 4, 5, 6
-    ALLOC_STACK %4
+    ALLOC_STACK %4, %3
     LOAD_IF_USED 0, 1, 2, 3, 4, 5, 6
     %if %0 > 4
         %ifnum %4
@@ -660,11 +742,19 @@ DECLARE_ARG 7, 8, 9, 10, 11, 12, 13, 14
 %endif ;======================================================================
 
 %if WIN64 == 0
-    %macro WIN64_SPILL_XMM 1
+    %macro WIN64_SPILL_XMM 1-2
+        RESET_STACK_STATE
+        %if mmsize != 8
+            %assign xmm_regs_used %1
+        %endif
     %endmacro
     %macro WIN64_RESTORE_XMM 0
+        RESET_STACK_STATE
     %endmacro
-    %macro WIN64_PUSH_XMM 0
+    %macro WIN64_PUSH_XMM 0-2
+        %if mmsize != 8 && %0 >= 1
+            %assign xmm_regs_used %1
+        %endif
     %endmacro
 %endif
 
@@ -705,7 +795,7 @@ DECLARE_ARG 7, 8, 9, 10, 11, 12, 13, 14
 
 BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae, jna, jnae, jb, jbe, jnb, jnbe, jc, jnc, js, jns, jo, jno, jp, jnp
 
-%macro TAIL_CALL 2 ; callee, is_nonadjacent
+%macro TAIL_CALL 1-2 1 ; callee, is_nonadjacent
     %if has_epilogue
         call %1
         RET
@@ -735,22 +825,25 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
 %endmacro
 %macro cglobal_internal 2-3+
     annotate_function_size
-    %if %1
-        %xdefine %%FUNCTION_PREFIX private_prefix
-        %xdefine %%VISIBILITY hidden
-    %else
-        %xdefine %%FUNCTION_PREFIX public_prefix
-        %xdefine %%VISIBILITY
-    %endif
     %ifndef cglobaled_%2
-        %xdefine %2 mangle(%%FUNCTION_PREFIX %+ _ %+ %2)
+        %if %1
+            %xdefine %2 mangle(private_prefix %+ _ %+ %2)
+        %else
+            %xdefine %2 mangle(public_prefix %+ _ %+ %2)
+        %endif
         %xdefine %2.skip_prologue %2 %+ .skip_prologue
         CAT_XDEFINE cglobaled_, %2, 1
     %endif
     %xdefine current_function %2
     %xdefine current_function_section __SECT__
     %if FORMAT_ELF
-        global %2:function %%VISIBILITY
+        %if %1
+            global %2:function hidden
+        %else
+            global %2:function
+        %endif
+    %elif FORMAT_MACHO && HAVE_PRIVATE_EXTERN && %1
+        global %2:private_extern
     %else
         global %2
     %endif
@@ -771,6 +864,8 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
 %macro cglobal_label 1
     %if FORMAT_ELF
         global current_function %+ %1:function hidden
+    %elif FORMAT_MACHO && HAVE_PRIVATE_EXTERN
+        global current_function %+ %1:private_extern
     %else
         global current_function %+ %1
     %endif
@@ -796,15 +891,34 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
     %xdefine %1 mangle(private_prefix %+ _ %+ %1)
     %if FORMAT_ELF
         global %1:data hidden
+    %elif FORMAT_MACHO && HAVE_PRIVATE_EXTERN
+        global %1:private_extern
     %else
         global %1
     %endif
     %1: %2
 %endmacro
 
-; This is needed for ELF, otherwise the GNU linker assumes the stack is executable by default.
 %if FORMAT_ELF
+    ; The GNU linker assumes the stack is executable by default.
     [SECTION .note.GNU-stack noalloc noexec nowrite progbits]
+
+    %ifdef __NASM_VERSION_ID__
+        %if __NASM_VERSION_ID__ >= 0x020e0300 ; 2.14.03
+            %if ARCH_X86_64
+                ; Control-flow Enforcement Technology (CET) properties.
+                [SECTION .note.gnu.property alloc noexec nowrite note align=gprsize]
+                dd 0x00000004  ; n_namesz
+                dd gprsize + 8 ; n_descsz
+                dd 0x00000005  ; n_type = NT_GNU_PROPERTY_TYPE_0
+                db "GNU",0     ; n_name
+                dd 0xc0000002  ; pr_type = GNU_PROPERTY_X86_FEATURE_1_AND
+                dd 0x00000004  ; pr_datasz
+                dd 0x00000002  ; pr_data = GNU_PROPERTY_X86_FEATURE_1_SHSTK
+                dd 0x00000000  ; pr_padding
+            %endif
+        %endif
+    %endif
 %endif
 
 ; Tell debuggers how large the function was.
@@ -828,32 +942,34 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
 ; cpuflags
 
 %assign cpuflags_mmx       (1<<0)
-%assign cpuflags_mmx2      (1<<1) | cpuflags_mmx
-%assign cpuflags_3dnow     (1<<2) | cpuflags_mmx
-%assign cpuflags_3dnowext  (1<<3) | cpuflags_3dnow
-%assign cpuflags_sse       (1<<4) | cpuflags_mmx2
-%assign cpuflags_sse2      (1<<5) | cpuflags_sse
-%assign cpuflags_sse2slow  (1<<6) | cpuflags_sse2
-%assign cpuflags_lzcnt     (1<<7) | cpuflags_sse2
-%assign cpuflags_sse3      (1<<8) | cpuflags_sse2
-%assign cpuflags_ssse3     (1<<9) | cpuflags_sse3
-%assign cpuflags_sse4      (1<<10)| cpuflags_ssse3
-%assign cpuflags_sse42     (1<<11)| cpuflags_sse4
-%assign cpuflags_aesni     (1<<12)| cpuflags_sse42
-%assign cpuflags_avx       (1<<13)| cpuflags_sse42
-%assign cpuflags_xop       (1<<14)| cpuflags_avx
-%assign cpuflags_fma4      (1<<15)| cpuflags_avx
-%assign cpuflags_fma3      (1<<16)| cpuflags_avx
-%assign cpuflags_bmi1      (1<<17)| cpuflags_avx|cpuflags_lzcnt
-%assign cpuflags_bmi2      (1<<18)| cpuflags_bmi1
-%assign cpuflags_avx2      (1<<19)| cpuflags_fma3|cpuflags_bmi2
-%assign cpuflags_avx512    (1<<20)| cpuflags_avx2 ; F, CD, BW, DQ, VL
-%assign cpuflags_avx512icl (1<<25)| cpuflags_avx512
-
-%assign cpuflags_cache32   (1<<21)
-%assign cpuflags_cache64   (1<<22)
-%assign cpuflags_aligned   (1<<23) ; not a cpu feature, but a function variant
-%assign cpuflags_atom      (1<<24)
+%assign cpuflags_mmx2      (1<<1)  | cpuflags_mmx
+%assign cpuflags_3dnow     (1<<2)  | cpuflags_mmx
+%assign cpuflags_3dnowext  (1<<3)  | cpuflags_3dnow
+%assign cpuflags_sse       (1<<4)  | cpuflags_mmx2
+%assign cpuflags_sse2      (1<<5)  | cpuflags_sse
+%assign cpuflags_sse2slow  (1<<6)  | cpuflags_sse2
+%assign cpuflags_lzcnt     (1<<7)  | cpuflags_sse2
+%assign cpuflags_sse3      (1<<8)  | cpuflags_sse2
+%assign cpuflags_ssse3     (1<<9)  | cpuflags_sse3
+%assign cpuflags_sse4      (1<<10) | cpuflags_ssse3
+%assign cpuflags_sse42     (1<<11) | cpuflags_sse4
+%assign cpuflags_aesni     (1<<12) | cpuflags_sse42
+%assign cpuflags_clmul     (1<<13) | cpuflags_sse42
+%assign cpuflags_gfni      (1<<14) | cpuflags_aesni|cpuflags_clmul
+%assign cpuflags_avx       (1<<15) | cpuflags_sse42
+%assign cpuflags_xop       (1<<16) | cpuflags_avx
+%assign cpuflags_fma4      (1<<17) | cpuflags_avx
+%assign cpuflags_fma3      (1<<18) | cpuflags_avx
+%assign cpuflags_bmi1      (1<<19) | cpuflags_avx|cpuflags_lzcnt
+%assign cpuflags_bmi2      (1<<20) | cpuflags_bmi1
+%assign cpuflags_avx2      (1<<21) | cpuflags_fma3|cpuflags_bmi2
+%assign cpuflags_avx512    (1<<22) | cpuflags_avx2 ; F, CD, BW, DQ, VL
+%assign cpuflags_avx512icl (1<<23) | cpuflags_avx512|cpuflags_gfni ; VNNI, IFMA, VBMI, VBMI2, VPOPCNTDQ, BITALG, VAES, VPCLMULQDQ
+
+%assign cpuflags_cache32   (1<<24)
+%assign cpuflags_cache64   (1<<25)
+%assign cpuflags_aligned   (1<<26) ; not a cpu feature, but a function variant
+%assign cpuflags_atom      (1<<27)
 
 ; Returns a boolean value expressing whether or not the specified cpuflag is enabled.
 %define    cpuflag(x) (((((cpuflags & (cpuflags_ %+ x)) ^ (cpuflags_ %+ x)) - 1) >> 31) & 1)
@@ -895,9 +1011,17 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
     %endif
 
     %if ARCH_X86_64 || cpuflag(sse2)
-        CPUNOP amdnop
+        %ifdef __NASM_VERSION_ID__
+            ALIGNMODE p6
+        %else
+            CPU amdnop
+        %endif
     %else
-        CPUNOP basicnop
+        %ifdef __NASM_VERSION_ID__
+            ALIGNMODE nop
+        %else
+            CPU basicnop
+        %endif
     %endif
 %endmacro
 
@@ -971,7 +1095,7 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
 %endmacro
 
 %macro INIT_XMM 0-1+
-    %assign avx_enabled 0
+    %assign avx_enabled FORCE_VEX_ENCODING
     %define RESET_MM_PERMUTATION INIT_XMM %1
     %define mmsize 16
     %define mova movdqa
@@ -983,6 +1107,9 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
     %if WIN64
         AVX512_MM_PERMUTATION 6 ; Swap callee-saved registers with volatile registers
     %endif
+    %xdefine bcstw 1to8
+    %xdefine bcstd 1to4
+    %xdefine bcstq 1to2
 %endmacro
 
 %macro INIT_YMM 0-1+
@@ -996,6 +1123,9 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
     INIT_CPUFLAGS %1
     DEFINE_MMREGS ymm
     AVX512_MM_PERMUTATION
+    %xdefine bcstw 1to16
+    %xdefine bcstd 1to8
+    %xdefine bcstq 1to4
 %endmacro
 
 %macro INIT_ZMM 0-1+
@@ -1009,6 +1139,9 @@ BRANCH_INSTR jz, je, jnz, jne, jl, jle, jnl, jnle, jg, jge, jng, jnge, ja, jae,
     INIT_CPUFLAGS %1
     DEFINE_MMREGS zmm
     AVX512_MM_PERMUTATION
+    %xdefine bcstw 1to32
+    %xdefine bcstd 1to16
+    %xdefine bcstq 1to8
 %endmacro
 
 INIT_XMM
@@ -1106,19 +1239,32 @@ INIT_XMM
     %endif
     %assign %%i 0
     %rep num_mmregs
-        CAT_XDEFINE %%f, %%i, m %+ %%i
+        %xdefine %%tmp m %+ %%i
+        CAT_XDEFINE %%f, %%i, regnumof %+ %%tmp
         %assign %%i %%i+1
     %endrep
 %endmacro
 
-%macro LOAD_MM_PERMUTATION 1 ; name to load from
-    %ifdef %1_m0
+%macro LOAD_MM_PERMUTATION 0-1 ; name to load from
+    %if %0
+        %xdefine %%f %1_m
+    %else
+        %xdefine %%f current_function %+ _m
+    %endif
+    %xdefine %%tmp %%f %+ 0
+    %ifnum %%tmp
+        DEFINE_MMREGS mmtype
         %assign %%i 0
         %rep num_mmregs
-            CAT_XDEFINE m, %%i, %1_m %+ %%i
-            CAT_XDEFINE nn, m %+ %%i, %%i
+            %xdefine %%tmp %%f %+ %%i
+            CAT_XDEFINE %%m, %%i, m %+ %%tmp
             %assign %%i %%i+1
         %endrep
+        %rep num_mmregs
+            %assign %%i %%i-1
+            CAT_XDEFINE m, %%i, %%m %+ %%i
+            CAT_XDEFINE nn, m %+ %%i, %%i
+        %endrep
     %endif
 %endmacro
 
@@ -1224,8 +1370,22 @@ INIT_XMM
         %ifdef cpuname
             %if notcpuflag(%2)
                 %error use of ``%1'' %2 instruction in cpuname function: current_function
-            %elif cpuflags_%2 < cpuflags_sse && notcpuflag(sse2) && __sizeofreg > 8
+            %elif %3 == 0 && __sizeofreg == 16 && notcpuflag(sse2)
                 %error use of ``%1'' sse2 instruction in cpuname function: current_function
+            %elif %3 == 0 && __sizeofreg == 32 && notcpuflag(avx2)
+                %error use of ``%1'' avx2 instruction in cpuname function: current_function
+            %elif __sizeofreg == 16 && notcpuflag(sse)
+                %error use of ``%1'' sse instruction in cpuname function: current_function
+            %elif __sizeofreg == 32 && notcpuflag(avx)
+                %error use of ``%1'' avx instruction in cpuname function: current_function
+            %elif __sizeofreg == 64 && notcpuflag(avx512)
+                %error use of ``%1'' avx512 instruction in cpuname function: current_function
+            %elifidn %1, pextrw ; special case because the base instruction is mmx2,
+                %ifnid %6       ; but sse4 is required for memory operands
+                    %if notcpuflag(sse4)
+                        %error use of ``%1'' sse4 instruction in cpuname function: current_function
+                    %endif
+                %endif
             %endif
         %endif
     %endif
@@ -1267,11 +1427,79 @@ INIT_XMM
             %1 %6, __src2
         %endif
     %elif %0 >= 9
-        __instr %6, %7, %8, %9
+        %if avx_enabled && __sizeofreg >= 16 && %4 == 1
+            %ifnnum regnumof%7
+                %if %3
+                    vmovaps %6, %7
+                %else
+                    vmovdqa %6, %7
+                %endif
+                __instr %6, %6, %8, %9
+            %else
+                __instr %6, %7, %8, %9
+            %endif
+        %else
+            __instr %6, %7, %8, %9
+        %endif
     %elif %0 == 8
-        __instr %6, %7, %8
+        %if avx_enabled && __sizeofreg >= 16 && %4 == 0
+            %xdefine __src1 %7
+            %xdefine __src2 %8
+            %if %5
+                %ifnum regnumof%7
+                    %ifnum regnumof%8
+                        %if regnumof%7 < 8 && regnumof%8 >= 8 && regnumof%8 < 16 && sizeof%8 <= 32
+                            ; Most VEX-encoded instructions require an additional byte to encode when
+                            ; src2 is a high register (e.g. m8..15). If the instruction is commutative
+                            ; we can swap src1 and src2 when doing so reduces the instruction length.
+                            %xdefine __src1 %8
+                            %xdefine __src2 %7
+                        %endif
+                    %endif
+                %elifnum regnumof%8 ; put memory operands in src2 when possible
+                    %xdefine __src1 %8
+                    %xdefine __src2 %7
+                %else
+                    %assign __emulate_avx 1
+                %endif
+            %elifnnum regnumof%7
+                ; EVEX allows imm8 shift instructions to be used with memory operands,
+                ; but VEX does not. This handles those special cases.
+                %ifnnum %8
+                    %assign __emulate_avx 1
+                %elif notcpuflag(avx512)
+                    %assign __emulate_avx 1
+                %endif
+            %endif
+            %if __emulate_avx ; a separate load is required
+                %if %3
+                    vmovaps %6, %7
+                %else
+                    vmovdqa %6, %7
+                %endif
+                __instr %6, %6, %8
+            %else
+                __instr %6, __src1, __src2
+            %endif
+        %else
+            __instr %6, %7, %8
+        %endif
     %elif %0 == 7
-        __instr %6, %7
+        %if avx_enabled && __sizeofreg >= 16 && %5
+            %xdefine __src1 %6
+            %xdefine __src2 %7
+            %ifnum regnumof%6
+                %ifnum regnumof%7
+                    %if regnumof%6 < 8 && regnumof%7 >= 8 && regnumof%7 < 16 && sizeof%7 <= 32
+                        %xdefine __src1 %7
+                        %xdefine __src2 %6
+                    %endif
+                %endif
+            %endif
+            __instr %6, __src1, __src2
+        %else
+            __instr %6, %7
+        %endif
     %else
         __instr %6
     %endif
@@ -1318,8 +1546,8 @@ AVX_INSTR andpd, sse2, 1, 0, 1
 AVX_INSTR andps, sse, 1, 0, 1
 AVX_INSTR blendpd, sse4, 1, 1, 0
 AVX_INSTR blendps, sse4, 1, 1, 0
-AVX_INSTR blendvpd, sse4 ; can't be emulated
-AVX_INSTR blendvps, sse4 ; can't be emulated
+AVX_INSTR blendvpd, sse4, 1, 1, 0 ; last operand must be xmm0 with legacy encoding
+AVX_INSTR blendvps, sse4, 1, 1, 0 ; last operand must be xmm0 with legacy encoding
 AVX_INSTR cmpeqpd, sse2, 1, 0, 1
 AVX_INSTR cmpeqps, sse, 1, 0, 1
 AVX_INSTR cmpeqsd, sse2, 1, 0, 0
@@ -1356,38 +1584,41 @@ AVX_INSTR cmpunordpd, sse2, 1, 0, 1
 AVX_INSTR cmpunordps, sse, 1, 0, 1
 AVX_INSTR cmpunordsd, sse2, 1, 0, 0
 AVX_INSTR cmpunordss, sse, 1, 0, 0
-AVX_INSTR comisd, sse2
-AVX_INSTR comiss, sse
-AVX_INSTR cvtdq2pd, sse2
-AVX_INSTR cvtdq2ps, sse2
-AVX_INSTR cvtpd2dq, sse2
-AVX_INSTR cvtpd2ps, sse2
-AVX_INSTR cvtps2dq, sse2
-AVX_INSTR cvtps2pd, sse2
-AVX_INSTR cvtsd2si, sse2
+AVX_INSTR comisd, sse2, 1
+AVX_INSTR comiss, sse, 1
+AVX_INSTR cvtdq2pd, sse2, 1
+AVX_INSTR cvtdq2ps, sse2, 1
+AVX_INSTR cvtpd2dq, sse2, 1
+AVX_INSTR cvtpd2ps, sse2, 1
+AVX_INSTR cvtps2dq, sse2, 1
+AVX_INSTR cvtps2pd, sse2, 1
+AVX_INSTR cvtsd2si, sse2, 1
 AVX_INSTR cvtsd2ss, sse2, 1, 0, 0
 AVX_INSTR cvtsi2sd, sse2, 1, 0, 0
 AVX_INSTR cvtsi2ss, sse, 1, 0, 0
 AVX_INSTR cvtss2sd, sse2, 1, 0, 0
-AVX_INSTR cvtss2si, sse
-AVX_INSTR cvttpd2dq, sse2
-AVX_INSTR cvttps2dq, sse2
-AVX_INSTR cvttsd2si, sse2
-AVX_INSTR cvttss2si, sse
+AVX_INSTR cvtss2si, sse, 1
+AVX_INSTR cvttpd2dq, sse2, 1
+AVX_INSTR cvttps2dq, sse2, 1
+AVX_INSTR cvttsd2si, sse2, 1
+AVX_INSTR cvttss2si, sse, 1
 AVX_INSTR divpd, sse2, 1, 0, 0
 AVX_INSTR divps, sse, 1, 0, 0
 AVX_INSTR divsd, sse2, 1, 0, 0
 AVX_INSTR divss, sse, 1, 0, 0
 AVX_INSTR dppd, sse4, 1, 1, 0
 AVX_INSTR dpps, sse4, 1, 1, 0
-AVX_INSTR extractps, sse4
+AVX_INSTR extractps, sse4, 1
+AVX_INSTR gf2p8affineinvqb, gfni, 0, 1, 0
+AVX_INSTR gf2p8affineqb, gfni, 0, 1, 0
+AVX_INSTR gf2p8mulb, gfni, 0, 0, 0
 AVX_INSTR haddpd, sse3, 1, 0, 0
 AVX_INSTR haddps, sse3, 1, 0, 0
 AVX_INSTR hsubpd, sse3, 1, 0, 0
 AVX_INSTR hsubps, sse3, 1, 0, 0
 AVX_INSTR insertps, sse4, 1, 1, 0
 AVX_INSTR lddqu, sse3
-AVX_INSTR ldmxcsr, sse
+AVX_INSTR ldmxcsr, sse, 1
 AVX_INSTR maskmovdqu, sse2
 AVX_INSTR maxpd, sse2, 1, 0, 1
 AVX_INSTR maxps, sse, 1, 0, 1
@@ -1397,10 +1628,10 @@ AVX_INSTR minpd, sse2, 1, 0, 1
 AVX_INSTR minps, sse, 1, 0, 1
 AVX_INSTR minsd, sse2, 1, 0, 0
 AVX_INSTR minss, sse, 1, 0, 0
-AVX_INSTR movapd, sse2
-AVX_INSTR movaps, sse
+AVX_INSTR movapd, sse2, 1
+AVX_INSTR movaps, sse, 1
 AVX_INSTR movd, mmx
-AVX_INSTR movddup, sse3
+AVX_INSTR movddup, sse3, 1
 AVX_INSTR movdqa, sse2
 AVX_INSTR movdqu, sse2
 AVX_INSTR movhlps, sse, 1, 0, 0
@@ -1409,19 +1640,19 @@ AVX_INSTR movhps, sse, 1, 0, 0
 AVX_INSTR movlhps, sse, 1, 0, 0
 AVX_INSTR movlpd, sse2, 1, 0, 0
 AVX_INSTR movlps, sse, 1, 0, 0
-AVX_INSTR movmskpd, sse2
-AVX_INSTR movmskps, sse
+AVX_INSTR movmskpd, sse2, 1
+AVX_INSTR movmskps, sse, 1
 AVX_INSTR movntdq, sse2
 AVX_INSTR movntdqa, sse4
-AVX_INSTR movntpd, sse2
-AVX_INSTR movntps, sse
+AVX_INSTR movntpd, sse2, 1
+AVX_INSTR movntps, sse, 1
 AVX_INSTR movq, mmx
 AVX_INSTR movsd, sse2, 1, 0, 0
-AVX_INSTR movshdup, sse3
-AVX_INSTR movsldup, sse3
+AVX_INSTR movshdup, sse3, 1
+AVX_INSTR movsldup, sse3, 1
 AVX_INSTR movss, sse, 1, 0, 0
-AVX_INSTR movupd, sse2
-AVX_INSTR movups, sse
+AVX_INSTR movupd, sse2, 1
+AVX_INSTR movups, sse, 1
 AVX_INSTR mpsadbw, sse4, 0, 1, 0
 AVX_INSTR mulpd, sse2, 1, 0, 1
 AVX_INSTR mulps, sse, 1, 0, 1
@@ -1432,90 +1663,90 @@ AVX_INSTR orps, sse, 1, 0, 1
 AVX_INSTR pabsb, ssse3
 AVX_INSTR pabsd, ssse3
 AVX_INSTR pabsw, ssse3
-AVX_INSTR packsswb, mmx, 0, 0, 0
 AVX_INSTR packssdw, mmx, 0, 0, 0
-AVX_INSTR packuswb, mmx, 0, 0, 0
+AVX_INSTR packsswb, mmx, 0, 0, 0
 AVX_INSTR packusdw, sse4, 0, 0, 0
+AVX_INSTR packuswb, mmx, 0, 0, 0
 AVX_INSTR paddb, mmx, 0, 0, 1
-AVX_INSTR paddw, mmx, 0, 0, 1
 AVX_INSTR paddd, mmx, 0, 0, 1
 AVX_INSTR paddq, sse2, 0, 0, 1
 AVX_INSTR paddsb, mmx, 0, 0, 1
 AVX_INSTR paddsw, mmx, 0, 0, 1
 AVX_INSTR paddusb, mmx, 0, 0, 1
 AVX_INSTR paddusw, mmx, 0, 0, 1
+AVX_INSTR paddw, mmx, 0, 0, 1
 AVX_INSTR palignr, ssse3, 0, 1, 0
 AVX_INSTR pand, mmx, 0, 0, 1
 AVX_INSTR pandn, mmx, 0, 0, 0
 AVX_INSTR pavgb, mmx2, 0, 0, 1
 AVX_INSTR pavgw, mmx2, 0, 0, 1
-AVX_INSTR pblendvb, sse4 ; can't be emulated
+AVX_INSTR pblendvb, sse4, 0, 1, 0 ; last operand must be xmm0 with legacy encoding
 AVX_INSTR pblendw, sse4, 0, 1, 0
-AVX_INSTR pclmulqdq, fnord, 0, 1, 0
-AVX_INSTR pclmulhqhqdq, fnord, 0, 0, 0
-AVX_INSTR pclmulhqlqdq, fnord, 0, 0, 0
-AVX_INSTR pclmullqhqdq, fnord, 0, 0, 0
-AVX_INSTR pclmullqlqdq, fnord, 0, 0, 0
-AVX_INSTR pcmpestri, sse42
-AVX_INSTR pcmpestrm, sse42
-AVX_INSTR pcmpistri, sse42
-AVX_INSTR pcmpistrm, sse42
+AVX_INSTR pclmulhqhqdq, clmul, 0, 0, 0
+AVX_INSTR pclmulhqlqdq, clmul, 0, 0, 0
+AVX_INSTR pclmullqhqdq, clmul, 0, 0, 0
+AVX_INSTR pclmullqlqdq, clmul, 0, 0, 0
+AVX_INSTR pclmulqdq, clmul, 0, 1, 0
 AVX_INSTR pcmpeqb, mmx, 0, 0, 1
-AVX_INSTR pcmpeqw, mmx, 0, 0, 1
 AVX_INSTR pcmpeqd, mmx, 0, 0, 1
 AVX_INSTR pcmpeqq, sse4, 0, 0, 1
+AVX_INSTR pcmpeqw, mmx, 0, 0, 1
+AVX_INSTR pcmpestri, sse42
+AVX_INSTR pcmpestrm, sse42
 AVX_INSTR pcmpgtb, mmx, 0, 0, 0
-AVX_INSTR pcmpgtw, mmx, 0, 0, 0
 AVX_INSTR pcmpgtd, mmx, 0, 0, 0
 AVX_INSTR pcmpgtq, sse42, 0, 0, 0
+AVX_INSTR pcmpgtw, mmx, 0, 0, 0
+AVX_INSTR pcmpistri, sse42
+AVX_INSTR pcmpistrm, sse42
 AVX_INSTR pextrb, sse4
 AVX_INSTR pextrd, sse4
 AVX_INSTR pextrq, sse4
 AVX_INSTR pextrw, mmx2
-AVX_INSTR phaddw, ssse3, 0, 0, 0
 AVX_INSTR phaddd, ssse3, 0, 0, 0
 AVX_INSTR phaddsw, ssse3, 0, 0, 0
+AVX_INSTR phaddw, ssse3, 0, 0, 0
 AVX_INSTR phminposuw, sse4
-AVX_INSTR phsubw, ssse3, 0, 0, 0
 AVX_INSTR phsubd, ssse3, 0, 0, 0
 AVX_INSTR phsubsw, ssse3, 0, 0, 0
+AVX_INSTR phsubw, ssse3, 0, 0, 0
 AVX_INSTR pinsrb, sse4, 0, 1, 0
 AVX_INSTR pinsrd, sse4, 0, 1, 0
 AVX_INSTR pinsrq, sse4, 0, 1, 0
 AVX_INSTR pinsrw, mmx2, 0, 1, 0
-AVX_INSTR pmaddwd, mmx, 0, 0, 1
 AVX_INSTR pmaddubsw, ssse3, 0, 0, 0
+AVX_INSTR pmaddwd, mmx, 0, 0, 1
 AVX_INSTR pmaxsb, sse4, 0, 0, 1
-AVX_INSTR pmaxsw, mmx2, 0, 0, 1
 AVX_INSTR pmaxsd, sse4, 0, 0, 1
+AVX_INSTR pmaxsw, mmx2, 0, 0, 1
 AVX_INSTR pmaxub, mmx2, 0, 0, 1
-AVX_INSTR pmaxuw, sse4, 0, 0, 1
 AVX_INSTR pmaxud, sse4, 0, 0, 1
+AVX_INSTR pmaxuw, sse4, 0, 0, 1
 AVX_INSTR pminsb, sse4, 0, 0, 1
-AVX_INSTR pminsw, mmx2, 0, 0, 1
 AVX_INSTR pminsd, sse4, 0, 0, 1
+AVX_INSTR pminsw, mmx2, 0, 0, 1
 AVX_INSTR pminub, mmx2, 0, 0, 1
-AVX_INSTR pminuw, sse4, 0, 0, 1
 AVX_INSTR pminud, sse4, 0, 0, 1
+AVX_INSTR pminuw, sse4, 0, 0, 1
 AVX_INSTR pmovmskb, mmx2
-AVX_INSTR pmovsxbw, sse4
 AVX_INSTR pmovsxbd, sse4
 AVX_INSTR pmovsxbq, sse4
+AVX_INSTR pmovsxbw, sse4
+AVX_INSTR pmovsxdq, sse4
 AVX_INSTR pmovsxwd, sse4
 AVX_INSTR pmovsxwq, sse4
-AVX_INSTR pmovsxdq, sse4
-AVX_INSTR pmovzxbw, sse4
 AVX_INSTR pmovzxbd, sse4
 AVX_INSTR pmovzxbq, sse4
+AVX_INSTR pmovzxbw, sse4
+AVX_INSTR pmovzxdq, sse4
 AVX_INSTR pmovzxwd, sse4
 AVX_INSTR pmovzxwq, sse4
-AVX_INSTR pmovzxdq, sse4
 AVX_INSTR pmuldq, sse4, 0, 0, 1
 AVX_INSTR pmulhrsw, ssse3, 0, 0, 1
 AVX_INSTR pmulhuw, mmx2, 0, 0, 1
 AVX_INSTR pmulhw, mmx, 0, 0, 1
-AVX_INSTR pmullw, mmx, 0, 0, 1
 AVX_INSTR pmulld, sse4, 0, 0, 1
+AVX_INSTR pmullw, mmx, 0, 0, 1
 AVX_INSTR pmuludq, sse2, 0, 0, 1
 AVX_INSTR por, mmx, 0, 0, 1
 AVX_INSTR psadbw, mmx2, 0, 0, 1
@@ -1524,57 +1755,57 @@ AVX_INSTR pshufd, sse2
 AVX_INSTR pshufhw, sse2
 AVX_INSTR pshuflw, sse2
 AVX_INSTR psignb, ssse3, 0, 0, 0
-AVX_INSTR psignw, ssse3, 0, 0, 0
 AVX_INSTR psignd, ssse3, 0, 0, 0
-AVX_INSTR psllw, mmx, 0, 0, 0
+AVX_INSTR psignw, ssse3, 0, 0, 0
 AVX_INSTR pslld, mmx, 0, 0, 0
-AVX_INSTR psllq, mmx, 0, 0, 0
 AVX_INSTR pslldq, sse2, 0, 0, 0
-AVX_INSTR psraw, mmx, 0, 0, 0
+AVX_INSTR psllq, mmx, 0, 0, 0
+AVX_INSTR psllw, mmx, 0, 0, 0
 AVX_INSTR psrad, mmx, 0, 0, 0
-AVX_INSTR psrlw, mmx, 0, 0, 0
+AVX_INSTR psraw, mmx, 0, 0, 0
 AVX_INSTR psrld, mmx, 0, 0, 0
-AVX_INSTR psrlq, mmx, 0, 0, 0
 AVX_INSTR psrldq, sse2, 0, 0, 0
+AVX_INSTR psrlq, mmx, 0, 0, 0
+AVX_INSTR psrlw, mmx, 0, 0, 0
 AVX_INSTR psubb, mmx, 0, 0, 0
-AVX_INSTR psubw, mmx, 0, 0, 0
 AVX_INSTR psubd, mmx, 0, 0, 0
 AVX_INSTR psubq, sse2, 0, 0, 0
 AVX_INSTR psubsb, mmx, 0, 0, 0
 AVX_INSTR psubsw, mmx, 0, 0, 0
 AVX_INSTR psubusb, mmx, 0, 0, 0
 AVX_INSTR psubusw, mmx, 0, 0, 0
+AVX_INSTR psubw, mmx, 0, 0, 0
 AVX_INSTR ptest, sse4
 AVX_INSTR punpckhbw, mmx, 0, 0, 0
-AVX_INSTR punpckhwd, mmx, 0, 0, 0
 AVX_INSTR punpckhdq, mmx, 0, 0, 0
 AVX_INSTR punpckhqdq, sse2, 0, 0, 0
+AVX_INSTR punpckhwd, mmx, 0, 0, 0
 AVX_INSTR punpcklbw, mmx, 0, 0, 0
-AVX_INSTR punpcklwd, mmx, 0, 0, 0
 AVX_INSTR punpckldq, mmx, 0, 0, 0
 AVX_INSTR punpcklqdq, sse2, 0, 0, 0
+AVX_INSTR punpcklwd, mmx, 0, 0, 0
 AVX_INSTR pxor, mmx, 0, 0, 1
-AVX_INSTR rcpps, sse
+AVX_INSTR rcpps, sse, 1
 AVX_INSTR rcpss, sse, 1, 0, 0
-AVX_INSTR roundpd, sse4
-AVX_INSTR roundps, sse4
+AVX_INSTR roundpd, sse4, 1
+AVX_INSTR roundps, sse4, 1
 AVX_INSTR roundsd, sse4, 1, 1, 0
 AVX_INSTR roundss, sse4, 1, 1, 0
-AVX_INSTR rsqrtps, sse
+AVX_INSTR rsqrtps, sse, 1
 AVX_INSTR rsqrtss, sse, 1, 0, 0
 AVX_INSTR shufpd, sse2, 1, 1, 0
 AVX_INSTR shufps, sse, 1, 1, 0
-AVX_INSTR sqrtpd, sse2
-AVX_INSTR sqrtps, sse
+AVX_INSTR sqrtpd, sse2, 1
+AVX_INSTR sqrtps, sse, 1
 AVX_INSTR sqrtsd, sse2, 1, 0, 0
 AVX_INSTR sqrtss, sse, 1, 0, 0
-AVX_INSTR stmxcsr, sse
+AVX_INSTR stmxcsr, sse, 1
 AVX_INSTR subpd, sse2, 1, 0, 0
 AVX_INSTR subps, sse, 1, 0, 0
 AVX_INSTR subsd, sse2, 1, 0, 0
 AVX_INSTR subss, sse, 1, 0, 0
-AVX_INSTR ucomisd, sse2
-AVX_INSTR ucomiss, sse
+AVX_INSTR ucomisd, sse2, 1
+AVX_INSTR ucomiss, sse, 1
 AVX_INSTR unpckhpd, sse2, 1, 0, 0
 AVX_INSTR unpckhps, sse, 1, 0, 0
 AVX_INSTR unpcklpd, sse2, 1, 0, 0
@@ -1584,8 +1815,41 @@ AVX_INSTR xorps, sse, 1, 0, 1
 
 ; 3DNow instructions, for sharing code between AVX, SSE and 3DN
 AVX_INSTR pfadd, 3dnow, 1, 0, 1
-AVX_INSTR pfsub, 3dnow, 1, 0, 0
 AVX_INSTR pfmul, 3dnow, 1, 0, 1
+AVX_INSTR pfsub, 3dnow, 1, 0, 0
+
+;%1 == instruction
+;%2 == minimal instruction set
+%macro GPR_INSTR 2
+    %macro %1 2-5 fnord, %1, %2
+        %ifdef cpuname
+            %if notcpuflag(%5)
+                %error use of ``%4'' %5 instruction in cpuname function: current_function
+            %endif
+        %endif
+        %ifidn %3, fnord
+            %4 %1, %2
+        %else
+            %4 %1, %2, %3
+        %endif
+    %endmacro
+%endmacro
+
+GPR_INSTR andn, bmi1
+GPR_INSTR bextr, bmi1
+GPR_INSTR blsi, bmi1
+GPR_INSTR blsmsk, bmi1
+GPR_INSTR blsr, bmi1
+GPR_INSTR bzhi, bmi2
+GPR_INSTR crc32, sse42
+GPR_INSTR mulx, bmi2
+GPR_INSTR pdep, bmi2
+GPR_INSTR pext, bmi2
+GPR_INSTR popcnt, sse42
+GPR_INSTR rorx, bmi2
+GPR_INSTR sarx, bmi2
+GPR_INSTR shlx, bmi2
+GPR_INSTR shrx, bmi2
 
 ; base-4 constants for shuffles
 %assign i 0
@@ -1618,15 +1882,11 @@ AVX_INSTR pfmul, 3dnow, 1, 0, 1
     %endmacro
 %endmacro
 
-FMA_INSTR  pmacsww,  pmullw, paddw
-FMA_INSTR  pmacsdd,  pmulld, paddd ; sse4 emulation
-FMA_INSTR pmacsdql,  pmuldq, paddq ; sse4 emulation
+FMA_INSTR pmacsdd,  pmulld,  paddd ; sse4 emulation
+FMA_INSTR pmacsdql, pmuldq,  paddq ; sse4 emulation
+FMA_INSTR pmacsww,  pmullw,  paddw
 FMA_INSTR pmadcswd, pmaddwd, paddd
 
-; tzcnt is equivalent to "rep bsf" and is backwards-compatible with bsf.
-; This lets us use tzcnt without bumping the yasm version requirement yet.
-%define tzcnt rep bsf
-
 ; Macros for consolidating FMA3 and FMA4 using 4-operand (dst, src1, src2, src3) syntax.
 ; FMA3 is only possible if dst is the same as one of the src registers.
 ; Either src2 or src3 can be a memory operand.
@@ -1687,6 +1947,11 @@ FMA4_INSTR fnmsub,   pd, ps, sd, ss
                 %assign %%evex_required 1
             %endif
         %endif
+        %ifnum regnumof%3
+            %if regnumof%3 >= 16 || sizeof%3 > 32
+                %assign %%evex_required 1
+            %endif
+        %endif
         %if %%evex_required
             %6 %%args
         %else
@@ -1711,16 +1976,3 @@ EVEX_INSTR vrcpps,         vrcp14ps,   1 ; EVEX versions have higher precision
 EVEX_INSTR vrcpss,         vrcp14ss,   1
 EVEX_INSTR vrsqrtps,       vrsqrt14ps, 1
 EVEX_INSTR vrsqrtss,       vrsqrt14ss, 1
-
-; workaround: vpbroadcastq is broken in x86_32 due to a yasm bug (fixed in 1.3.0)
-%ifdef __YASM_VER__
-    %if __YASM_VERSION_ID__ < 0x01030000 && ARCH_X86_64 == 0
-        %macro vpbroadcastq 2
-            %if sizeof%1 == 16
-                movddup %1, %2
-            %else
-                vbroadcastsd %1, %2
-            %endif
-        %endmacro
-    %endif
-%endif
diff --git a/media/ffvpx/libavutil/x86/x86util.asm b/media/ffvpx/libavutil/x86/x86util.asm
index d7cd996842f59..836f6afcb8030 100644
--- a/media/ffvpx/libavutil/x86/x86util.asm
+++ b/media/ffvpx/libavutil/x86/x86util.asm
@@ -802,10 +802,6 @@
 %macro PMINSD 3 ; dst, src, tmp/unused
 %if cpuflag(sse4)
     pminsd    %1, %2
-%elif cpuflag(sse2)
-    cvtdq2ps  %1, %1
-    minps     %1, %2
-    cvtps2dq  %1, %1
 %else
     mova      %3, %2
     pcmpgtd   %3, %1
diff --git a/media/ffvpx/libavutil_visibility.h b/media/ffvpx/libavutil_visibility.h
index a5cce0844af20..1ed8d267ad12a 100644
--- a/media/ffvpx/libavutil_visibility.h
+++ b/media/ffvpx/libavutil_visibility.h
@@ -10,10 +10,10 @@
 #define MOZILLA_AVUTIL_VISIBILITY_H
 
 #pragma GCC visibility push(default)
-#include "libavutil/cpu.h"
 
 // We need av_log() to be visible so we can enable assertions in libavcodec.
 #include "libavutil/log.h"
+#include "libavcodec/packet.h"
 
 #pragma GCC visibility pop
 
