commit e0c0e794f0c1debefd9a7eecb7b57ba01faf5008
Author: Daniel Kolesa <daniel@octaforge.org>
Date:   Tue May 16 02:01:52 2023 +0200

    handle utf-8 in qt streams in a qt6-compatible way

diff --git a/apps/launcher/maindialog.cpp b/apps/launcher/maindialog.cpp
index d41cd52..5844384 100644
--- a/apps/launcher/maindialog.cpp
+++ b/apps/launcher/maindialog.cpp
@@ -2,6 +2,7 @@
 
 #include <components/version/version.hpp>
 #include <components/misc/helpviewer.hpp>
+#include <components/misc/utf8qtextstream.hpp>
 
 #include <QDate>
 #include <QMessageBox>
@@ -9,7 +10,6 @@
 #include <QInputDialog>
 #include <QFileDialog>
 #include <QCloseEvent>
-#include <QTextCodec>
 
 #include "playpage.hpp"
 #include "graphicspage.hpp"
@@ -301,7 +301,7 @@ bool Launcher::MainDialog::setupLauncherSettings()
                 return false;
             }
             QTextStream stream(&file);
-            stream.setCodec(QTextCodec::codecForName("UTF-8"));
+            ensureUtf8Encoding(stream);
 
             mLauncherSettings.readFile(stream);
         }
@@ -335,7 +335,7 @@ bool Launcher::MainDialog::setupGameSettings()
             return false;
         }
         QTextStream stream(&file);
-        stream.setCodec(QTextCodec::codecForName("UTF-8"));
+        ensureUtf8Encoding(stream);
 
         mGameSettings.readUserFile(stream);
         file.close();
@@ -361,7 +361,7 @@ bool Launcher::MainDialog::setupGameSettings()
                 return false;
             }
             QTextStream stream(&file);
-            stream.setCodec(QTextCodec::codecForName("UTF-8"));
+            ensureUtf8Encoding(stream);
 
             mGameSettings.readFile(stream);
             file.close();
@@ -563,7 +563,7 @@ bool Launcher::MainDialog::writeSettings()
 
     QTextStream stream(&file);
     stream.setDevice(&file);
-    stream.setCodec(QTextCodec::codecForName("UTF-8"));
+    ensureUtf8Encoding(stream);
 
     mLauncherSettings.writeFile(stream);
     file.close();
diff --git a/apps/wizard/inisettings.cpp b/apps/wizard/inisettings.cpp
index f423f07..ed0488e 100644
--- a/apps/wizard/inisettings.cpp
+++ b/apps/wizard/inisettings.cpp
@@ -160,7 +160,7 @@ bool Wizard::IniSettings::writeFile(const QString &path, QTextStream &stream)
 
     if (file.open(QIODevice::ReadWrite | QIODevice::Truncate | QIODevice::Text)) {
         QTextStream in(&file);
-        in.setCodec(stream.codec());
+        in.setEncoding(stream.encoding());
 
         // Write the updated buffer to an empty file
         in << buffer;
diff --git a/apps/wizard/mainwizard.cpp b/apps/wizard/mainwizard.cpp
index d92f5b0..9034866 100644
--- a/apps/wizard/mainwizard.cpp
+++ b/apps/wizard/mainwizard.cpp
@@ -5,7 +5,6 @@
 #include <QTime>
 #include <QCloseEvent>
 #include <QMessageBox>
-#include <QTextCodec>
 #include <QDir>
 
 #include "intropage.hpp"
@@ -21,6 +20,8 @@
 #include "installationpage.hpp"
 #endif
 
+#include <components/misc/utf8qtextstream.hpp>
+
 using namespace Process;
 
 Wizard::MainWizard::MainWizard(QWidget *parent) :
@@ -152,7 +153,7 @@ void Wizard::MainWizard::setupGameSettings()
             return qApp->quit();
         }
         QTextStream stream(&file);
-        stream.setCodec(QTextCodec::codecForName("UTF-8"));
+        ensureUtf8Encoding(stream);
 
         mGameSettings.readUserFile(stream);
     }
@@ -181,7 +182,7 @@ void Wizard::MainWizard::setupGameSettings()
                 return qApp->quit();
             }
             QTextStream stream(&file);
-            stream.setCodec(QTextCodec::codecForName("UTF-8"));
+            ensureUtf8Encoding(stream);
 
             mGameSettings.readFile(stream);
         }
@@ -214,7 +215,7 @@ void Wizard::MainWizard::setupLauncherSettings()
             return qApp->quit();
         }
         QTextStream stream(&file);
-        stream.setCodec(QTextCodec::codecForName("UTF-8"));
+        ensureUtf8Encoding(stream);
 
         mLauncherSettings.readFile(stream);
     }
@@ -416,7 +417,7 @@ void Wizard::MainWizard::writeSettings()
     }
 
     QTextStream stream(&file);
-    stream.setCodec(QTextCodec::codecForName("UTF-8"));
+    ensureUtf8Encoding(stream);
 
     mGameSettings.writeFile(stream);
     file.close();
@@ -438,7 +439,7 @@ void Wizard::MainWizard::writeSettings()
     }
 
     stream.setDevice(&file);
-    stream.setCodec(QTextCodec::codecForName("UTF-8"));
+    ensureUtf8Encoding(stream);
 
     mLauncherSettings.writeFile(stream);
     file.close();
diff --git a/components/CMakeLists.txt b/components/CMakeLists.txt
index 4e56c7f..808640b 100644
--- a/components/CMakeLists.txt
+++ b/components/CMakeLists.txt
@@ -87,7 +87,7 @@ add_component_dir (esmterrain
     )
 
 add_component_dir (misc
-    constants utf8stream stringops resourcehelpers rng messageformatparser weakcache thread
+    constants utf8stream utf8qtextstream stringops resourcehelpers rng messageformatparser weakcache thread
     )
 
 add_component_dir (debug
diff --git a/components/config/gamesettings.cpp b/components/config/gamesettings.cpp
index 6276e27..ff9046f 100644
--- a/components/config/gamesettings.cpp
+++ b/components/config/gamesettings.cpp
@@ -1,11 +1,11 @@
 #include "gamesettings.hpp"
 #include "launchersettings.hpp"
 
-#include <QTextCodec>
 #include <QDir>
 #include <QRegularExpression>
 
 #include <components/files/configurationmanager.hpp>
+#include <components/misc/utf8qtextstream.hpp>
 
 const char Config::GameSettings::sContentKey[] = "content";
 
@@ -223,7 +223,7 @@ bool Config::GameSettings::isOrderedLine(const QString& line)
 bool Config::GameSettings::writeFileWithComments(QFile &file)
 {
     QTextStream stream(&file);
-    stream.setCodec(QTextCodec::codecForName("UTF-8"));
+    ensureUtf8Encoding(stream);
 
     // slurp
     std::vector<QString> fileCopy;
diff --git a/components/config/gamesettings.cpp.orig b/components/config/gamesettings.cpp.orig
new file mode 100644
index 0000000..1cc6bfd
--- /dev/null
+++ b/components/config/gamesettings.cpp.orig
@@ -0,0 +1,504 @@
+#include "gamesettings.hpp"
+#include "launchersettings.hpp"
+
+#include <QTextCodec>
+#include <QDir>
+#include <QRegularExpression>
+
+#include <components/files/configurationmanager.hpp>
+
+const char Config::GameSettings::sContentKey[] = "content";
+
+Config::GameSettings::GameSettings(Files::ConfigurationManager &cfg)
+    : mCfgMgr(cfg)
+{
+}
+
+void Config::GameSettings::validatePaths()
+{
+    QStringList paths = mSettings.values(QString("data"));
+    Files::PathContainer dataDirs;
+
+    for (const QString &path : paths)
+    {
+        QByteArray bytes = path.toUtf8();
+        dataDirs.push_back(Files::PathContainer::value_type(std::string(bytes.constData(), bytes.length())));
+    }
+
+    // Parse the data dirs to convert the tokenized paths
+    mCfgMgr.processPaths(dataDirs);
+    mDataDirs.clear();
+
+    for (auto & dataDir : dataDirs) {
+        QString path = QString::fromUtf8(dataDir.string().c_str());
+
+        QDir dir(path);
+        if (dir.exists())
+            mDataDirs.append(path);
+    }
+
+    // Do the same for data-local
+    QString local = mSettings.value(QString("data-local"));
+    if (local.length() && local.at(0) == QChar('\"'))
+    {
+        local.remove(0, 1);
+        local.chop(1);
+    }
+
+    if (local.isEmpty())
+        return;
+
+    dataDirs.clear();
+    QByteArray bytes = local.toUtf8();
+    dataDirs.push_back(Files::PathContainer::value_type(std::string(bytes.constData(), bytes.length())));
+
+    mCfgMgr.processPaths(dataDirs);
+
+    if (!dataDirs.empty()) {
+        QString path = QString::fromUtf8(dataDirs.front().string().c_str());
+
+        QDir dir(path);
+        if (dir.exists())
+            mDataLocal = path;
+    }
+}
+
+QStringList Config::GameSettings::values(const QString &key, const QStringList &defaultValues) const
+{
+    if (!mSettings.values(key).isEmpty())
+        return mSettings.values(key);
+    return defaultValues;
+}
+
+bool Config::GameSettings::readFile(QTextStream &stream)
+{
+    return readFile(stream, mSettings);
+}
+
+bool Config::GameSettings::readUserFile(QTextStream &stream)
+{
+    return readFile(stream, mUserSettings);
+}
+
+bool Config::GameSettings::readFile(QTextStream &stream, QMultiMap<QString, QString> &settings)
+{
+    QMultiMap<QString, QString> cache;
+    QRegExp keyRe("^([^=]+)\\s*=\\s*(.+)$");
+
+    while (!stream.atEnd()) {
+        QString line = stream.readLine();
+
+        if (line.isEmpty() || line.startsWith("#"))
+            continue;
+
+        QRegularExpressionMatch match = keyRe.match(line);
+        if (match.hasMatch())
+
+            QString key = match.captured(1).trimmed();
+            QString value = match.captured(2).trimmed();
+
+            // Don't remove composing entries
+            if (key != QLatin1String("data")
+                && key != QLatin1String("fallback-archive")
+                && key != QLatin1String("content")
+                && key != QLatin1String("groundcover")
+                && key != QLatin1String("script-blacklist"))
+                settings.remove(key);
+
+            if (key == QLatin1String("data")
+                || key == QLatin1String("data-local")
+                || key == QLatin1String("resources")
+                || key == QLatin1String("load-savegame"))
+            {
+                // Path line (e.g. 'data=...'), so needs processing to deal with ampersands and quotes
+                // The following is based on boost::io::detail::quoted_manip.hpp, but calling those functions did not work as there are too may QStrings involved
+                QChar delim = '\"';
+                QChar escape = '&';
+
+                if (value.at(0) == delim)
+                {
+                    QString valueOriginal = value;
+                    value = "";
+
+                    for (QString::const_iterator it = valueOriginal.begin() + 1; it != valueOriginal.end(); ++it)
+                    {
+                        if (*it == escape)
+                            ++it;
+                        else if (*it == delim)
+                            break;
+                        value += *it;
+                    }
+                }
+            }
+
+            QStringList values = cache.values(key);
+            values.append(settings.values(key));
+
+            if (!values.contains(value)) {
+                cache.insert(key, value);
+            }
+        }
+    }
+
+    if (settings.isEmpty()) {
+        settings = cache; // This is the first time we read a file
+        validatePaths();
+        return true;
+    }
+
+    // Merge the changed keys with those which didn't
+    settings.unite(cache);
+    validatePaths();
+
+    return true;
+}
+
+bool Config::GameSettings::writeFile(QTextStream &stream)
+{
+    // Iterate in reverse order to preserve insertion order
+    QMapIterator<QString, QString> i(mUserSettings);
+    i.toBack();
+
+    while (i.hasPrevious()) {
+        i.previous();
+
+        // path lines (e.g. 'data=...') need quotes and ampersands escaping to match how boost::filesystem::path uses boost::io::quoted
+        if (i.key() == QLatin1String("data")
+            || i.key() == QLatin1String("data-local")
+            || i.key() == QLatin1String("resources")
+            || i.key() == QLatin1String("load-savegame"))
+        {
+            stream << i.key() << "=";
+
+            // The following is based on boost::io::detail::quoted_manip.hpp, but calling those functions did not work as there are too may QStrings involved
+            QChar delim = '\"';
+            QChar escape = '&';
+            QString string = i.value();
+
+            stream << delim;
+            for (auto it : string)
+            {
+                if (it == delim || it == escape)
+                    stream << escape;
+                stream << it;
+            }
+            stream << delim;
+
+            stream << '\n';
+            continue;
+        }
+
+        stream << i.key() << "=" << i.value() << "\n";
+
+    }
+
+    return true;
+}
+
+bool Config::GameSettings::isOrderedLine(const QString& line)
+{
+    return line.contains(QRegularExpression("^\\s*fallback-archive\\s*="))
+        || line.contains(QRegularExpression("^\\s*fallback\\s*="))
+        || line.contains(QRegularExpression("^\\s*data\\s*="))
+        || line.contains(QRegularExpression("^\\s*data-local\\s*="))
+        || line.contains(QRegularExpression("^\\s*resources\\s*="))
+        || line.contains(QRegularExpression("^\\s*groundcover\\s*="))
+        || line.contains(QRegularExpression("^\\s*content\\s*="));
+}
+
+// Policy:
+//
+// - Always ignore a line beginning with '#' or empty lines; added above a config
+//   entry.
+//
+// - If a line in file exists with matching key and first part of value (before ',',
+//   '\n', etc) also matches, then replace the line with that of mUserSettings.
+// - else remove line
+//
+// - If there is no corresponding line in file, add at the end
+//
+// - Removed content items are saved as comments if the item had any comments.
+//   Content items prepended with '##' are considered previously removed.
+//
+bool Config::GameSettings::writeFileWithComments(QFile &file)
+{
+    QTextStream stream(&file);
+    stream.setCodec(QTextCodec::codecForName("UTF-8"));
+
+    // slurp
+    std::vector<QString> fileCopy;
+    QString line = stream.readLine();
+    while (!line.isNull())
+    {
+        fileCopy.push_back(line);
+        line = stream.readLine();
+    }
+    stream.seek(0);
+
+    // empty file, no comments to keep
+    if (fileCopy.empty())
+        return writeFile(stream);
+
+    // start
+    //   |
+    //   |    +----------------------------------------------------------+
+    //   |    |                                                          |
+    //   v    v                                                          |
+    // skip non-"ordered" lines (remove "ordered" lines)                 |
+    //   |              ^                                                |
+    //   |              |                                                |
+    //   |      non-"ordered" line, write saved comments                 |
+    //   |              ^                                                |
+    //   v              |                                                |
+    // blank or comment line, save in temp buffer <--------+             |
+    //        |                |                           |             |
+    //        |                +------- comment line ------+             |
+    //        v                    (special processing '##')             |
+    //  "ordered" line                                                   |
+    //        |                                                          |
+    //        v                                                          |
+    // save in a separate map of comments keyed by "ordered" line        |
+    //        |                                                          |
+    //        +----------------------------------------------------------+
+    //
+    //
+    QRegExp settingRegex("^([^=]+)\\s*=\\s*([^,]+)(.*)$");
+    std::vector<QString> comments;
+    auto commentStart = fileCopy.end();
+    std::map<QString, std::vector<QString> > commentsMap;
+    for (auto iter = fileCopy.begin(); iter != fileCopy.end(); ++iter)
+    {
+        if (isOrderedLine(*iter))
+        {
+            // save in a separate map of comments keyed by "ordered" line
+            if (!comments.empty())
+            {
+                QRegularExpressionMatch match = settingRegex.match(*iter);
+                if (match.hasMatch())
+                {
+                    commentsMap[match.captured(1) + "=" + match.captured(2)] = comments;
+                    comments.clear();
+                    commentStart = fileCopy.end();
+                }
+                // else do nothing, malformed line
+            }
+
+            *iter = QString(); // "ordered" lines to be removed later
+        }
+        else if ((*iter).isEmpty() || (*iter).contains(QRegExp("^\\s*#")))
+        {
+            // comment line, save in temp buffer
+            if (comments.empty())
+                commentStart = iter;
+
+            // special removed content processing
+            if ((*iter).contains(QRegExp("^##content\\s*=")))
+            {
+                if (!comments.empty())
+                {
+                    commentsMap[*iter] = comments;
+                    comments.clear();
+                    commentStart = fileCopy.end();
+                }
+            }
+            else
+                comments.push_back(*iter);
+
+            *iter = QString(); // assume to be deleted later
+        }
+        else
+        {
+            QRegularExpressionMatch match = settingRegex.match(*iter);
+
+            // blank or non-"ordered" line, write saved comments
+            if (!comments.empty() && match.hasMatch() && settingRegex.captureCount() >= 2
+                && mUserSettings.find(match.captured(1)) != mUserSettings.end())
+            {
+                if (commentStart == fileCopy.end())
+                    throw std::runtime_error("Config::GameSettings: failed to parse settings - iterator is past of end of settings file");
+
+                for (const auto & comment : comments)
+                {
+                    *commentStart = comment;
+                    ++commentStart;
+                }
+                comments.clear();
+                commentStart = fileCopy.end();
+            }
+
+            // keep blank lines and non-"ordered" lines other than comments
+
+            // look for a key in the line
+            if (index == -1 || settingRegex.captureCount() < 2)
+            {
+                // no key or first part of value found in line, replace with a null string which
+                // will be remved later
+                *iter = QString();
+                comments.clear();
+                commentStart = fileCopy.end();
+                continue;
+            }
+
+            // look for a matching key in user settings
+            *iter = QString(); // assume no match
+            QString key = match.captured(1);
+            QString keyVal = match.captured(1) + "=" + match.captured(2);
+            QMultiMap<QString, QString>::const_iterator i = mUserSettings.find(key);
+            while (i != mUserSettings.end() && i.key() == key)
+            {
+                QString settingLine = i.key() + "=" + i.value();
+                QRegularExpressionMatch keyMatch = settingRegex.match(settingLine);
+                if (keyMatch.hasMatch())
+                {
+                    if ((keyMatch.captured(1) + "=" + keyMatch.captured(2)) == keyVal)
+                    {
+                        *iter = settingLine;
+                        break;
+                    }
+                }
+                ++i;
+            }
+        }
+    }
+
+    // comments at top of file
+    for (auto & iter : fileCopy)
+    {
+        if (iter.isNull())
+            continue;
+
+        // Below is based on readFile() code, if that changes corresponding change may be
+        // required (for example duplicates may be inserted if the rules don't match)
+        if (/*(*iter).isEmpty() ||*/ iter.contains(QRegExp("^\\s*#")))
+        {
+            stream << iter << "\n";
+            continue;
+        }
+    }
+
+    // Iterate in reverse order to preserve insertion order
+    QString settingLine;
+    QMapIterator<QString, QString> it(mUserSettings);
+    it.toBack();
+
+    while (it.hasPrevious())
+    {
+        it.previous();
+
+        if (it.key() == QLatin1String("data")
+            || it.key() == QLatin1String("data-local")
+            || it.key() == QLatin1String("resources")
+            || it.key() == QLatin1String("load-savegame"))
+        {
+            settingLine = it.key() + "=";
+
+            // The following is based on boost::io::detail::quoted_manip.hpp, but calling those functions did not work as there are too may QStrings involved
+            QChar delim = '\"';
+            QChar escape = '&';
+            QString string = it.value();
+
+            settingLine += delim;
+            for (auto iter : string)
+            {
+                if (iter == delim || iter == escape)
+                    settingLine += escape;
+                settingLine += iter;
+            }
+            settingLine += delim;
+        }
+        else
+            settingLine = it.key() + "=" + it.value();
+
+        QRegularExpressionMatch match = settingRegex.match(settingLine);
+        if (match.hasMatch())
+        {
+            auto i = commentsMap.find(match.captured(1) + "=" + match.captured(2));
+
+            // check if previous removed content item with comments
+            if (i == commentsMap.end())
+                i = commentsMap.find("##" + match.captured(1) + "=" + match.captured(2));
+
+            if (i != commentsMap.end())
+            {
+                std::vector<QString> cLines = i->second;
+                for (const auto & cLine : cLines)
+                    stream << cLine << "\n";
+
+                commentsMap.erase(i);
+            }
+        }
+
+        stream << settingLine << "\n";
+    }
+
+    // flush any removed settings
+    if (!commentsMap.empty())
+    {
+        auto i = commentsMap.begin();
+        for (; i != commentsMap.end(); ++i)
+        {
+            if (i->first.contains(QRegExp("^\\s*content\\s*=")))
+            {
+                std::vector<QString> cLines = i->second;
+                for (const auto & cLine : cLines)
+                    stream << cLine << "\n";
+
+                // mark the content line entry for future preocessing
+                stream << "##" << i->first << "\n";
+
+                //commentsMap.erase(i);
+            }
+        }
+    }
+
+    // flush any end comments
+    if (!comments.empty())
+    {
+        for (const auto & comment : comments)
+            stream << comment << "\n";
+    }
+
+    file.resize(file.pos());
+
+    return true;
+}
+
+bool Config::GameSettings::hasMaster()
+{
+    bool result = false;
+    QStringList content = mSettings.values(QString(Config::GameSettings::sContentKey));
+    for (int i = 0; i < content.count(); ++i) 
+    {
+        if (content.at(i).endsWith(QLatin1String(".omwgame"), Qt::CaseInsensitive) || content.at(i).endsWith(QLatin1String(".esm"), Qt::CaseInsensitive)) 
+        {
+            result = true;
+            break;
+        }
+    }
+
+    return result;
+}
+
+void Config::GameSettings::setContentList(const QStringList& fileNames)
+{
+    remove(sContentKey);
+    for (const QString& fileName : fileNames)
+    {
+        setMultiValue(sContentKey, fileName);
+    }
+}
+
+QStringList Config::GameSettings::getContentList() const
+{
+    // QMap returns multiple rows in LIFO order, so need to reverse
+    return Config::LauncherSettings::reverse(values(sContentKey));
+}
+
+void Config::GameSettings::clear()
+{
+    mSettings.clear();
+    mUserSettings.clear();
+    mDataDirs.clear();
+    mDataLocal.clear();
+}
+
diff --git a/components/config/launchersettings.cpp.orig b/components/config/launchersettings.cpp.orig
new file mode 100644
index 0000000..b4fbcf8
--- /dev/null
+++ b/components/config/launchersettings.cpp.orig
@@ -0,0 +1,195 @@
+#include "launchersettings.hpp"
+
+#include <QDebug>
+#include <QTextStream>
+#include <QString>
+#include <QRegularExpression>
+#include <QMultiMap>
+
+const char Config::LauncherSettings::sCurrentContentListKey[] = "Profiles/currentprofile";
+const char Config::LauncherSettings::sLauncherConfigFileName[] = "launcher.cfg";
+const char Config::LauncherSettings::sContentListsSectionPrefix[] = "Profiles/";
+const char Config::LauncherSettings::sContentListSuffix[] = "/content";
+
+QStringList Config::LauncherSettings::subKeys(const QString &key)
+{
+    QMultiMap<QString, QString> settings = SettingsBase::getSettings();
+    QStringList keys = settings.uniqueKeys();
+
+    QRegularExpression keyRe("(.+)/");
+
+    QStringList result;
+
+    for (const QString &currentKey : keys)
+    {
+        QRegularExpressionMatch match = keyRe.match(currentKey);
+        if (match.hasMatch())
+        {
+            QString prefixedKey = match.captured(1);
+
+            if(prefixedKey.startsWith(key))
+            {
+                QString subKey = prefixedKey.remove(key);
+                if (!subKey.isEmpty())
+                    result.append(subKey);
+            }
+        }
+    }
+
+    result.removeDuplicates();
+    return result;
+}
+
+
+bool Config::LauncherSettings::writeFile(QTextStream &stream)
+{
+    QString sectionPrefix;
+    QRegExp sectionRe("([^/]+)/(.+)$");
+    QMultiMap<QString, QString> settings = SettingsBase::getSettings();
+
+    QMapIterator<QString, QString> i(settings);
+    i.toBack();
+
+    while (i.hasPrevious()) {
+        i.previous();
+
+        QString prefix;
+        QString key;
+
+        QRegularExpressionMatch match = sectionRe.match(i.key());
+        if (match.hasMatch()) {
+            prefix = match.captured(1);
+            key = match.captured(2);
+        }
+
+        // Get rid of legacy settings
+        if (key.contains(QChar('\\')))
+            continue;
+
+        if (key == QLatin1String("CurrentProfile"))
+            continue;
+
+        if (sectionPrefix != prefix) {
+            sectionPrefix = prefix;
+            stream << "\n[" << prefix << "]\n";
+        }
+
+        stream << key << "=" << i.value() << "\n";
+    }
+
+    return true;
+
+}
+
+QStringList Config::LauncherSettings::getContentLists()
+{
+    return subKeys(QString(sContentListsSectionPrefix));
+}
+
+QString Config::LauncherSettings::makeContentListKey(const QString& contentListName)
+{
+    return QString(sContentListsSectionPrefix) + contentListName + QString(sContentListSuffix);
+}
+
+void Config::LauncherSettings::setContentList(const GameSettings& gameSettings)
+{
+    // obtain content list from game settings (if present)
+    const QStringList files(gameSettings.getContentList());
+
+    // if openmw.cfg has no content, exit so we don't create an empty content list.
+    if (files.isEmpty())
+    {
+        return;
+    }
+
+    // if any existing profile in launcher matches the content list, make that profile the default
+    for (const QString &listName : getContentLists())
+    {
+        if (isEqual(files, getContentListFiles(listName)))
+        {
+            setCurrentContentListName(listName);
+            return;
+        }
+    }
+
+    // otherwise, add content list
+    QString newContentListName(makeNewContentListName());
+    setCurrentContentListName(newContentListName);
+    setContentList(newContentListName, files);
+}
+
+void Config::LauncherSettings::removeContentList(const QString &contentListName)
+{
+    remove(makeContentListKey(contentListName));
+}
+
+void Config::LauncherSettings::setCurrentContentListName(const QString &contentListName)
+{
+    remove(QString(sCurrentContentListKey));
+    setValue(QString(sCurrentContentListKey), contentListName);
+}
+
+void Config::LauncherSettings::setContentList(const QString& contentListName, const QStringList& fileNames)
+{
+    removeContentList(contentListName);
+    QString key = makeContentListKey(contentListName);
+    for (const QString& fileName : fileNames)
+    {
+        setMultiValue(key, fileName);
+    }
+}
+
+QString Config::LauncherSettings::getCurrentContentListName() const
+{
+    return value(QString(sCurrentContentListKey));
+}
+
+QStringList Config::LauncherSettings::getContentListFiles(const QString& contentListName) const
+{
+    // QMap returns multiple rows in LIFO order, so need to reverse
+    return reverse(getSettings().values(makeContentListKey(contentListName)));
+}
+
+QStringList Config::LauncherSettings::reverse(const QStringList& toReverse)
+{
+    QStringList result;
+    result.reserve(toReverse.size());
+    std::reverse_copy(toReverse.begin(), toReverse.end(), std::back_inserter(result));
+    return result;
+}
+
+bool Config::LauncherSettings::isEqual(const QStringList& list1, const QStringList& list2)
+{
+    if (list1.count() != list2.count())
+    {
+        return false;
+    }
+
+    for (int i = 0; i < list1.count(); ++i)
+    {
+        if (list1.at(i) != list2.at(i))
+        {
+            return false;
+        }
+    }
+
+    // if get here, lists are same
+    return true;
+}
+
+QString Config::LauncherSettings::makeNewContentListName()
+{
+    // basically, use date and time as the name  e.g. YYYY-MM-DDThh:mm:ss
+    time_t rawtime;
+    struct tm * timeinfo;
+
+    time(&rawtime);
+    timeinfo = localtime(&rawtime);
+    int base = 10;
+    QChar zeroPad('0');
+    return QString("%1-%2-%3T%4:%5:%6")
+        .arg(timeinfo->tm_year + 1900, 4).arg(timeinfo->tm_mon + 1, 2, base, zeroPad).arg(timeinfo->tm_mday, 2, base, zeroPad)
+        .arg(timeinfo->tm_hour, 2, base, zeroPad).arg(timeinfo->tm_min, 2, base, zeroPad).arg(timeinfo->tm_sec, 2, base, zeroPad);
+}
+
+
diff --git a/components/config/settingsbase.hpp.orig b/components/config/settingsbase.hpp.orig
new file mode 100644
index 0000000..cbae47d
--- /dev/null
+++ b/components/config/settingsbase.hpp.orig
@@ -0,0 +1,118 @@
+#ifndef SETTINGSBASE_HPP
+#define SETTINGSBASE_HPP
+
+#include <QTextStream>
+#include <QStringList>
+#include <QString>
+#include <QRegularExpression>
+#include <QMultiMap>
+
+namespace Config
+{
+    template <class Map>
+    class SettingsBase
+    {
+
+    public:
+        SettingsBase() { mMultiValue = false; }
+        ~SettingsBase() = default;
+
+        inline QString value(const QString &key, const QString &defaultValue = QString()) const
+        {
+            return mSettings.value(key).isEmpty() ? defaultValue : mSettings.value(key);
+        }
+
+        inline void setValue(const QString &key, const QString &value)
+        {
+            QStringList values = mSettings.values(key);
+            if (!values.contains(value))
+                mSettings.insert(key, value);
+        }
+
+        inline void setMultiValue(const QString &key, const QString &value)
+        {
+            QStringList values = mSettings.values(key);
+            if (!values.contains(value))
+                mSettings.insert(key, value);
+        }
+
+        inline void setMultiValueEnabled(bool enable)
+        {
+            mMultiValue = enable;
+        }
+
+        inline void remove(const QString &key)
+        {
+            mSettings.remove(key);
+        }
+
+        Map getSettings() const {return mSettings;} 
+
+        bool readFile(QTextStream &stream)
+        {
+            Map cache;
+
+            QString sectionPrefix;
+
+            QRegExp sectionRe("^\\[([^]]+)\\]");
+            QRegExp keyRe("^([^=]+)\\s*=\\s*(.+)$");
+
+            while (!stream.atEnd()) {
+                QString line = stream.readLine();
+
+                if (line.isEmpty() || line.startsWith("#"))
+                    continue;
+
+                QRegularExpressionMatch sectionMatch = sectionRe.match(line);
+                if (sectionMatch.hasMatch()) {
+                    sectionPrefix = sectionMatch.captured(1);
+                    sectionPrefix.append("/");
+                    continue;
+                }
+
+                QRegularExpressionMatch match = keyRe.match(line);
+                if (match.hasMatch()) {
+
+                    QString key = match.captured(1).trimmed();
+                    QString value = match.captured(2).trimmed();
+
+                    if (!sectionPrefix.isEmpty())
+                        key.prepend(sectionPrefix);
+
+                    mSettings.remove(key);
+
+                    QStringList values = cache.values(key);
+
+                    if (!values.contains(value)) {
+                        if (mMultiValue) {
+                            cache.insert(key, value);
+                        } else {
+                            cache.remove(key);
+                            cache.insert(key, value);
+                        }
+                    }
+                }
+            }
+
+            if (mSettings.isEmpty()) {
+                mSettings = cache; // This is the first time we read a file
+                return true;
+            }
+
+            // Merge the changed keys with those which didn't
+            mSettings.unite(cache);
+            return true;
+        }
+
+        void clear()
+        {
+            mSettings.clear();
+        }
+
+    private:
+        Map mSettings;
+
+        bool mMultiValue;
+    };
+}
+#endif // SETTINGSBASE_HPP
diff --git a/components/contentselector/view/combobox.cpp.orig b/components/contentselector/view/combobox.cpp.orig
new file mode 100644
index 0000000..742e236
--- /dev/null
+++ b/components/contentselector/view/combobox.cpp.orig
@@ -0,0 +1,37 @@
+#include <QString>
+#include <QKeyEvent>
+
+#include "combobox.hpp"
+
+ContentSelectorView::ComboBox::ComboBox(QWidget *parent) :
+    QComboBox(parent)
+{
+    mValidator = new QRegExpValidator(QRegExp("^[a-zA-Z0-9_]*$"), this); // Alpha-numeric + underscore
+    setValidator(mValidator);
+    setEditable(true);
+    setCompleter(nullptr);
+    setEnabled (true);
+
+    setInsertPolicy(QComboBox::NoInsert);
+}
+
+void ContentSelectorView::ComboBox::paintEvent(QPaintEvent *)
+{
+    QStylePainter painter(this);
+    painter.setPen(palette().color(QPalette::Text));
+
+    // draw the combobox frame, focusrect and selected etc.
+    QStyleOptionComboBox opt;
+    initStyleOption(&opt);
+    painter.drawComplexControl(QStyle::CC_ComboBox, opt);
+
+    // draw the icon and text
+    if (!opt.editable && currentIndex() == -1) // <<< we adjust the text displayed when nothing is selected
+        opt.currentText = mPlaceholderText;
+    painter.drawControl(QStyle::CE_ComboBoxLabel, opt);
+}
+
+void ContentSelectorView::ComboBox::setPlaceholderText(const QString &text)
+{
+    mPlaceholderText = text;
+}
diff --git a/components/contentselector/view/combobox.hpp.orig b/components/contentselector/view/combobox.hpp.orig
new file mode 100644
index 0000000..efab683
--- /dev/null
+++ b/components/contentselector/view/combobox.hpp.orig
@@ -0,0 +1,30 @@
+#ifndef COMBOBOX_HPP
+#define COMBOBOX_HPP
+
+#include <QComboBox>
+#include <QStylePainter>
+
+class QString;
+class QRegExpValidator;
+
+namespace ContentSelectorView
+{
+    class ComboBox : public QComboBox
+    {
+        Q_OBJECT
+
+    public:
+        explicit ComboBox (QWidget *parent = nullptr);
+
+        void setPlaceholderText(const QString &text);
+
+    private:
+        QString mPlaceholderText;
+
+    protected:
+        void paintEvent(QPaintEvent *) override;
+        QRegularExpressionValidator* mValidator;
+    };
+}
+
+#endif // COMBOBOX_HPP
diff --git a/components/contentselector/view/contentselector.cpp.orig b/components/contentselector/view/contentselector.cpp.orig
new file mode 100644
index 0000000..6bb8e6e
--- /dev/null
+++ b/components/contentselector/view/contentselector.cpp.orig
@@ -0,0 +1,289 @@
+#include "contentselector.hpp"
+
+#include <components/contentselector/model/esmfile.hpp>
+
+#include <QSortFilterProxyModel>
+
+#include <QMenu>
+#include <QContextMenuEvent>
+
+#include <QClipboard>
+#include <QModelIndex>
+
+ContentSelectorView::ContentSelector::ContentSelector(QWidget *parent) :
+    QObject(parent)
+{
+    ui.setupUi(parent);
+    ui.addonView->setDragDropMode(QAbstractItemView::InternalMove);
+
+    buildContentModel();
+    buildGameFileView();
+    buildAddonView();
+}
+
+void ContentSelectorView::ContentSelector::buildContentModel()
+{
+    QIcon warningIcon(ui.addonView->style()->standardIcon(QStyle::SP_MessageBoxWarning).pixmap(QSize(16, 15)));
+    mContentModel = new ContentSelectorModel::ContentModel(this, warningIcon);
+}
+
+void ContentSelectorView::ContentSelector::buildGameFileView()
+{
+    ui.gameFileView->setVisible (true);
+
+    ui.gameFileView->setPlaceholderText(QString("Select a game file..."));
+
+    connect (ui.gameFileView, SIGNAL (currentIndexChanged(int)),
+             this, SLOT (slotCurrentGameFileIndexChanged(int)));
+
+    ui.gameFileView->setCurrentIndex(-1);
+    ui.gameFileView->setCurrentIndex(0);
+}
+
+class AddOnProxyModel : public QSortFilterProxyModel
+{
+public:
+    explicit AddOnProxyModel(QObject* parent = nullptr) :
+        QSortFilterProxyModel(parent)
+    {}
+
+    bool filterAcceptsRow(int sourceRow, const QModelIndex& sourceParent) const override
+    {
+        static const QString ContentTypeAddon = QString::number((int)ContentSelectorModel::ContentType_Addon);
+
+        QModelIndex nameIndex = sourceModel()->index(sourceRow, 0, sourceParent);
+        const QString userRole = sourceModel()->data(nameIndex, Qt::UserRole).toString();
+
+        return QSortFilterProxyModel::filterAcceptsRow(sourceRow, sourceParent) && userRole == ContentTypeAddon;
+    }
+};
+
+void ContentSelectorView::ContentSelector::buildAddonView()
+{
+    ui.addonView->setVisible (true);
+
+    mAddonProxyModel = new AddOnProxyModel(this);
+    mAddonProxyModel->setFilterRegExp(searchFilter()->text());
+    mAddonProxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
+    mAddonProxyModel->setDynamicSortFilter (true);
+    mAddonProxyModel->setSourceModel (mContentModel);
+
+    connect(ui.searchFilter, SIGNAL(textEdited(QString)), mAddonProxyModel, SLOT(setFilterWildcard(QString)));
+    connect(ui.searchFilter, SIGNAL(textEdited(QString)), this, SLOT(slotSearchFilterTextChanged(QString)));
+
+    ui.addonView->setModel(mAddonProxyModel);
+
+    connect(ui.addonView, SIGNAL(activated(const QModelIndex&)), this, SLOT(slotAddonTableItemActivated(const QModelIndex&)));
+    connect(mContentModel, SIGNAL(dataChanged(const QModelIndex&, const QModelIndex&)), this, SIGNAL(signalAddonDataChanged(QModelIndex,QModelIndex)));
+    buildContextMenu();
+}
+
+void ContentSelectorView::ContentSelector::buildContextMenu()
+{
+    ui.addonView->setContextMenuPolicy(Qt::CustomContextMenu);
+    connect(ui.addonView, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(slotShowContextMenu(const QPoint&)));
+
+    mContextMenu = new QMenu(ui.addonView);
+    mContextMenu->addAction(tr("&Check Selected"), this, SLOT(slotCheckMultiSelectedItems()));
+    mContextMenu->addAction(tr("&Uncheck Selected"), this, SLOT(slotUncheckMultiSelectedItems()));
+    mContextMenu->addAction(tr("&Copy Path(s) to Clipboard"), this, SLOT(slotCopySelectedItemsPaths()));
+}
+
+void ContentSelectorView::ContentSelector::setProfileContent(const QStringList &fileList)
+{
+    clearCheckStates();
+
+    for (const QString &filepath : fileList)
+    {
+        const ContentSelectorModel::EsmFile *file = mContentModel->item(filepath);
+        if (file && file->isGameFile())
+        {
+            setGameFile (filepath);
+            break;
+        }
+    }
+
+    setContentList(fileList);
+}
+
+void ContentSelectorView::ContentSelector::setGameFile(const QString &filename)
+{
+    int index = -1;
+
+    if (!filename.isEmpty())
+    {
+        const ContentSelectorModel::EsmFile *file = mContentModel->item (filename);
+        index = ui.gameFileView->findText (file->fileName());
+
+        //verify that the current index is also checked in the model
+        if (!mContentModel->setCheckState(filename, true))
+        {
+            //throw error in case file not found?
+            return;
+        }
+    }
+
+    ui.gameFileView->setCurrentIndex(index);
+}
+
+void ContentSelectorView::ContentSelector::clearCheckStates()
+{
+    mContentModel->uncheckAll();
+}
+
+void ContentSelectorView::ContentSelector::setEncoding(const QString &encoding)
+{
+    mContentModel->setEncoding(encoding);
+}
+
+void ContentSelectorView::ContentSelector::setContentList(const QStringList &list)
+{
+    if (list.isEmpty())
+    {
+        slotCurrentGameFileIndexChanged (ui.gameFileView->currentIndex());
+    }
+    else
+        mContentModel->setContentList(list);
+}
+
+ContentSelectorModel::ContentFileList
+        ContentSelectorView::ContentSelector::selectedFiles() const
+{
+    if (!mContentModel)
+        return ContentSelectorModel::ContentFileList();
+
+    return mContentModel->checkedItems();
+}
+
+void ContentSelectorView::ContentSelector::addFiles(const QString &path)
+{
+    mContentModel->addFiles(path);
+
+    // add any game files to the combo box
+    for (const QString& gameFileName : mContentModel->gameFiles())
+    {
+        if (ui.gameFileView->findText(gameFileName) == -1)
+        {
+            ui.gameFileView->addItem(gameFileName);
+        }
+    }
+
+    if (ui.gameFileView->currentIndex() != -1)
+        ui.gameFileView->setCurrentIndex(-1);
+
+    mContentModel->uncheckAll();
+}
+
+void ContentSelectorView::ContentSelector::clearFiles()
+{
+    mContentModel->clearFiles();
+}
+
+QString ContentSelectorView::ContentSelector::currentFile() const
+{
+    QModelIndex currentIdx = ui.addonView->currentIndex();
+
+    if (!currentIdx.isValid())
+        return ui.gameFileView->currentText();
+
+    QModelIndex idx = mContentModel->index(mAddonProxyModel->mapToSource(currentIdx).row(), 0, QModelIndex());
+    return mContentModel->data(idx, Qt::DisplayRole).toString();
+}
+
+void ContentSelectorView::ContentSelector::slotCurrentGameFileIndexChanged(int index)
+{
+    static int oldIndex = -1;
+
+    if (index != oldIndex)
+    {
+        if (oldIndex > -1)
+        {
+            setGameFileSelected(oldIndex, false);
+        }
+
+        oldIndex = index;
+
+        setGameFileSelected(index, true);
+        mContentModel->checkForLoadOrderErrors();
+    }
+
+    emit signalCurrentGamefileIndexChanged (index);
+}
+
+void ContentSelectorView::ContentSelector::setGameFileSelected(int index, bool selected)
+{
+    QString fileName = ui.gameFileView->itemText(index);
+    const ContentSelectorModel::EsmFile* file = mContentModel->item(fileName);
+    if (file != nullptr)
+    {
+        QModelIndex index2(mContentModel->indexFromItem(file));
+        mContentModel->setData(index2, selected, Qt::UserRole + 1);
+    }
+}
+
+void ContentSelectorView::ContentSelector::slotAddonTableItemActivated(const QModelIndex &index)
+{
+    // toggles check state when an AddOn file is double clicked or activated by keyboard
+    QModelIndex sourceIndex = mAddonProxyModel->mapToSource (index);
+
+    if (!mContentModel->isEnabled (sourceIndex))
+        return;
+
+    Qt::CheckState checkState = Qt::Unchecked;
+
+    if (mContentModel->data(sourceIndex, Qt::CheckStateRole).toInt() == Qt::Unchecked)
+        checkState = Qt::Checked;
+
+    mContentModel->setData(sourceIndex, checkState, Qt::CheckStateRole);
+}
+
+void ContentSelectorView::ContentSelector::slotShowContextMenu(const QPoint& pos)
+{
+    QPoint globalPos = ui.addonView->viewport()->mapToGlobal(pos);
+    mContextMenu->exec(globalPos);
+}
+
+void ContentSelectorView::ContentSelector::setCheckStateForMultiSelectedItems(bool checked)
+{
+    Qt::CheckState checkState = checked ? Qt::Checked : Qt::Unchecked;
+    for (const QModelIndex& index : ui.addonView->selectionModel()->selectedIndexes())
+    {
+        QModelIndex sourceIndex = mAddonProxyModel->mapToSource(index);
+        if (mContentModel->data(sourceIndex, Qt::CheckStateRole).toInt() != checkState)
+        {
+            mContentModel->setData(sourceIndex, checkState, Qt::CheckStateRole);
+        }
+    }
+}
+
+void ContentSelectorView::ContentSelector::slotUncheckMultiSelectedItems()
+{
+    setCheckStateForMultiSelectedItems(false);
+}
+
+void ContentSelectorView::ContentSelector::slotCheckMultiSelectedItems()
+{
+    setCheckStateForMultiSelectedItems(true);
+}
+
+void ContentSelectorView::ContentSelector::slotCopySelectedItemsPaths()
+{
+    QClipboard *clipboard = QApplication::clipboard();
+    QString filepaths;
+    for (const QModelIndex& index : ui.addonView->selectionModel()->selectedIndexes())
+    {
+        int row = mAddonProxyModel->mapToSource(index).row();
+        const ContentSelectorModel::EsmFile *file = mContentModel->item(row);
+        filepaths += file->filePath() + "\n";
+    }
+
+    if (!filepaths.isEmpty())
+    {
+        clipboard->setText(filepaths);
+    }
+}
+
+void ContentSelectorView::ContentSelector::slotSearchFilterTextChanged(const QString& newText)
+{
+    ui.addonView->setDragEnabled(newText.isEmpty());
+}
diff --git a/components/misc/utf8qtextstream.hpp b/components/misc/utf8qtextstream.hpp
new file mode 100644
index 0000000..37ee2cf
--- /dev/null
+++ b/components/misc/utf8qtextstream.hpp
@@ -0,0 +1,20 @@
+#ifndef MISC_UTF8QTEXTSTREAM_HPP
+#define MISC_UTF8QTEXTSTREAM_HPP
+
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+#include <QTextCodec>
+#endif
+#include <QTextStream>
+
+namespace
+{
+    void ensureUtf8Encoding(QTextStream& stream)
+    {
+#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
+        stream.setCodec(QTextCodec::codecForName("UTF-8"));
+#else
+        stream.setEncoding(QStringConverter::Utf8);
+#endif
+    }
+}
+#endif
