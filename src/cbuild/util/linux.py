# linux kernel packaging helpers


def get_arch(pkg):
    match pkg.profile().arch:
        case "ppc64le" | "ppc64" | "ppc":
            return "powerpc"
        case "aarch64":
            return "arm64"
        case "x86_64":
            return "x86_64"
        case "riscv64":
            return "riscv"
        case "armhf" | "armv7":
            return "arm"
        case "loongarch64" | "loongarch32":
            return "loongarch"
        case _:
            pkg.error(f"unknown linux architecture {pkg.profile().arch}")


def _build_env(pkg, menv, base_env, env):
    renv = dict(menv)
    # needed for efistub
    renv["CBUILD_BYPASS_STRIP_WRAPPER"] = "1"
    if base_env:
        renv.update(base_env)
    if env:
        renv.update(env)
    return renv


def configure(pkg, extra_args=[], build_dir=None, env=None):
    cfgarch = pkg.profile().arch

    for f in pkg.files_path.glob("config-*"):
        pkg.cp(f, ".")

    epoch = pkg.source_date_epoch or 0
    args = []

    if pkg.profile().cross:
        args += [f"CROSS_COMPILE={pkg.profile().triplet}"]

    bdir = build_dir
    if not bdir:
        bdir = pkg.make_dir

    pkg.do(
        "chimera-buildkernel",
        "prepare",
        f"ARCH={get_arch(pkg)}",
        f"CONFIG_FILE=config-{cfgarch}",
        f"OBJDIR={bdir}",
        f"JOBS={pkg.make_jobs}",
        f"EPOCH={epoch}",
        f"SPLIT_DBG={'1' if pkg.build_dbg else '0'}",
        *args,
        *extra_args,
        env=_build_env(pkg, pkg.configure_env, None, env),
    )


def update_configs(pkg, archs, extra_args=[]):
    flavor = "generic"
    for flv in extra_args:
        if flv.startswith("FLAVOR="):
            flavor = flv.removeprefix("FLAVOR=")
    for a in archs:
        with pkg.profile(a):
            with pkg.stamp(f"{a}_config"):
                pkg.log(f"configuring {a}...")
                configure(pkg, extra_args, f"{pkg.make_dir}-{a}")
                pkg.log("now perform other config (press enter once done)")
                input()
                pkg.cp(
                    f"{pkg.make_dir}-{a}/.config",
                    pkg.files_path / f"config-{a}.{flavor}",
                )
    pkg.log_green("SUCCESS: kernel configs have been updated")


def build(pkg, env=None):
    pkg.do(
        "chimera-buildkernel",
        "build",
        env=_build_env(pkg, pkg.make_env, pkg.make_build_env, env),
    )


def install(pkg, env=None):
    pkg.do(
        "chimera-buildkernel",
        "install",
        pkg.chroot_destdir,
        env=_build_env(pkg, pkg.make_env, pkg.make_install_env, env),
    )
    kdest = list(
        (pkg.destdir / "usr/lib/modules").glob(f"{pkg.pkgver}-{pkg.pkgrel}-*")
    )[0]
    # most things get relocated to a distribution directory
    pkg.install_dir(f"{kdest.relative_to(pkg.destdir)}/apk-dist/boot")
    # write the series into a special file...
    with open(kdest / "apk-dist/.apk-series", "w") as sf:
        sf.write(f"{pkg.pkgname}\n")
    # relocate boot files
    for f in (pkg.destdir / "boot").iterdir():
        pkg.mv(f, kdest / "apk-dist/boot")
    # and relocate other distribution files
    for f in kdest.iterdir():
        match f.name:
            case "modules.builtin" | "modules.builtin.modinfo":
                pass
            case "modules.order":
                pass
            case "build" | "apk-dist":
                # this stays where it is
                continue
            case _:
                # generated by depmod
                if f.name.startswith("modules."):
                    f.unlink()
                    continue
        # these get moved to dist always
        pkg.mv(f, f.parent / "apk-dist")


# api to manipulate out of tree modules


def get_version(pkg, expected=None):
    from cbuild.core import paths

    kver = None
    for f in (paths.bldroot() / "usr/lib/modules").iterdir():
        if kver:
            pkg.error(f"kernel version already set: {kver}")
        kver = f.name

    if expected and expected not in kver:
        pkg.error(f"kernel mismatch: {kver} (expected {expected})")

    return kver


def get_modsrc(pkg, modname, modver):
    from cbuild.core import paths

    return paths.bldroot() / f"usr/src/{modname}-{modver}"


def _call_ckms(pkg, kver, *args, tmpfiles=None):
    pkg.do(
        "ckms",
        "-s",
        pkg.chroot_cwd,
        "-k",
        kver,
        *args,
        env={"CBUILD_BYPASS_STRIP_WRAPPER": "1"},
        tmpfiles=tmpfiles,
    )


def ckms_configure(pkg, modname, modver, kver):
    _call_ckms(pkg, kver, "add", f"/usr/src/{modname}-{modver}")


def ckms_build(pkg, modname, modver, kver):
    from cbuild.core import paths

    # check if we have the stuff available
    kpath = paths.keys() / "kernel"
    pkey = kpath / f"{kver}-signing_key.pem"
    cert = kpath / f"{kver}-signing_key.x509"
    tfiles = None
    cargs = []

    # pass the signing key ephemerally via file descriptors
    if pkey.is_file() and cert.is_file():
        tfiles = [pkey, cert]
        cargs += [f"--sign=/tmp/{kver}-signing_key"]

    _call_ckms(
        pkg, kver, *cargs, "build", f"{modname}={modver}", tmpfiles=tfiles
    )


def ckms_install(pkg, modname, modver, kver):
    modbase = "usr/lib/modules"
    moddest = f"{modbase}/{kver}"

    pkg.install_dir(moddest)
    _call_ckms(
        pkg,
        kver,
        "-d",
        pkg.chroot_destdir / modbase,
        "-D",
        "-x",
        "zst",
        "install",
        f"{modname}={modver}",
    )

    mfpath = f"{moddest}/ckms-manifest/{modname}"
    pkg.install_dir(mfpath)
    with open(pkg.destdir / mfpath / modver, "w") as mf:
        for mod in sorted(pkg.destdir.rglob("*.ko*")):
            mf.write(f"{mod.relative_to(pkg.destdir)}\n")

    cdpath = f"{moddest}/ckms-disable/{modname}"
    pkg.install_dir(cdpath)
    (pkg.destdir / cdpath / modver).touch(0o644)

    # and finally relocate to apk-dist
    pkg.install_dir(f"{moddest}/apk-dist")
    for f in (pkg.destdir / moddest).iterdir():
        if f.name == "apk-dist":
            continue
        pkg.mv(f, f.parent / "apk-dist")
